var check = require('check-types')

function lesson(options) {
	if (!(this instanceof lesson)) return new lesson(options);
	
	//if we don't have a UI object, can't continue, error
	if (!(check.object(options) && check.object(options.UI))) {
		throw new TypeError("Argument 'UI' (object) is required, argument should be object.");
	}
	
	this._UI = options.UI;
	
	//SETUP
	//initial setup state
	this._state = this._INIT;
	
	var next = this.next;
	var pre_start = this.pre_start;
	//attach event handler for 'insert' button
	this._UI.insert_button.addEventListener("click", function() {
		pre_start();
	});
	
	//attach even handler for 'next' button
	this._UI.next_button.addEventListener("click", function() {
		next();
	});
	
	//all done with initial setup
	this._state = this._READY;
};

lesson.prototype = {
	//public
	//method used before the start of the lesson
	//	checks user input, gathers state of the UI, etc
	//	does nothing if traversing a lesson
	pre_start : function() {
		if (this._state !== this._READY) {
			//do nothing if we're setting up or in the middle of a lesson
			return;
		}
		
		//get user input to use during the lesson
		this._input_tmp = this._UI.input.get();
		
		//if user input is NaN, then unusable, print error and return
		//NOTE: Number.isNaN() returns true on undefined
		if (Number.isNaN(this._input_tmp)) {
			this._UI.output.set("The input is not a number.\n Please enter a number and press the insert button to insert the number into the array.");
			this._input_tmp = undefined;
			return;
		}
		
		//gather the state of the working array before lesson start
		if (this._UI.array.working.length === this._UI.array.working.size) {
			this._array_full = true;
		} else {
			this._array_full = false;
		}
		
		//change state to enter lesson
		this._state = this._RUN;
		this._step_state = this._STEP_1;
		
		//call the first step in the lesson
		return this.next();
	},
	//public
	//once running the lesson, used to get the next step in the lesson
	//	does nothing if not traversing a lesson
	next : function() {
		if (this._state !== this._RUN) {
			//do nothing as we're not in the lesson yet
			return;
		}
		
		if (this._array_full) {
			//array full case
			
			//create new array step
			if (this._step_state === this._STEP_1) {
				//allocate the new array and store a reference
				this._array_tmp = this._UI.array.get({size:this._UI.array.working.size*2, nodes:0});
				
				//allocate a new tail arrow for the new array
				this._arrow_tmp = this._UI.arrow.get({name:'tail', array:this._array_tmp, index:0});
				
				var message = "Array is full. Allocating new array of twice the length of the old one.";
				this._UI.output.set(message);
				
				this._step_state = this._STEP_2;
				
				return {value:message, done:false};
			}
			
			//create a move pointer, step
			if (this._step_state === this._STEP_2) {
				//allocate a new move arrow, on the old array, at index 0
				this._move_pointer = this._UI.arrow.get({name:'move', array:this._UI.array.working, index:0});
				
				var message = "Creating a move pointer at index 0 on the old array.";
				this._UI.output.set(message);
				
				this._step_state = this._STEP_MOVING;
				
				return {value:message, done:false};
			}
			
			//move content from old array to new array, step
			if (this._step_state === this._STEP_MOVING) {
				//exit condition
				//if the move pointer is pointing at the same index as the tail pointer in the old array
				if (this._move_pointer.index === this._UI.arrow.working.index) {
					var message = "The 'move' pointer is at the same index as the 'tail' pointer on the old array, we've finished moving the values.";
					this._UI.output.set(message);
				
					this._step_state = this._STEP_3;
					return {value:message, done:false};
				}
				
				//else, move the value at the current index
				var src_idx = this._move_pointer.index;
				var dst_idx = this._arrow_tmp.index;
				
				this._UI.array.move(
					{
						from_array: this._UI.array.working,
						from_index: src_idx,
						to_array: this._array_tmp,
						to_index: dst_idx,
					}
				);
				
				this._array_tmp[dst_idx] = this._UI.array.working[src_idx];
				//not removing value from old array, wait until array de-allocates
				
				//increment the move pointer
				this._move_pointer.increment();
				
				//increment the pointer in the new array, since we just put in a new value
				this._arrow_tmp.increment();
				
				var message = "Moved value " + String(this._array_tmp[dst_idx]) + ", from old array to new.";
				this._UI.output.set(message);
				
				return {value:message, done:false};
			}
			
			if (this._step_state === this._STEP_3) {
				//set array_full to false, now that we have a new array with more space
				this._array_full = false;
				
				//remove the old array and arrow from the UI
				this._UI.array.del(this._UI.array.working);
				this._UI.arrow.del(this._UI.arrow.working);
				
				//update the working array, to be the array we just got finished moving to
				this._UI.array.working = this._array_tmp;
				this._UI.arrow.working = this._arrow_tmp;
				this._array_tmp = undefined;
				this._arrow_tmp = undefined;
				
				//remove the 'move' arrow
				this._UI.arrow.del(this._move_pointer);
				this._move_pointer = undefined;
				
				var message = "Removing the old array and the move pointer.";
				this._UI.output.set(message);
				
				//set step and array_full to the appropriate values such that on next()
				//	we will re-use the logic below to copy the value from the input to the new array, that now has room
				this._step_state = this._STEP_1;
				
				return {value:message, done:false};
			}
		} else {
			//array not full case
			
			//move step
			if (this._step_state === this._STEP_1) {
				//move user input from input array to working array, at "tail" pointer location
				this._UI.array.move(
					{
						from_array: this._UI.array.input,
						from_index: 0,	//only a single index in input array
						to_array: this._UI.array.working,
						to_index: this._UI.arrow.working.index,
					}
				);
				
				//moving logic
				//NOTE: instead of using delete using pop(), as delete does not properly update length?
				//delete this._UI.array.input[0];
				this._UI.array.input.pop();
				this._UI.array.working[this._UI.arrow.working.index] = this._input_tmp;
				
				//set output to state what's been done
				var message = "Added the value " + String(this._input_tmp) + " to the array."
				this._UI.output.set(message);
				
				this._input_tmp = undefined;
				
				//increment the step state to do the next step on next()
				this._step_state = this._STEP_2;
				
				return {value:message, done:false};
			}
			
			//tail pointer increment step
			if (this._step_state === this._STEP_2) {
				this._UI.arrow.working.increment();	//increment tail pointer
				
				//set output to state what's been done
				var message = "Moved the 'tail' pointer to index: " + String(this._UI.arrow.working.index) + ", to prepare for the next insertion.";
				this._UI.output.set(message);
				
				//reset step state for next call
				this._step_state = undefined;
				
				//set state of lesson to accept another user input for insertion
				this._state = this._READY;
				
				//return done
				return {value:message, done:true};
			}
		}
	},
	
	//private variables
	_UI : 			undefined,	//local pointer to the UI object
	_input_tmp :	undefined,	//local storage for input while traversing a lesson
	_array_full : 	false,		//marks the case of the array being full or not, causing different lesson logic
	_array_tmp :	undefined,	//holds a reference to a new array object, used on _array_full === true case to allocate a new larger array
	_arrow_tmp :	undefined,	//holds a reference to a new arrow object for the a new array, on _array_full === true case
	_move_pointer : undefined,	//holds a reference to an arrow object, used in copy on _array_full === true case
	
	//state and constants associated
	_RUN : 2,			//currently traversing the lesson
	_READY : 1,			//ready to start the lesson, done with all of the setup, not currently in the lesson
	_INIT : 0,			//initial state, setting up object for lesson, should not be able to interact at this step
	_state : undefined,	//tracks the state of the lesson
	
	//states for when stepping through a lesson
	_STEP_3 : 3,
	_STEP_MOVING : 0,
	_STEP_2 : 2,
	_STEP_1 : 1,
	_step_state : undefined,
};

module.exports = lesson;