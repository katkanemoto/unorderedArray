var check = require('check-types')

function lesson(options) {
	if (!(this instanceof lesson)) return new lesson(options);
	
	//if we don't have a UI object, can't continue, error
	if (!(check.object(options) && check.object(options.UI))) {
		throw new TypeError("Argument 'UI' (object) is required, argument should be object.");
	}
	
	this._UI = options.UI;
	
	//SETUP
	//initial setup state
	this._state = this._INIT;
	
	//setup the UI array used during the lesson
	var result = this._setup_array();
	//array API
	/* //an array of numbers, the values stored in the UI array
	array._.values
	
	//a method to visually add a createjs.Text object to the array
	//	store the Text object inside the the UI array container, as a sub-child along with the ArrayElement object
	array._.push
	
	//a property indicating how large the array can be at maximum
	array._.length
	
	//function that returns an arrow / iterator over the array (requires argument "name" [a non-empty string])
	array._.iterator
	*/
	this._array = result.array;
	//arrow API
	/* //name of arrow, e.g. "tail"
	arrow._.name

	//store the reference of the object the arrow is pointed at
	arrow._.pointed_at
	
	//move the arrow to its next position, update pointed_at, etc (iterator protocol)
	arrow._.next
	
	//add move() functionality
	arrow._.move 
	
	//the index the arrow is pointed at
	arrow._index
	*/
	this._tail_arrow = result.arrow;
	
	//register the UI elements with the UI
	//	only add the array as the arrow is a child of the array component
	this._UI.stage.add(this._array);
	
	var next = this.next;
	var pre_start = this.pre_start;
	var instance = this;
	
	//NOTE: had to use call() here, methods were being called with the window assigned to `this` as they were being called from inside an event handler
	//attach event handler for 'next' button
	this._UI.next_button.addEventListener("click", function() {
		//if we're tweening, do nothing that would involve an animation
		var move = require('lib/util/move');
		if (move.is_moving()) return;
		//if we're in the READY state, then call pre_start to do the checks that need to be done before starting a lesson
		//otherwise, just continue with a lesson in progress
		if (instance._state === instance._READY) {
			pre_start.call(instance);
		} else {
			next.call(instance);
		}
	});
	
	//track if we've already allocated a new array, if so, then can't allocate another
	this._allocated_array = false;
	
	//all done with initial setup
	this._state = this._READY;
};

lesson.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC
	
	//method used before the start of the lesson
	//	checks user input, gathers state of the UI, etc
	//	does nothing if traversing a lesson
	pre_start : function() {
		//do nothing if not in the READY state
		if (this._state !== this._READY) return;
		
		//get user input to use during the lesson
		this._input_tmp = this._UI.input.get();
		
		//if user input is NaN, then unusable, print error and return
		//NOTE: Number.isNaN() returns true on undefined
		if (Number.isNaN(this._input_tmp)) {
			this._UI.output.set(
				"The input is not a number.\n" +
				"Please enter a number and press\n" +
				"the 'Next' button to insert the\n" +
				"number into the array.\n");
			this._input_tmp = undefined;
			return;
		}
		
		//gather the state of the working array before lesson start
		if (this._array._.values.length >= this._array._.length) {
			this._array_full = true;
		} else {
			this._array_full = false;
		}
		
		//change state to enter lesson
		this._state = this._RUN;
		this._step_state = this._STEP_1;
		
		//call the first step in the lesson
		return this.next();
	},
	
	//once running the lesson, used to get the next step in the lesson
	//	does nothing if not traversing a lesson
	next : function() {
		//do nothing if not in the RUN state
		if (this._state !== this._RUN) return;
		/* if (this._state !== this._RUN) {
			var message = "Enter a number above" + "\n" +
				"and press 'Next'.";
			
			this._UI.output.set(message);
			
			//do nothing as we're not in the lesson yet
			return;
		} */
		
		if (this._array_full) {
			//array full case
			
			//create new array step
			if (this._step_state === this._STEP_1) {
				//if we've previously allocated a new array, then shutdown the lesson
				if(this._allocated_array) {
					this._state = this._DONE;
					this._step_state = undefined;
					
					var message = "Lesson finished." + "\n" +
					"We have already allocated a new" + "\n" + 
					"array, the lesson cannot allocate" + "\n" +
					"another.";
					
					this._UI.output.set(message);
					
					return {done:true};
				}
				
				//allocate the new array (twice the size of the old one) and store a reference
				var array_UI = require('lib/UI/array_UI');
				var result = array_UI({length:this._array._.length*2});				 
				this._array_tmp = result.array;
				
				//store the new tail arrow for the new array
				this._arrow_tmp = result.arrow;
				
				//place the new array below the old array, such that it does not overlap the old array or the old tail arrow
				this._array_tmp.x = this._array.x;
				//TODO: replace with with a this._UI.arrow.working.getBounds().height calculation, to make the positioning more dynamic
				this._array_tmp.y = this._array.y + 115;
				
				//add the new array to the stage
				this._UI.stage.add(this._array_tmp);
				
				var message = "Array is full." + "\n" +
				"Allocating new array of twice the" + "\n" + 
				"length of the old one.";
				
				this._UI.output.set(message);
				
				this._step_state = this._STEP_2;
				
				//flag that we've allocated an array, so the lesson won't do it again
				this._allocated_array = true;
				
				return {value:message, done:false};
			}
			
			//create a move pointer, step
			if (this._step_state === this._STEP_2) {
				//allocate a new move arrow, on the old array, at index 0
				this._move_pointer = this._array._.iterator("move");
				
				var message = "Creating a move pointer at index 0" + "\n" + 
					"on the old array.";
				
				this._UI.output.set(message);
				
				this._step_state = this._STEP_MOVING_1;
				
				return {value:message, done:false};
			}
			
			//move content from old array to new array, step
			if (this._step_state === this._STEP_MOVING_1) {
				//move the value at the current index of the move pointer to the new array
				this._array_tmp._.push(this._move_pointer._.pointed_at.children[1]);
				
				var message = "Moved value " + String(this._arrow_tmp._.pointed_at.children[1].text) + ",\n" + 
					"from old array to the new array.";
				
				this._UI.output.set(message);
				
				this._step_state = this._STEP_MOVING_2;
				
				return {value:message, done:false};
			}
			
			//increment the move pointer
			if (this._step_state === this._STEP_MOVING_2) {
				this._move_pointer._.next();
				
				var message = "Incremented the move pointer to" + "\n" + 
					"index " + String(this._move_pointer._.index);
				
				this._UI.output.set(message);
				
				this._step_state = this._STEP_MOVING_3;
				
				return {value:message, done:false};
			}
			
			//increment the pointer in the new array, since we just put in a new value
			if (this._step_state === this._STEP_MOVING_3) {
				this._arrow_tmp._.next();
				
				var message = "Incremented the tail pointer in the" + "\n" + 
					"new array to index " + String(this._arrow_tmp._.index);
				
				this._UI.output.set(message);
				
				//check for the exit codition and potentially loop around to _STEP_MOVING_1 to move other values
				this._step_state = this._STEP_MOVING_4;
				
				return {value:message, done:false};
			}
			
			//check for exit condition
			if (this._step_state === this._STEP_MOVING_4) {
				//if the move pointer is pointing at the same index as the tail pointer in the old array
				if (this._move_pointer._.index === this._tail_arrow._.index) {
					var message = "The 'move' pointer is at the same" + "\n" + 
								  "index as the 'tail' pointer on the" + "\n" +
								  "old array, we've finished moving" + "\n" +
								  "the values.";
								  
					this._UI.output.set(message);
				
					this._step_state = this._STEP_3;
					return {value:message, done:false};
				} else {
					//else loop around to move more values
					var message = "As the 'move' pointer is not at" + "\n" +
								"the same index as the 'tail'" + "\n" +
								"pointer, we need to move at least" + "\n" +
								"one more value from the old array" + "\n" +
								"to the new.";
								  
					this._UI.output.set(message);
				
					this._step_state = this._STEP_MOVING_1;
					return {value:message, done:false};
				}
			}
			
			//remove the old array and the move pointer step
			if (this._step_state === this._STEP_3) {
				//set array_full to false, now that we have a new array with more space
				this._array_full = false;
				
				//remove the old array and arrow from the UI
				/* this._UI.array.del(this._UI.array.working);
				this._UI.arrow.del(this._UI.arrow.working); */
				
				//save the old array's coordinates, so we can tween the new array to that position
				var array_x = this._array.x;
				var array_y = this._array.y;
				
				//remove the old array (and arrow) from the UI
				this._UI.stage.del(this._array);
				
				//remove the 'move' arrow
				this._UI.stage.del(this._move_pointer);
				this._move_pointer = undefined;
				
				//update the working array, to be the array we just got finished moving to
				this._array = this._array_tmp;
				this._tail_arrow = this._arrow_tmp;
				this._array_tmp = undefined;
				this._arrow_tmp = undefined;
				
				//tween the new array to the position of the old
				this._array._.move.to({x:array_x, y:array_y});
				
				var message = "Removing the old array and the" + "\n" +
					"move pointer.";
				this._UI.output.set(message);
				
				//set step and array_full to the appropriate values such that on next()
				//	we will re-use the logic below to copy the value from the input to the new array, that now has room
				this._step_state = this._STEP_1;
				
				return {value:message, done:false};
			}
		} else {
			//array not full case
			
			//move the input from the text input to the array
			if (this._step_state === this._STEP_1) {
				//create a canvas element of the input & clear the input from the HTML input
				var input = this._UI.input.get_canvas_element();
				
				//tween the element to the array & attach it to the array, inputing its value into the array._.values array				
				this._array._.push(input);
				
				//set output to state what's been done
				var message = "Added the value " + String(this._input_tmp) + " to the array."
				this._UI.output.set(message);
				
				this._input_tmp = undefined;
				
				//increment the step state to do the next step on next()
				this._step_state = this._STEP_2;
				
				return {value:message, done:false};
			}
			
			//tail pointer increment step
			if (this._step_state === this._STEP_2) {
				this._tail_arrow._.next();	//increment tail pointer
				
				//set output to state what's been done
				var message;
				
				//the arrow may move beyond the array
				if (this._tail_arrow._.index === this._array._.length) {
					message = "Moved the 'tail' pointer to" + "\n" +
					"the end of the array, there are no" + "\n" +
					"other indices to insert values into.";
				} else {
					message = "Moved the 'tail' pointer to index: " + String(this._tail_arrow._.index) + ",\n" +
					"to prepare for the next insertion.";
				}
				
				this._UI.output.set(message);
				
				//reset step state for next call
				this._step_state = undefined;
				
				//set state of lesson to accept another user input for insertion
				this._state = this._READY;
				
				//return done
				return {value:message, done:true};
			}
		}
	},
	
	//PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE
	
	//sets up an array UI component, for registration with the UI during INIT
	_setup_array : function() {
		var size = 2;
		var array_UI = require('lib/UI/array_UI');
		var result = array_UI({length:size});
		
		//TODO: allow config of positioning
		//positioning array
		result.array.x = 100;
		result.array.y = 150;
		
		return result;
	},
	
	//private variables
	_UI : 			undefined,	//local pointer to the UI object
	_input_tmp :	undefined,	//local storage for input while traversing a lesson
	_array_full : 	false,		//marks the case of the array being full or not, causing different lesson logic
	_array_tmp :	undefined,	//holds a reference to a new array object, used on _array_full === true case to allocate a new larger array
	_arrow_tmp :	undefined,	//holds a reference to a new arrow object for the a new array, on _array_full === true case
	_move_pointer : undefined,	//holds a reference to an arrow object, used in copy on _array_full === true case
	_array : undefined,			//reference to the UI array setup in the constructor and registered with the UI
	_arrow : undefined,			//reference to the UI arrow setup with the array and registered with the UI
	
	//state and constants associated
	_DONE : 3,			//if we can no longer run the lesson, then set this state which makes the lesson unresponsive
	_RUN : 2,			//currently traversing the lesson
	_READY : 1,			//ready to start the lesson, done with all of the setup, not currently in the lesson
	_INIT : 0,			//initial state, setting up object for lesson, should not be able to interact at this step
	_state : undefined,	//tracks the state of the lesson
	
	//states for when stepping through a lesson
	_STEP_3 : 3,
	_STEP_MOVING_3 : 7,	//checking if the movement of values if finished
	_STEP_MOVING_3 : 6,	//incrementing move pointer
	_STEP_MOVING_2 : 5,	//incrementing tail pointer in new array
	_STEP_MOVING_1 : 4,	//moving values between arrays
	_STEP_2 : 2,
	_STEP_1 : 1,
	_step_state : undefined,
};

module.exports = lesson;