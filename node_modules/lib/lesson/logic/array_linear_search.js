var check = require('check-types');

function array_linear_search(options) {
	if (!(this instanceof array_linear_search)) return new array_linear_search(options);
	
	//requires arguments
	if (check.undefined(options)) {
		throw new TypeError("Requires argument object.");
	}
	
	if (check.not.object(options.UI)) {
		throw new TypeError("Required argument: UI, should be object (proxy to control the UI)");
	}
	this._UI = options.UI;
	
	var array_UI = require('lib/UI/array_UI');
	if (!array_UI.is_array(options.array)){
		throw new TypeError("Required argument: array, should be type array_UI.");
	}
	this._array = options.array;
	
	var arrow_UI = require('lib/UI/arrow_UI');
	if (!arrow_UI.is_arrow(options.arrow)) {
		throw new TypeError("Required argument: arrow, should be type arrow_UI");
	}
	this._arrow = options.arrow;
	
	this._state = this._READY;
};

array_linear_search.prototype = {
	//public function to handle calling internal lesson logic
	next : function() {
		return this._next({UI: this._UI, array:this._array, arrow:this._arrow});
	},
	
	//PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE
	_next : function(options) {
		var UI = options.UI;		
		var array = options.array;
		var arrow = options.arrow;
		
		//pre-lesson logic
		//	checks user input, gathers state of the UI, etc
		if (this._state === this._READY) {
			//get user input to use during the lesson
			this._input_tmp = UI.input.get();
			
			//if user input is NaN, then unusable, print error and return
			//NOTE: Number.isNaN() returns true on undefined
			if (Number.isNaN(this._input_tmp)) {
				UI.output.set(
					"The input is not a number.\n" +
					"Please enter a number and press\n" +
					"the 'Next' button to begin the\n" +
					"lesson.\n");
				this._input_tmp = undefined;
				return;
			}
			
			//after we've got the input, then disable the text input, until we're ready for another lesson
			UI.input.self._.htmlElement.disabled = true;
			
			//change state to enter lesson
			this._state = this._RUN;
			this._step_state = this._STEP_1;
		}
		
		//do nothing if not in the RUN state
		if (this._state !== this._RUN) return false;
			
		//state what we're doing
		if (this._step_state === this._STEP_1) {
			//save the original position, to restore after this step
			var original_y = UI.output.self.y;
			
			var output = "We'll allocate a find arrow, then" + "\n" +
						"look through each item in the array" + "\n" +
						"for the value: " + String(this._input_tmp) + ", if we found it" + "\n" + 
						"then we'll report which index it was" + "\n" +
						"found in, if we didn't then we'll" + "\n" +
						"report an error.";
			
			//adjust the text output to make room for the overview
			UI.output.self.y -= 20;
			
			UI.output.set(output);
			
			this._step_state = this._STEP_2;
			
			//restore the text output to its original position
			UI.output.self.y = original_y;
			
			return {value:output, done:false};
		}
		
		//allocate a find arrow
		if (this._step_state === this._STEP_2) {
			var output = "Allocating a 'find' arrow" + "\n" +
			"and pointing at the start of the"  + "\n" +
			"array.";
			
			this._find_arrow = array._.iterator("find");
			array.addChild(this._find_arrow);
			
			UI.output.set(output);
			
			this._step_state = this._STEP_SEARCHING_1;
			
			return {value:output, done:false};
		}
		
		//check the current item for a match to what we're searching for
		//OR
		//we're at the end of the array so we didn't find it
		if (this._step_state === this._STEP_SEARCHING_1) {
			//end of the array / not found case
			if (this._find_arrow._.index === this._arrow._.index) {
				var output = "The 'find' arrow is pointing to the" + "\n" +
				"same place as the 'tail' arrow" + "\n" +
				"which means we're at the end of" + "\n" +
				"the array and did not find the" + "\n" +
				"value: " + String(this._input_tmp);
				
				UI.output.set(output);
				
				this._step_state = this._STEP_END_NOT_FOUND;
				
				return {value:output, done:false};
			}
			
			var current_index = this._find_arrow._.index;
			var output = "Is the value at the index of the 'find'" + "\n" +
			"arrow " + "(" + String(array._.values[current_index]) + ")" + " equal to what we're" + "\n" +
			"searching for " + "(" + String(this._input_tmp) + ")?";
			
			if (array._.values[current_index] === this._input_tmp) {
				//found case
				this._step_state = this._STEP_END_FOUND;
			} else {
				this._step_state = this._STEP_SEARCHING_2;
			}
			
			UI.output.set(output);
			
			return {value:output, done:false};
		}
		
		//not found, so check the next index
		if (this._step_state === this._STEP_SEARCHING_2) {
			var current_index = this._find_arrow._.index;
			var output = String(array._.values[current_index]) + " != " + String(this._input_tmp) + ", so increment the 'find' arrow"  + "\n" +
			"to the next index and check if we've" + "\n" +
			"found the value there.";
			
			this._find_arrow._.next();
			
			this._step_state = this._STEP_SEARCHING_1;
			
			UI.output.set(output);
			
			return {value:output, done:false};
		}
		
		//found at the current index case
		if (this._step_state === this._STEP_END_FOUND) {
			var current_index = this._find_arrow._.index;
			var output = "We found it! We'd then report that" + "\n" +
			"we found the value (" + String(this._input_tmp) + ")" + "\n" +
			"at index: " + String(current_index) + ".";
			
			//record the index we found
			this._found_index = current_index;
			
			this._step_state = this._STEP_CLEANUP;
			
			UI.output.set(output);
			
			return {value:output, done:false};
		}
		
		//not found in the array case
		if (this._step_state === this._STEP_END_NOT_FOUND) {
			var output = "Which means we could not find it" + "\n" +
			"in the array." + "\n" +
			"We'd then report an error.";
			
			this._step_state = this._STEP_CLEANUP;
			
			UI.output.set(output);
			
			return {value:output, done:false};
		}
		
		//cleanup step
		if (this._step_state === this._STEP_CLEANUP) {
			var output = "Deallocating the 'find' arrow," + "\n" +
			"to clean up before the next search.";
			
			array.removeChild(this._find_arrow);
			
			this._step_state = undefined;
			this._state = this._READY;
			
			UI.output.set(output);
			
			//re-enabling the text input to get input for the next lesson
			UI.input.self._.htmlElement.disabled = false;
			
			var found_index = this._found_index;
			return {value: {index:found_index}, done:true};
		}
	},
	
	//PROPERTIES
	//PRIVATE
	
	//state and constants associated
	_DONE : 3,					//if we can no longer run the lesson, then set this state which makes the lesson unresponsive
	_RUN : 2,					//currently traversing the lesson
	_READY : 1,					//ready to start the lesson, done with all of the setup, not currently in the lesson
	_INIT : 0,					//initial state, setting up object for lesson, should not be able to interact at this step
	_state : undefined,			//tracks the state of the lesson
	_found_index : undefined,	//set to the value of any index that the lesson finds if searching for a value
	
	//states for when stepping through a lesson
	_STEP_CLEANUP		: 6,
	_STEP_END_NOT_FOUND	: 5,
	_STEP_END_FOUND		: 4,
	_STEP_SEARCHING_2	: 3,
	_STEP_SEARCHING_1	: 2,
	_STEP_2 			: 1,
	_STEP_1 			: 0,
	_step_state : undefined,
	
	_UI : 			undefined,	//holds a reference to the required argument UI (the proxy to control the UI)
	_array :		undefined,	//holds a reference to the required array (the UI component to traverse during the lesson)
	_arrow :		undefined,	//holds a reference to the required arrow (the "tail" arrow of the array)
	_input_tmp :	undefined,	//used to hold user input during the lesson
	_find_arrow : 	undefined,	//reference to the find arrow, used during the lesson
};

module.exports = array_linear_search;