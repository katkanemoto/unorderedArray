module.exports = place;

//allows setting of convenience methods on object
//such that we can position a Shape(like) object:
//shape.place.(a position near)(other_shape)

var check = require('check-types');

function place(context, options) {
	if (!(this instanceof place)) return new place(context, options);
	
	this._argument_check(context);
	
	this._context = context;
}

place.prototype = {
	//NOTE: in all setter methods, we use the idiom:
	//	shape.x = target.x - shape.bounds.(x, y)
	//	this is to take into account the special requirements of positioning circles correctly
	//	circles are placed with their center at their (x, y) coordinate, while rectangles are placed with their top left hand corner at their (x, y)
	//	thus when we set bounds we include the amount of offset in x and y between the center of the circle and the top left hand corner of the circle
	//	thus if we subtract the values from their bounds, we get positive amounts of offset
	//	that is required to place the circles directly under other figures, without overlap
	
	//shape.place.under(other_shape);
	//adjust position of shape, such that it is directly below other_shape
	below : function(target) {
		this._argument_check(target);
		
		this._context.x = target.x - this._context.getBounds().x;
		this._context.y = target.y + target.getBounds().height - this._context.getBounds().y;
	},
	
	//shape.place.above(other_shape);
	//adjust position of shape, such that it is directly above other_shape
	above : function(target) {
		this._argument_check(target);
		
		this._context.x = target.x - this._context.getBounds().x;
		this._context.y = target.y + this._context.getBounds().y;
	},
	
	//TODO: for left and right positioning, align circular shapes with the centers of their targets
	//	maybe some sort of transform such that the x and y position of circles is counted as their top left corners?
	
	//shape.place.to_the_left_of(other_shape);
	//adjust position of shape, such that it is directly to the left of other_shape
	to_the_left_of : function(target) {
		this._argument_check(target);
		
		this._context.x = target.x + this._context.getBounds().x;
		this._context.y = target.y
	},
	
	//shape.place.to_the_right_of(other_shape);
	//adjust position of shape, such that it is directly to the right of other_shape
	to_the_right_of : function(target) {
		this._argument_check(target);
		
		this._context.x = target.x + target.getBounds().width - this._context.getBounds().x;
		this._context.y = target.y;
	},
	
	_argument_check : function(obj) {
		if (check.undefined(obj.x) || check.undefined(obj.y)) {
			throw new TypeError("argument should be like a createjs.Shape (needs x and y properties).");
		}
		
		if(check.null(obj.getBounds())) {
			throw new ReferenceError("argument should have bounds set, such that getBounds() returns object.");
		}
	},
	
	//private
	//holds the reference to the Shape to manipulate with functions ^
	_context : undefined,
}