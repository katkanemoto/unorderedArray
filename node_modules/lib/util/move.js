//tween an object from one location to another
//	if another move is already taking place, then do nothing (mutex)

var check = require('check-types');

var _is_moving = false;

//source should be an object to be tweened, with position values (x, y)
//destination should be an object with coordinates ({x:value, y:value})
//	optional: duration, a numeric value for how long the tween should take
function move(options) {
	if (!check.object(options)) {
		throw new TypeError('Requires argument, object');
	}
	
	if (!(check.object(options.source) && check.object(options.destination) && check.object(options.createjs))) {
		throw new TypeError('Requires object options: source, destination, createjs.');
	}
	
	var source = options.source;
	var destination = options.destination;
	var createjs = options.createjs;
	
	//if destination has a property, then source should as well, if not then error
	//	specifically numeric properties (x, y)
	for (property in destination) {
		if (!(check.number(destination[property]))) {
			throw new TypeError("Argument '" + String(property) + "', should be numeric.");
		}
		
		if (check.undefined(source[property])) {
			throw new TypeError("Argument '" + String(property) + "', is not present on 'source' to tween.");
		}
		
		if (!check.number(source[property])) {
			throw new TypeError("Argument '" + String(property) + "', on 'source' is not numeric.");
		}
	}
	
	var duration = 1000;	//1 second default tween duration
	if (check.number(options.duration) && options.duration > 0) {
		//else use an optional duration for the tween
		duration = options.duration;
	}
	
	if (_is_moving) {
		//if we're currently tweening, then do nothing
		return false;
	} else {
		_is_moving = true;
		createjs.Tween.get(source).to({x:destination.x, y:destination.y}, duration).call(function() {
			//once tween is finished, then unlock the mutex to allow other tweens to execute
			_is_moving = false;
		});
		return true;
	}
}

module.exports = move;