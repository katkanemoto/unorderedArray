//tween an object from one location to another
//	if another move is already taking place, then do nothing (mutex)

//move() is decorated on to an object with the idiom:
//	source_object._.move.to(destination)
//(see below for method definitions)

var check = require('check-types');
var primitives = require("lib/util/primitives");

//internal mutex, tracks if an animation is currently occuring
var _is_moving = false;

//source should be an object to be tweened, with position values (x, y)
//destination arguments (methods, below) should be an object with properties (coordinates) ({x:value, y:value})
//	optional: duration, a numeric value for how long the tween should take (set in the constructor, but can be overriden on methods, below)
function move(source, options) {
	if (!(this instanceof move)) return new move(source, options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._argument_check(source);
	this._source = source;
	
	//1 second default tween duration
	this._duration = 1000;
	if (check.object(options) && check.number(options.duration) && options.duration >= 0) {
		//else use an optional duration for the tween
		this._duration = options.duration;
	}
}

move.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//TODO: add functionality to only tween a single property at a time
	//	(only requires x or y, but not both and only the set one is used)
	
	//private
	//check if arg is an object and has properties (x, y), if not then throws with informative error
	//(all methods should have this type of argument)
	_argument_check : function(arg) {
		if (check.not.object(arg)) {
			throw new TypeError('Requires argument, object');
		}
		
		if (check.undefined(arg.x) || check.not.number(arg.x)) {
			throw new TypeError("Argument requires numeric property x.");
		}
		
		if (check.undefined(arg.y) || check.not.number(arg.y)) {
			throw new TypeError("Argument requires numeric property y.");
		}
		
		return true;
	},
	
	//public
	//tween an object (source, as passed to constructor, above) to a destination (an object with (x, y) properties)
	//	taking an optional duration argument
	to : function(destination, options) {
		this._argument_check(destination);
		
		var duration = this._duration;
		if (check.object(options) && check.number(options.duration) && options.duration > 0) {
			//else use an optional duration for the tween
			duration = options.duration;
		}
		
		if (_is_moving) {
			//if we're currently tweening, then do nothing
			return false;
		} else {
			_is_moving = true;
			createjs.Tween.get(this._source).to({x:destination.x, y:destination.y}, duration).call(function() {
				//once tween is finished, then unlock the mutex to allow other tweens to execute
				_is_moving = false;
			});
			return true;
		}
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,	//reference to the createjs object used to Tween
	_source : undefined,	//the object to be move()d
	_duration : undefined,	//the amount of time a tween should take (can be overriden in each method)
};

//static method, returns if a tween is currently occuring
move.is_moving = function() {
	return _is_moving;
}

module.exports = move;