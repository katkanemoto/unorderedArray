//duck typing
//takes an object with properties of:
//	obj._.htmlElement (of type Element)
//	obj.htmlElement (of type Element)
//	obj.children (where append_to() calls append_to() on the children, if they have such a function)
//returns a function that either:
//	appends an html object to a parent html object in the dom (via appendChild())
//	calls append_to() on its children, if it has any
//the function accepts an html element
//	the html is then appended to an html element on the DOM
//		(or passed to child append_to() on a recursive call)
//	or an error is thrown if the object passed is not a valid html element
//source:https://github.com/substack/browserify-handbook#reusable-components

var check = require('check-types');

function append_to(obj) {
	if(!check.object(obj)) {
		throw new TypeError("Incorrect argument type, requires Object.");
	}
	
	//used to point to the correct HTML element, given the different forms the object can take (as below)
	var child_node;
	
	//the function used to apply an html Element (or container of one) directly to an Element in the DOM
	function direct_append_to(target) {
		if( !(check.instanceStrict(target, Element)) ) {
			throw new TypeError("Incorrect argument type, requires HTML Element.");
		}
		
		target.appendChild(child_node);
	}
	
	//form: obj.htmlElement
	if (!check.undefined(obj.htmlElement)) {
		if(check.instanceStrict(obj.htmlElement, Element)) {
			child_node = obj.htmlElement;
			return direct_append_to;	//return the function used to append the Element to the DOM
		} else {
			throw new TypeError("Incorrect property type, obj.htmlElement should be of type: HTML Element.");
		}
	}
	
	//form: obj._.htmlElement
	if (check.object(obj._)) {
		if (!check.undefined(obj._.htmlElement)) {
			if (check.instanceStrict(obj._.htmlElement, Element)) {
				child_node = obj._.htmlElement;
				return direct_append_to;	//return the function used to append the Element to the DOM
			} else {
				throw new TypeError("Incorrect property type, obj._.htmlElement should be of type: HTML Element.");
			}
		}
	}
	
	//function to use on containers, calls child append_to() functions on children
	//	will error at run time if not all children have an append_to function
	function indirect_append_to(target) {
		if( !(check.instanceStrict(target, Element)) ) {
			throw new TypeError("Incorrect argument type, requires HTML Element.");
		}
		
		//iterate through the children, append_to() on each, so we attach all HTML / DOMElement children to target
		//	(assuming that append_to() has been applied to the ._. namepsace)
		for (var i = 0; i < obj.children.length; i++) {
			if ( check.function(obj.children[i]._.append_to) ) {
				obj.children[i]._.append_to(target);
			} /* else {
				var type_of = require('lib/util/type_of');
				throw new TypeError('append_to on child ' + String(i) + ' was of type: ' + type_of(obj.children[i]._.append_to) + ', expected function.');
			} */
		}
	}
	
	//form: obj.children
	if (!check.undefined(obj.children)) {
		if(check.array(obj.children)) {
			return indirect_append_to;
		} else {
			throw new TypeError("Property 'children' should be of type array.");
		}
	}
	
	throw new TypeError("Object was of incorrect form, see documentation for acceptable forms.");
};

module.exports = append_to;