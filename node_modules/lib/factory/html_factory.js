//create a variety of HTML input controls
//each element is created via the document global then wrapped in a createjs.DOMElement for positioning through createjs
//then the DOMElement and an optional text field are wrapped in a createjs.Container
//each container is then appended with properties / methods:
//	allow access to the underlying HTML
//	a method apply_to(), that allows it to be attached to another HTML element in the DOM
//	e.g.
//		var target = document.getElementById(dom_element);
//		target.appendChild(html_element);

//initial supported HTML input controls supported:
//	button, radio button & text input

//	TODO: breakout handling of different types of HTML controls into their own code and require() here
module.exports = html_factory;

var check = require('check-types');
var argument_check = require("lib/util/argument_check");
var primitives = require("lib/util/primitives");

function html_factory(options) {
	//get an instance if we just call it
	if(!(this instanceof html_factory)) return new html_factory(options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	//create the text factory instance for getting Text for our Shapes
	var text_factory = require('lib/factory/text_factory');
	this._text_factory = text_factory();
	//default text should be empty string
	this._text_factory.text({text:''});
	
	//options for the raw HTML element
	this._html_options = {};
	
	//options for the container
	this._container_options = {x:0, y:0};
	
	//default HTML types
	this._default_types = ['radio', 'text', 'button'];
	
	this._name = '';
};

html_factory.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//public
	//configures the value of the text, defaults to an empty string
	//optionally takes text positioning and configuration options (font, color, x, y, etc)
	//	and text (a String()-able object or a createjs Text object) to set the value of the text to
	//pass in empty string for empty text
	text : function(options) {
		this._text_factory.text(options)
	},
	
	//TODO: if 'type' option already set, then don't complain about 'type' not being an argument
	//public
	//configures the raw HTML input element as returned from document.createElement
	//	validated options: type, id (is String'd if present)
	//	type is required, id is optional
	//	if id is undefined, then a unique id is generated and exposed as a decorated property at get() time
	html : function(options) {
		if(!check.object(options)) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated options: type, id
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//if type isn't passed...
		if (!("type" in validated_options)) {
			throw new TypeError("argument 'type' is required, should be non-empty String");
		}
		
		//type was passed, but unsupported type
		if (this._default_types.indexOf(validated_options.type) === -1) {
			throw new TypeError("argument 'type' was unsupported: " + String(validated_options.type));
		}
		
		//generate an id if we need one
		if(!("id" in validated_options)) {
			var unique_id = require('lib/util/unique_id');
			var id_str = unique_id(validated_options.type);
			validated_options.id = id_str;
		} else {
			//...else if the user passed us one, just String it
			validated_options.id = String(validated_options.id);
		}
		
		//if the type was 'button', then we can take an optional 'label' argument, but not allowed on any other HTML type
		if (validated_options.type !== 'button' && !(check.undefined(validated_options.label))) {
			throw new TypeError("argument 'label' is only used with 'button' HTML type");
		}
			
		//set HTML options for producing HTML in _get_html() later		
		for (option in validated_options) {
			this._html_options[option] = validated_options[option];
		}
	},
	
	//public
	//decorate an optional name value on the HTML for identification purposes
	name : function(value) {
		if(!check.undefined(value)) this._name = String(value);
	},
	
	//private
	//returns a configured createjs Text() object as configured in text()
	_get_text : function() {
		return this._text_factory.get();
	},
	
	//private
	//returns a configured HTML option as configured in html()
	_get_html : function() {
		var html = document.createElement('input');
		html.type = this._html_options.type;
		html.id = this._html_options.id;
		//positions html at (0, 0) on canvas
		html.style.top = 0;
		html.style.left = 0;
		
		//copy any other user options to the html object
		for (option in this._html_options) {
			if (option === 'label') {
				//string anything the user passed in for the label
				//NOTE: as incorrectly documented on MDN, to apply a label to a button use the 'value' property instead of 'label'
				//https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
				html.value = String(this._html_options['label']);
				continue;
			}
			html[option] = this._html_options[option];
		}
		
		return html;
	},
	
	//private
	//wraps the raw HTML object in a createjs.DOMElement
	//	where the raw HTML can be found as the htmlElement property on the DOMElement object
	_get_dom_element : function (html) {
		return new this._createjs.DOMElement(html);
	},
	
	//private
	//bundle the DOMElement and text together in a createjs.container
	//adding properties for convenience methods on the container from the html and text
	_bundle : function(DOMElement, text) {
		var container = new this._createjs.Container();
		
		//adding text last, such that it appears above the HTML
		container.addChild(DOMElement);
		container.addChild(text);
		
		//adding convenience methods for accessing internal objects for later
		//	within the _ namespace
		container._ = {};
		container._.htmlElement = DOMElement.htmlElement;
		container._.text = text.text;	//get the value of the text, not the Text object
		
		return container;
	},
	
	//private
	//add additional convenience methods to the container for ease of accessing and using the HTML object
	_decorate : function(container) {
		var append_to = require('lib/util/append_to');
		container._.append_to = append_to(container);
		
		//TODO, setup place commands on container for easy positioning
		//	the DOMElement can't calculate its own bounds, so we have no reliable way to getting the bounds of the HTML object
		//	the Element interface DOES have some ways of calculating the dimensions of the elements, but they're marked as experimental at this time:
		//	https://developer.mozilla.org/en-US/docs/Web/API/Element
		/* var place = require('lib/util/place');
		container._.place = place(container); */
		
		//add add_to_stage functionality
		var add_to_stage = require('lib/util/add_to_stage');
		container._.add_to_stage = add_to_stage(container);
		
		//add optional name
		//if name is unset, attempt to attach 'label' property as name on container
		//otherwise 'name' is ''
		if (this._name.length === 0) {
			if (!(check.undefined(this._html_options.label))) container._.name = String(this._html_options.label);
		} else {
			container._.name = this._name;
		}
		
		return container;
	},
	
	_set_props : function(container, options) {
		//save the user options
		for (option in options) {
			this._container_options[option] = options[option];
		}
		
		//...and apply any new options to the container
		for (option in this._container_options) {
			container[option] = this._container_options[option];
		}
		
		return container;
	},
	
	get : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		if (!("type" in this._html_options)) {
			throw new TypeError("Unknown type of HTML to create, run html() first before calling get()");
		}
		
		//validated options: x, y
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		var html = this._get_html();							//get the raw HTML
		var text = this._get_text();							//get the optional Text
		var de = this._get_dom_element(html);					//wrap the raw HTML in a createjs.DOMElement
		var container = this._bundle(de, text);					//bundle the DOMElement and text together in a createjs.container
		container = this._decorate(container)					//add additional convenience methods specific to the HTML to the container
		return this._set_props(container, validated_options);	//set last minute user defined properties on the container
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_text_factory : undefined,	//holds the text_factory instance
	_html_options : {},			//options for the raw HTML element
	_container_options : {},	//options for the container
	_default_types : [],		//default HTML types
	_shape_type : undefined,	//HTML input type setup in html()
	_name : '',					//optional name to attach to the HTML
	_createjs : undefined,		//local reference to the createjs object
};