module.exports = shape_factory;

var check = require('check-types');
var argument_check = require("lib/util/argument_check");
var primitives = require("lib/util/primitives");

function shape_factory(options) {
	//get an instance if we just call it
	if(!(this instanceof shape_factory)) return new shape_factory(options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	//configure defaults for color of Shape
	this._color_options = {fill:undefined, stroke:null}
	
	//create the text factory instance for getting Text for our Shapes
	var text_factory = require('lib/factory/text_factory');
	this._text_factory = text_factory();
	
	//default sizing and positioning options for the Shape
	//	default h and w for rect shapes come from LaFore defaults
	//TODO: radius = 1, is a placeholder until we can measure the radius of circles used in LaFore
	this._shape_options = {radius: 1, height:18, width:36, x:0, y:0},
	
	//default options for the container (that will hold both the Shape and Text)
	//users can set persistent options for the container by passing options to get()
	this._container_options = {x:0, y:0};
	
	//configure default shapes the factory knows about
	//'rectangle' and 'box' are aliases for 'rect'
	this._default_shapes = ["circle", "rect", "rectangle", "box"];
	
	//configured in shape() then used in _get_shape() to return the Shape object
	this._shape_type = undefined;
};

shape_factory.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//public
	//configures the fill and stroke of the shape returned
	//default behavior for the fill is getting a random color that has good contrast with the text color
	//default for stroke is null
	//takes optional values for fill and stroke
	color : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated options: color (alias for fill), fill, stroke
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		if ('fill' in validated_options) {
			this._color_options['fill'] = validated_options['fill'];
		}
		
		if ('color' in validated_options) {
			this._color_options['fill'] = validated_options['color'];
		}
		
		if ('stroke' in validated_options) {
			this._color_options['stroke'] = validated_options['stroke'];
		}
	},
	
	//public
	//configures the value of the text, defaults to a random integer between 0 and 1000
	//optionally takes text positioning and configuration options (font, color, x, y, etc)
	//	and text (a String()-able object or a createjs Text object) to set the value of the text to
	//pass in empty string for empty text
	text : function(options) {
		this._text_factory.text(options)
	},
	
	//public
	//configures the type of shape to return, 'type' must be a known string (circle, rect, etc)
	//includes defaults for size
	shape : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated options:
		//	height, width (for rect shapes)
		//	radius (for circle shapes)
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//if type isn't passed...
		if (!("type" in validated_options)) {
			throw new TypeError("argument 'type' is required, should be non-empty String");
		}
		
		if(this._default_shapes.indexOf(validated_options.type) === -1) {
			throw new TypeError("argument 'type' was unknown shape type: " + String(validated_options.type));
		}
		
		if (validated_options.type === "circle") {
			//if there are configuration options, then use them, otherwise the defaults
			if(validated_options.radius) this._shape_options.radius = validated_options.radius;
			
			this._shape_type = "circle"
			return;
		}
		
		if (validated_options.type === "rectangle" || validated_options.type === "rect" || validated_options.type === "box") {
			//if there are confgiuration options, then use them, otherwise the defaults
			if(validated_options.width) this._shape_options.width = validated_options.width;
			if(validated_options.height) this._shape_options.height = validated_options.height;
			
			this._shape_type = "rect"
			return;
		}
	},
	
	//private
	//configured by color(), returns user defined CSS hex color string(s) if supplied
	//	otherwise a random fill color that has good contrast with the text color and null for the stroke
	_get_color : function() {
		var fill, stroke;
		
		//if the fill is undefined (the default) then get a random color with good constrast with the text color
		if (check.undefined(this._color_options.fill)) {
			fill = (require('lib/util/random_color'))(this._text_factory.color());
		} else {
			fill = this._color_options.fill;
		}
		stroke = this._color_options.stroke;
		
		return {fill:fill, stroke:stroke};
	},
	
	//private
	//returns a configured createjs Text() object as configured in text()
	_get_text : function() {
		return this._text_factory.get();
	},
	
	//private
	//returns a configured createjs Shape object, as configured by shape()
	_get_shape : function(shape_color) {
		if (check.undefined(this._shape_type)) {
			throw new TypeError("Unknown type of Shape to create, run shape() first before calling get()");
		}
		
		var shape = new this._createjs.Shape();
		
		//assign color (stroke and fill) BEFORE applying shape for some reason (createjs idiom)
		shape.graphics.beginFill(shape_color.fill);
		shape.graphics.beginStroke(shape_color.stroke);
		
		//assign (x, y) coordinates to the Shape in _get_shape() rather than on the Graphic (createjs idiom)
		shape.x = this._shape_options.x;
		shape.y = this._shape_options.y;
		
		//circle specific Shape handling
		if (this._shape_type === 'circle') {
			shape.graphics.drawCircle(0, 0, this._shape_options.radius);
			
			//set bounds on the Shape for later
			//Note: we set the (x, y) coordinates to the top left hand corner of the "bounding box"
			//	as such the (x, y) coordinates are always negative, as we are always above and to the left of center
			//	where the (x, y) coordinates of how the Shape is placed is figured by createjs
			shape.setBounds(-this._shape_options.radius, 
				-this._shape_options.radius, 
				2*this._shape_options.radius,
				2*this._shape_options.radius
				);
		}
		
		//rectangle specific Shape handling
		if (this._shape_type === 'rect') {
			shape.graphics.drawRect(0, 0, this._shape_options.width, this._shape_options.height);
			
			//set bounds on the Shape for later
			shape.setBounds(0, 0,
				this._shape_options.width,
				this._shape_options.height
				);
		}
		
		//assign any other user options to the Shape
		for (shape_option in this._shape_options) {
			//...except for those we've already covered
			if (shape_option in {radius:null, height:null, width:null, x:null, y:null}) continue;
			shape[shape_option] = this._shape_options[shape_option];
		}
		
		//return the Shape
		return shape;
	},
	
	//private
	//returns a createjs container with the configured shape and text objects inside
	//	such that the text is viewable, overlaying the Shape
	_bundle : function(shape, text) {
		var container = new this._createjs.Container();
		container.addChild(shape);
		container.addChild(text);
		return container;
	},
	
	//private
	//set convenience accessor properties on the container, as well as any positioning / transform options passed to get()
	_set_props : function(container, options) {
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//set user options in _container_options to save state
		for (option in validated_options) {
			this._container_options[option] = validated_options[option];
		}
		
		//... and then apply to container
		for (option in this._container_options) {
			container[option] = this._container_options[option];
		}
		
		return container;
	},
	
	//TODO: modify to have color items decorated on to shape object
	//	then just append them to the container in _decorate here
	_decorate : function(container, color) {
		var shape = container.children[0];
		var text = container.children[1];
		
		container._ = {};
		
		//set the container's event listener methods, to point to the Shape's event listener methods
		container._.on = shape.on;
		container._.off = shape.off;
		container._.addEventListener = shape.addEventListener;
		container._.hasEventListener = shape.hasEventListener;
		container._.removeAllEventListeners = shape.removeAllEventListeners;
		container._.removeEventListener = shape.removeEventListener;
		
		//manually set container bounds to Shape bounds
		//as the container bounds can inherit from the Text bounds which are apparently set automatically while the Shape is not?
		container.setBounds(shape.getBounds().x, shape.getBounds().y, shape.getBounds().width, shape.getBounds().height);
		
		//setup place commands on container for easy positioning
		var place = require('lib/util/place');
		container._.place = place(container);
		
		//add add_to_stage functionality
		var add_to_stage = require('lib/util/add_to_stage');
		container._.add_to_stage = add_to_stage(container);
		
		//setup properties for the Shape stroke and fill
		container._.shape_fill = color.fill;
		container._.shape_stroke = color.stroke;
		
		return container;
	},
	
	//public
	//allocate a new shape of the configured type
	get : function (options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//template pattern, build the shape object
		//where options can be positioning and transform options as applied to the container
		var shape_color = this._get_color();				//get the color string used in shape construction
		var shape_text = this._get_text();					//the text value to display with the shape
		var shape = this._get_shape(shape_color);			//get the shape itself
		var container = this._bundle(shape, shape_text);	//bundle the shape and text into a createjs container
		container = this._decorate(container, shape_color);	//add additional convenience methods specific to the Shape to the container
		return this._set_props(container, options);			//add properties user propertier to container
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	//private
	//the color used on the shape, if undefined then just use random
	_color_options : {},
	//private
	//text factory, used in setting up Text objects for Shape's
	_text_factory : undefined,
	//private
	//shape options and type as set in shape()
	_shape_options : {},
	//private
	//defines what method is used to construct the Shape, once configured in shape()
	_shape_type : undefined,
	//private
	//options for the container pased back to the caller
	_container_options : {},
	
	_createjs : undefined,		//local reference to the createjs object
};