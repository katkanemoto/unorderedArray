//used to construct UI arrow (three strokes, forming a <- pattern)
//defaults from LaFore: 20px long, 12px wide, red, poiting to the left
//	the vertical distance along the arrow body that the arrowhead extends, is also 6px

var check = require('check-types');
var argument_check = require("lib/util/argument_check");
var type_of = require('lib/util/type_of');
var primitives = require("lib/util/primitives");

module.exports = arrow_factory;

function arrow_factory(options) {
	if (!(this instanceof arrow_factory)) return new arrow_factory(options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
		
	//angle is counted as rotating to the RIGHT for positive values (counterintuitively)
	//so a left facing arrow has an angle value of -180 degrees
	//the below code will build an arrow that faces to the left by default, so initial angle is zero
	this._arrow_options = {length: 20, width: 12, color: 'red', angle: 0};
	
	this._container_options = {x:0, y:0};
	
	this._default_directions = {'left':0, 'right':-180, 'up':-270, 'down':-90};
}

arrow_factory.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//sets up a new arrow, with optional argument: length, width, color, angle and direction
	//	where direction is a convenience alias for angle and accepts: 'left', 'right', 'up' and 'down'
	//	angle is internally translated from standard standard left hand rotation (e.g. 90 degrees points up as normal, instead of down as per the canvas)
	arrow : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object or undefined.");
		}
		
		//validated options: type, id
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//check arguments unique to arrow construction
		//validated options: angle, length, direction
		if(!(check.number(validated_options.angle) || check.undefined(validated_options.angle))) {
			throw new TypeError("Variable: " + "angle" + " was " + type_of(validated_options.angle) + ", should be: " + "number");
		}
		if(!(check.number(validated_options.length) || check.undefined(validated_options.length))) {
			throw new TypeError("Variable: " + "length" + " was " + type_of(validated_options.length) + ", should be: " + "number");
		} else {
			if (check.number(validated_options.length) && validated_options.length <= 0) {
				throw new TypeError("Variable: " + "length" + " was " + validated_options.length + ", should be greater than zero.");
			}
		}
		if(!(check.string(validated_options.direction) || check.undefined(validated_options.direction))) {
			throw new TypeError("Variable: " + "direction" + " was " + type_of(validated_options.direction) + ", should be: " + "string");
		} else {
			if (check.string(validated_options.direction) && !(validated_options.direction in this._default_directions)) {
				throw new TypeError("Variable: " + "direction" + " was " + validated_options.direction + ", should be: " 
				+ "one of these: " + "'left', 'right', 'up' or 'down'");
			}
		}
		
		//it's an error to have both angle and direction passed
		if (check.number(validated_options.angle) && check.string(validated_options.direction)) {
			throw new Error('Cannot have options "angle" and "direction" defined at the same time.');
		}
		
		//translate normal angle notation to special angle notation used by canvas
		if (check.number(validated_options.angle)) {
			validated_options.angle = -validated_options.angle;
		}
		
		//if direction is set, then translate that into an angle and unset direction before setting options on _arrow_options
		if(check.string(validated_options.direction)) {
			validated_options.angle = this._default_directions[validated_options.direction];
			delete validated_options.direction;
		}
		
		//copy settings for arrow creation on get()
		for (option in validated_options) {
			this._arrow_options[option] = validated_options[option];
		}
	},
	
	//return a createjs Shape of the tip of the arrow
	_get_tip : function() {
		var tip = new this._createjs.Shape();
		
		//start drawing at the top, then move to the very end of the tip, then to the bottom
		//creating an open ended triangle whose base is twice as long as it is tall
		tip.graphics.beginStroke(this._arrow_options.color)
			.moveTo((this._arrow_options.width/2), -(this._arrow_options.width/2))
			.lineTo(0, 0)
			.lineTo((this._arrow_options.width/2), (this._arrow_options.width/2));
			
		return tip;
	},
	
	//return a createjs Shape of the line composing the rest of the arrow
	_get_line : function() {
		var line = new this._createjs.Shape();
		
		//start at the tip of the arrow (0, 0) and create a line that is as long as the length property
		line.graphics.setStrokeStyle(1)
			.beginStroke(this._arrow_options.color).moveTo(0, 0).lineTo(this._arrow_options.length, 0);
			
		return line;
	},
	
	//return a createjs Container, containing the tip and line, forming the arrow
	_bundle : function(tip, line) {
		var container = new this._createjs.Container();
		container.addChild(tip);
		container.addChild(line);
		return container;
	},
	
	_decorate : function(container) {
		container._ = {};
		
		//apply bounds of the arrow
		container.setBounds(0, 0, this._arrow_options.length, this._arrow_options.width);
		
		//add placing functionality to container
		var place = require('lib/util/place');
		container._.place = place(container);
		
		//add add_to_stage functionality
		var add_to_stage = require('lib/util/add_to_stage');
		container._.add_to_stage = add_to_stage(container);
		
		return container;
	},
	
	//set user options (positioning) as passed to get(), then apply angle of rotation to the container
	_set_props : function(container, options) {
		//copy settings for arrow creation on get()
		for (option in options) {
			this._container_options[option] = options[option];
		}
		
		//copy container options to container for return
		for (option in this._container_options) {
			container[option] = this._container_options[option];
		}
		
		//apply the angle of rotation to the arrow
		container.rotation = this._arrow_options.angle;
		
		return container;
	},
	
	//takes positioning (and other) options on the container
	get : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated options: x, y
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		var tip = this._get_tip();
		var line = this._get_line();
		var container = this._bundle(tip, line);
		container = this._decorate(container);
		return this._set_props(container, validated_options);
	},
	
	//TODO
	//takes two points, resturns an arrow whose origin is origin and whose terminal point (which point it points at) is terminal
	//	points are of the form: [x, y] (where x and y are numbers)
	/* get_arrow_between : function(origin, terminal) {
		if (!(
			check.array(origin) && 
			check.array(terminal) && 
			check.number(origin[0]) && 
			check.number(origin[1]) && 
			check.number(terminal[0]) && 
			check.number(terminal[1])
			)
			) {
			throw new TypeError("Incorrect argument type, should be array: [x, y] (where x and y are numbers)");
		}
		
		//calculate distance between the points
		var distance = require('euclidean-distance');
		var l = distance(origin, terminal);
		
		//then update the arrow, so that it is that length
		this.arrow({length:l});
		
		//calculate the angle needed to have the tip of the arrow rest on the terminal, given that the initial point is at origin
		
		//get an arrow, such that it's initial point is set at origin
		var a = this.get({x:origin[0], y:origin[1]});
		
		
	}, */
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_arrow_options : {},			//holds options for arrows
	_default_directions : {},		//default direction strings that an arrow accepts mapping to angle values
	_container_options : {},		//options applied to the container, used for positiong of the figure, etc
};