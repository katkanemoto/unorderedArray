module.exports = lesson_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function lesson_UI(options) {
	if (!(this instanceof lesson_UI)) return new lesson_UI(options);
	
	//if we don't have a stage, createjs or lib object, can't continue, error
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._stage = primitives.get('stage');
	if (check.undefined(this._stage) || check.not.object(this._stage)) {
		throw new ReferenceError("'stage' undefined or not object in primitives object.");
	}
	
	this._lib = primitives.get('lib');
	if (check.undefined(this._lib) || check.not.object(this._lib)) {
		throw new ReferenceError("'lib' undefined or not object in primitives object.");
	}
	
	//TODO: singleton
	
	this._state = this._INIT;
	
	//setup UI elements
	this._setup_title_screen();
	this._setup_start_button();
	this._setup_array_screen();
	this._setup_array();
	
	this._state = this._PRE_LESSON;
	
	//play the initial title screen animation
	this._title_screen.gotoAndPlay("open");
};

lesson_UI.prototype = {
	_setup_title_screen : function() {
		this._title_screen = new this._lib.TitleScreen();
		this._title_screen.x = 192;
		this._title_screen.y = 256;
		
		this._stage.addChild(this._title_screen);	//add the title screen to the stage
	},
	
	_setup_start_button : function() {
		//insert_btn is automatically populated inside the title screen object by AA
		this._start_button = this._title_screen.insert_btn;
		
		//on button press for the insert button
		//next() to transition to the next state and play the close animation on the title screen
		var instance = this;
		this._start_button.addEventListener("click", function() {
			instance.next();
		});
	},
	
	_setup_array_screen : function() {
		this._array_screen = new this._lib.ArrayScreen();	//setup by AA
		this._array_screen.x = 0;
		this._array_screen.y = 0;
	},
	
	_setup_array : function() {
		var size = 5;
		this._array = this._make_array(size);
		
		//TODO: allow config of positioning
		//positioning array
		this._array.x = 100;
		this._array.y = 200;
		
		//TODO, move this into make_array, where the coordinates depend on their parent's coordinates as well as their own
		for (var i = 0; i < this._array.children.length; i++) {
			var arrayElement = this._array.children[i];
			
			//create a new namespace to decorate into
			arrayElement._ = {};
			
			//create a namespace in the decoration for each type of move we need
			arrayElement._.below = {x: this._array.x + arrayElement.x + 22, y:this._array.y + 70};
			arrayElement._.on = {x: this._array.x + arrayElement.x + 9, y:this._array.y + 15};
		}
	},
	
	_make_array : function(size) {
		var offsetX = 0;
		var container = new this._createjs.Container();
		
		for (var i = 0; i < size; i++) {
			//create the array element in a container, so 
			var arrayElement = new this._lib.ArrayElement();
			
			//offset each subcontainer by the size of the array element box
			arrayElement.x = offsetX;
			
			//BUG:
			//for some reason the width as returned by getBounds() is about half of the ArrayElement length as shown on the canvas
			//	using 50px as workaround
			//offsetX += arrayElement.getBounds().width;
			offsetX += 50;
			
			//setting associated index (displays below ArrayElement figure, configured by AA)
			arrayElement.index_txt.text = String(i);
			
			container.addChild(arrayElement);
		}
		
		//set bounds on the array, for using place() later
		//NOTE: having to guess at the height of the container, as arrayElement's don't have correct bounds
		container.setBounds(0, 0, offsetX, 50 + 20);
		
		return container;
	},
	
	//add a text input to the array_screen to capture user input
	_setup_text_input : function() {
		//get the text input
		var html_factory = require('lib/factory/html_factory');
		var hf = html_factory();
		hf.html({type:'text'});
		this._text_input = hf.get();
		
		//get the canvas_container div to attach to
		var canvas_container = document.getElementById('canvas_container');
		
		//position the text input
		this._text_input.x = 100;
		this._text_input.y = 100;
		
		var instance = this;
		//decorate method to get value of text input
		this._text_input._.get_text_input_value = function() {
			//no matter what is entered the "value" property is always a string
			//emtpy string case / no input, Number returns 0 for this?
			if (instance._text_input.children[0].htmlElement.value.length === 0) {
				return Number.NaN;
			}
			
			//despite the docs, this is a static method, so allocating it as per the docs (new Number), results in NaN on non-number input being wrapped in an object in a non-standard way that is undetectable by:
			//Number.Nan, equality checking with NaN, Number.isNaN() and typeof
			return Number(instance._text_input.children[0].htmlElement.value);
		};
		
		//...and a method to set the value
		this._text_input._.set = function(value) {
			instance._text_input.children[0].htmlElement.value = String(value);
		};
		
		//...and a convenience method to clear the text input
		this._text_input._.clear = function() {
			instance._text_input.children[0].htmlElement.value = "";
		};
		
		//make text_input a child of the canvas_container
		this._text_input._.append_to(canvas_container);
		
		//add it as a child of the array_screen
		this._array_screen.addChild(this._text_input);
	},
	
	//add a button "insert" to the array screen to control the lesson
	_setup_insert_button : function() {
		var shape_factory = require('lib/factory/shape_factory');
		var sf = shape_factory();
		sf.color({color:'red'});
		sf.text({text:"Insert"});
		sf.shape({type:"box"});
		
		this._insert_button = sf.get();
		
		//position next to the text input
		this._insert_button.x = 300;
		this._insert_button.y = 100;
		
		//adding pub/sub to event listener, so we can subscribe to click events later
		var pub_sub = require('pubsub-js');
		
		//add an event handler to the shape to listen for clicks
		this._insert_button.children[0].addEventListener("click", function() {
			pub_sub.publish("click.insert_button");
		});
		
		//decorate pub_sub on the object
		this._insert_button._.pub_sub = pub_sub;
		
		//add it as a child of the array_screen to appear when the array screen is added to the stage
		this._array_screen.addChild(this._insert_button);
	},
	
	//add a button "next" to the array screen to control stepping through the lesson
	_setup_next_button : function() {
		var shape_factory = require('lib/factory/shape_factory');
		var sf = shape_factory();
		sf.color({color:'green'});
		sf.text({text:"Next"});
		sf.shape({type:"box"});
		
		this._next_button = sf.get();
		
		//position at the bottom of the screen
		this._next_button.x = 200;
		this._next_button.y = 400;
		
		//adding pub/sub to event listener, so we can subscribe to click events later
		var pub_sub = require('pubsub-js');
		
		//add an event handler to the shape to listen for clicks
		this._next_button.children[0].addEventListener("click", function() {
			pub_sub.publish("click.next_button");
		});
		
		//decorate pub_sub on the object
		this._next_button._.pub_sub = pub_sub;
		
		//add it as a child of the array_screen to appear when the array screen is added to the stage
		this._array_screen.addChild(this._next_button);
	},
	
	//add an arrow pointing at the 0th position of the array, labeled "tail"
	_setup_tail_arrow : function() {
		this._tail_arrow = this._make_arrow("tail");
		
		//place the arrow initially under the 0th child, as there are not values in the array yet
		this._tail_arrow.x = this._array.children[0]._.below.x;
		this._tail_arrow.y = this._array.children[0]._.below.y;
		
		this._array_screen.addChild(this._tail_arrow);
	},
	
	//create upward facing arrows with an optional label
	_make_arrow : function(name) {
		var arrow_factory = require('lib/factory/arrow_factory');
		var af = arrow_factory();
		af.arrow({direction: "up"});
		
		var arrow = af.get();
		
		var c = new this._createjs.Container();
		c.addChild(arrow);
		
		//if there is a label, then append it to the container for return, positioning the text to be below the arrow
		if (check.nonEmptyString(name)) {
			var text_factory = require('lib/factory/text_factory');
			var tf = text_factory();
			tf.text({text:name});
			var label = tf.get();
			
			//lifted from 'lib/util/place', below()
			label.x = arrow.x - label.getBounds().x;
			label.y = arrow.y + arrow.getBounds().height - label.getBounds().y;
			
			//slight correction: down and to the left, to be centered under the arrow
			label.y += 5;
			label.x += -10;
			
			c.addChild(label);
		}
		
		//decorate with add_to_stage() and place()
		c._ = {};
		
		//add placing functionality to container
		var place = require('lib/util/place');
		c._.place = place(c);
		
		//add add_to_stage functionality
		var add_to_stage = require('lib/util/add_to_stage');
		c._.add_to_stage = add_to_stage(c);
		
		return c;
	},
	
	//setup the text output and expose a control object with conenience methods
	_setup_text_output : function() {
		var text_factory = require('lib/factory/text_factory');
		var tf = text_factory();
		tf.text({text:""});	//set blank initially
		var output = tf.get();
		
		//decorate with convenience methods
		function get() {
			return output.text;
		}
		
		function set(value) {
			output.text = String(value);
		}
		
		function clear() {
			output.text = "";
		}
		
		this._text_output = output;
		this._text_output._.set = set;
		this._text_output._.get = get;
		this._text_output._.clear = clear;
		
		//position the text at the bottom of the screen, just below the next button
		//lifted from 'lib/util/place', below()
		this._text_output.x = 100;	//aligned with the array and the text input
		this._text_output.y = this._next_button.y + this._next_button.getBounds().height;
		
		this._array_screen.addChild(this._text_output);
	},
	
	//public
	//proceed through the states of the lesson
	next : function() {
		if (this._state === this._INIT) return;	//do nothing if in the INIT state
		
		//handling for title screen, before the lesson UI is displayed
		//	called from click of the "insert" button on the title screen
		if (this._state === this._PRE_LESSON) {
			//set the state into lesson to allow the transition to the lesson logic
			this._state = this._LESSON;
			
			//TODO: add code here to delete title screen object from the stage and the reference here, to free memory
			this._title_screen.gotoAndPlay("close");
			
			this.next();
			
			return;
		}
		
		//handling for lesson screen, after pre-lesson has ended
		//	called by the PRE_LESSON handler on title screen close
		if (this._state === this._LESSON) {
			this._array_screen.gotoAndPlay("open");	//do the opening animation for the array screen
			
			//add the generated array to the screen
			this._array_screen.addChild(this._array);
			this._stage.addChild(this._array_screen);
			
			//add the text input HTML to the array screen
			//	cannot add earlier as appears over canvas even though not added to stage
			this._setup_text_input();
			
			//add an insert button next to the text input to control the start of the lesson
			this._setup_insert_button();
			
			//add a next button at the bottom of the lesson
			this._setup_next_button();
			
			//setup a new arrow to point at the first position of the new array
			this._setup_tail_arrow();
			
			//setup a createjs.Text object at the bottom of the screen to give the user instruction
			this._setup_text_output();
			
			//TEST
			/* var text_factory = require('lib/factory/text_factory');
			var tf = text_factory();
			
			for (var i = 0; i < this._array.children.length; i++) {
				var arrayElement = this._array.children[i];
				
				tf.text({text:1000});
				var text = tf.get();
				text.x = arrayElement._.on.x;
				text.y = arrayElement._.on.y;
				
				console.log(text);
				
				text._.add_to_stage();
			} */

			//this._array.addChild(text);
			
			return;
		}
	},
	
	//internal variables
	_stage : undefined,			//holds a reference to the createjs stage (of type lib.unorderedArray, created in AA)
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_lib : undefined,			//holds a reference to the lib object, created by AA and used to access objects created by AA
	_title_screen : undefined,	//reference to an object of type TitleScreen (created in AA)
	_start_button : undefined,	//reference to the insert button object (AA)
	_array_screen : undefined,	//reference to the array screen object (AA)
	_array : undefined,			//reference to the array created for the array screen
	_text_input : undefined,	//reference to the text input created, that's attached to the array screen
	_insert_button : undefined,	//reference to the insert button, used in the lesson, to start the lesson
	_next_button : undefined,	//reference to the next button, used in lesson, to continue the lesson once started
	_tail_arrow : undefined,	//reference to the arrow pointing at the "tail" position of the current working array
	
	//state tracking variables
	_state : undefined,
	_INIT : 0,
	_PRE_LESSON : 1,
	_LESSON : 2,
};