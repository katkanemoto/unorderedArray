module.exports = lesson_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function lesson_UI(options) {
	if (!(this instanceof lesson_UI)) return new lesson_UI(options);
	
	//if we don't have a stage, createjs or lib object, can't continue, error
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._stage = primitives.get('stage');
	if (check.undefined(this._stage) || check.not.object(this._stage)) {
		throw new ReferenceError("'stage' undefined or not object in primitives object.");
	}
	
	this._lib = primitives.get('lib');
	if (check.undefined(this._lib) || check.not.object(this._lib)) {
		throw new ReferenceError("'lib' undefined or not object in primitives object.");
	}
	
	this._state = this._INIT;
	
	//setup intial UI elements
	this._title_screen = this._setup_title_screen();
	this._start_button = this._setup_start_button();
	
	//add the title screen to the stage
	//	(start button is already added as a child of the title screen object) 
	this._stage.addChild(this._title_screen);
	
	//add any additional displayObjects to the stage that were register()ed
	if (lesson_UI.prototype._registered_objects && lesson_UI.prototype._registered_objects.get('init').length) {
		var items = lesson_UI.prototype._registered_objects.get('init');
		for (var i = 0; i < items.length; i++) {
			this._stage.addChild(items[i]);
		}
	}
	
	this._state = this._PRE_LESSON;
	
	//add any additional displayObjects to the title screen that were register()ed
	if (lesson_UI.prototype._registered_objects && lesson_UI.prototype._registered_objects.get('pre_lesson').length) {
		var items = lesson_UI.prototype._registered_objects.get('pre_lesson');
		for (var i = 0; i < items.length; i++) {
			this._title_screen.addChild(items[i]);
		}
	}
	
	//play the initial title screen animation
	this._title_screen.gotoAndPlay("open");
};

lesson_UI.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE-PRIVATE
	_setup_title_screen : function() {
		var title_screen = new this._lib.TitleScreen();
		title_screen.x = 192;
		title_screen.y = 256;
		
		//return the title screen to add to the stage
		return title_screen;
	},
	
	_setup_start_button : function() {
		//insert_btn is automatically populated inside the title screen object by AA
		var start_button = this._title_screen.insert_btn;
		
		//on button press for the insert button
		//next() to transition to the next state and play the close animation on the title screen
		var instance = this;
		start_button.addEventListener("click", function() {
			instance.next();
		});
		
		return start_button;
	},
	
	_setup_array_screen : function() {
		var array_screen = new this._lib.ArrayScreen();	//setup by AA
		array_screen.x = 0;
		array_screen.y = 0;
		
		return array_screen;
	},
	
	//add a text input to the array_screen to capture user input
	_setup_text_input : function() {
		//get the text input
		var html_factory = require('lib/factory/html_factory');
		var hf = html_factory();
		hf.html({type:'text'});
		var text_input = hf.get();
		
		//position the text input
		text_input.x = 100;
		text_input.y = 100;
		
		//var instance = this;
		//decorate method to get value of text input
		text_input._.get = function() {
			//no matter what is entered the "value" property is always a string
			//emtpy string case / no input, Number returns 0 for this?
			if (text_input.children[0].htmlElement.value.length === 0) {
				return Number.NaN;
			}
			
			//despite the docs, this is a static method, so allocating it as per the docs (new Number), results in NaN on non-number input being wrapped in an object in a non-standard way that is undetectable by:
			//Number.Nan, equality checking with NaN, Number.isNaN() and typeof
			return Number(text_input.children[0].htmlElement.value);
		};
		
		//...and a method to set the value
		text_input._.set = function(value) {
			text_input.children[0].htmlElement.value = String(value);
		};
		
		//...and a convenience method to clear the text input
		text_input._.clear = function() {
			text_input.children[0].htmlElement.value = "";
		};
		
		return text_input;
	},
	
	//add a point to control the stepping of the lesson
	_setup_next_button : function() {
		var shape_factory = require('lib/factory/shape_factory');
		var sf = shape_factory();
		sf.color({color:'red'});
		sf.text({text:"Next"});
		sf.shape({type:"box"});
		
		var next_button = sf.get();
		
		//position next to the text input
		next_button.x = 300;
		next_button.y = 100;
		
		//adding pub/sub to event listener, so we can subscribe to click events later
		var pub_sub = require('pubsub-js');
		
		//add an event handler to the shape to listen for clicks
		next_button.children[0].addEventListener("click", function() {
			pub_sub.publish("click.next_button");
		});
		
		//decorate pub_sub on the object
		next_button._.pub_sub = pub_sub;
		
		//return for adding to the array screen
		return next_button;
	},
	
	//setup the text output and expose a control object with conenience methods
	_setup_text_output : function() {
		var text_factory = require('lib/factory/text_factory');
		var tf = text_factory();
		tf.text({text:""});	//set blank initially
		var output = tf.get();
		
		//decorate with convenience methods
		function get() {
			return output.text;
		}
		
		function set(value) {
			output.text = String(value);
		}
		
		function clear() {
			output.text = "";
		}
		
		output._.set = set;
		output._.get = get;
		output._.clear = clear;
		
		output.x = 100;	//aligned with the text input
		output.y = 420;	//position the text at the bottom of the screen
		
		return output;
	},
	
	//method to create a createjs.Text object to tween on the canvas, that visually appears near the text input
	//	visualizes inputing information from the text input into the UI array
	_text_input_to_canvas : function() {
		if (this._state !== this._LESSON) return;
		
		input = this._text_input._.get();
		if (Number.isNaN(input)) return;
		
		var text_factory = require('lib/factory/text_factory');
		var tf = text_factory();
		tf.text({text:input});
		var ret = tf.get();
		
		//position near text input, to be ready for tweening
		//	the text input overlays any canvas element, so make the input appear just below the text input
		ret.x = this._text_input.x;
		ret.y = this._text_input.y + 20;
		
		//clear the text input
		this._text_input._.clear();
		
		//add the Text object to the stage
		ret._.add_to_stage();
		
		//return the text object so it can be tweened by the caller
		return ret;
	},
	
	//PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC-PUBLIC
	
	//proceed through the states of the lesson
	next : function() {
		if (this._state === this._INIT) return;	//do nothing if in the INIT state
		
		//handling for title screen, before the lesson UI is displayed
		//	called from click of the Start button on the title screen
		if (this._state === this._PRE_LESSON) {
			//set the state into lesson to allow the transition to the lesson logic
			this._state = this._LESSON;
			
			this._title_screen.gotoAndPlay("close");
			
			this.next();
			
			//de-allocate the title screen
			this._title_screen = undefined;
			
			return;
		}
		
		//handling for lesson screen, after pre-lesson has ended
		//	called by the PRE_LESSON handler on title screen close
		if (this._state === this._LESSON) {
			this._array_screen = this._setup_array_screen();
			
			//add the text input HTML to the array screen
			//	cannot add earlier as appears over canvas even though not added to stage
			this._text_input = this._setup_text_input();
			
			//get the canvas_container div to attach the text input to
			var canvas_container = document.getElementById('canvas_container');
			
			//make text_input a child of the canvas_container
			this._text_input._.append_to(canvas_container);
			
			//add it to the array screen
			this._array_screen.addChild(this._text_input);
			
			//add a next button next to the text input to control the lesson
			this._next_button = this._setup_next_button();
			
			//add it to the array screen
			this._array_screen.addChild(this._next_button);
			
			//setup a createjs.Text object at the bottom of the screen to give the user instruction
			this._text_output = this._setup_text_output();
			
			//add it to the array screen
			this._array_screen.addChild(this._text_output);
			
			//add the array screen to the stage to draw it and all of its children
			this._stage.addChild(this._array_screen);
			
			//add any additional displayObjects to the array screen that were register()ed
			if (lesson_UI.prototype._registered_objects && lesson_UI.prototype._registered_objects.get('lesson').length) {
				var items = lesson_UI.prototype._registered_objects.get('lesson');
				for (var i = 0; i < items.length; i++) {
					this._array_screen.addChild(items[i]);
				}
			}
			
			//after the above setup, do the opening animation for the array screen
			this._array_screen.gotoAndPlay("open");
			
			return;
		}
	},
	
	//return a proxy object that allows control of the UI by the lesson code
	get_proxy : function() {
		if (this._state !== this._LESSON) return undefined;
		
		var instance = this;
		return {
			input : {
				get : instance._text_input._.get,
				set : instance._text_input._.set,
				clear : instance._text_input._.clear,
				//have to call() here as if this is called from the proxy,
				//then the `this` variable (in _text_input_to_canvas()) becomes the `input` namespace within the proxy
				//causing bizarre errors
				get_canvas_element : function() {
					return instance._text_input_to_canvas.call(instance);
				},
			},
			output : {
				get : instance._text_output._.get,
				set : instance._text_output._.set,
				clear : instance._text_output._.clear,
			},
			next_button : instance._next_button,
			stage : {
				//as we only need to manipulate the UI in the lesson stage
				//just make changes to this._array_screen
				add : function(obj) {
					if(check.not.object(obj) || check.not.instanceStrict(obj, instance._createjs.DisplayObject)) {
						throw new TypeError("Bad argument to stage.add(), should be createjs.DisplayObject");
					}
					instance._array_screen.addChild(obj);
					instance._stage.update();
				},
				del : function(obj) {
					var result = instance._array_screen.removeChild(obj);
					instance._stage.update();
					return result;
				},
			},
		};
	},
	
	//internal variables
	_stage : undefined,			//holds a reference to the createjs stage (of type lib.unorderedArray, created in AA)
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_lib : undefined,			//holds a reference to the lib object, created by AA and used to access objects created by AA
	_title_screen : undefined,	//reference to an object of type TitleScreen (created in AA)
	_start_button : undefined,	//reference to the insert button object (AA)
	_array_screen : undefined,	//reference to the array screen object (AA)
	_text_input : undefined,	//reference to the text input created, that's attached to the array screen
	_next_button : undefined,	//reference to the next button, used in lesson, to continue the lesson once started
	
	//state tracking variables
	_state : undefined,
	_INIT : 0,
	_PRE_LESSON : 1,
	_LESSON : 2,
	
	_valid_state_strings : ['init', 'pre_lesson', 'lesson'],	//strings used to refrence states, by lesson_UI.register()
	//holds a Map of the the objects added to the canvas at various states of the lesson
	//	created and populated in lesson_UI.register()
	_registered_objects : undefined,
};

//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS

//STATIC-STATIC-STATIC-STATIC-STATIC-STATIC-STATIC-STATIC-STATIC-STATIC-STATIC-STATIC-STATIC-STATIC

//register a createjs display object to display during a state of the lesson
lesson_UI.register = function(options) {
	//requires createjs registered with primitives
	var _createjs = primitives.get('createjs');
	if (check.undefined(_createjs) || check.not.object(_createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	//required options
	if (check.undefined(options) || check.not.object(options)) {
		throw new TypeError("Requires options objects.");
	}
	
	//require option: object
	//	requires a createjs display object to register with the UI
	if (check.undefined(options.object) || check.not.instanceStrict(options.object, _createjs.DisplayObject)) {
		throw new TypeError("Required option: object, should be createjs DisplayObject.");
	}
	
	//require option: state
	//	requires a string that matches a valid state
	var state_valid = false;
	if (check.string(options.state)) {
		for (var i = 0; i < lesson_UI.prototype._valid_state_strings.length; i++) {
			var str = lesson_UI.prototype._valid_state_strings[i];
			if (str.match(options.state)) {
				state_valid = true;
			}
		}
	}
	if (!state_valid) {
		throw new TypeError("Required option: state, should be string and one of these: " + String(lesson_UI.prototype._valid_state_strings) + ".");
	}
	
	//setup the Map in lesson_UI.prototype._registered_objects, if needed
	if (check.undefined(lesson_UI.prototype._registered_objects)) {
		lesson_UI.prototype._registered_objects = new Map();
		
		//create a key in the Map for each valid state we can add objects in
		for (var i = 0; i < lesson_UI.prototype._valid_state_strings.length; i++) {
			var str = lesson_UI.prototype._valid_state_strings[i];
			
			//the key should map to an array that we push() new objects on to in the next step
			lesson_UI.prototype._registered_objects.set(str, []);
		}
	}
	
	//add the object to the array mapping to the state where it should be added to during the lesson_UI
	lesson_UI.prototype._registered_objects.get(options.state).push(options.object);
};