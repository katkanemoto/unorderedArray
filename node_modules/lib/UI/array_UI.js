module.exports = array_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function array_UI(options) {
	if (!(this instanceof array_UI)) return new array_UI(options);
	
	//requires primitives.lib and primitives.createjs
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._lib = primitives.get('lib');
	if (check.undefined(this._lib) || check.not.object(this._lib)) {
		throw new ReferenceError("'lib' undefined or not object in primitives object.");
	}
	
	//requires argument length, how big to make the array (should be integer > 0)
	if (check.undefined(options) || check.undefined(options.length) || check.not.integer(options.length) || options.length <= 0) {
		throw new TypeError("Require argument object with property 'length'. 'length' should be an integer > 0.");
	}
	
	//TODO: remove containers and just make container of ArrayElements
	//create an array of containers containing ArrayElements, we'll place the Text objects in the inner containers later when we assign a value to an index
	this._array = this._make_array(options.length);
	
	//decorate the inner containers with coordinates to place UI elements below / on the arrayElements in the array
	this._array = this._decorate_coordinates(this._array);
	
	//decorate outer container with an array that will map to the values contained in the array holding the UI elements
	//	when they're added with the methods added below
	this._array = this._decorate_value_array(this._array);
	
	//get the arrow associated with the array, points at the first elements in the array
	//	the arrow implements the iterator protocol and is assigned a next() function that will traverse the array,
	//	returning values in the array as well as move()ing the UI arrow to the next position in the array
	this._arrow = this._setup_tail_arrow(this._array);
	
	//decorate outer container with convenience methods that:
	//	handle adding values to the array
	//		this methods handles the UI aspects of adding value (move()) and the logical aspect (updating the internal logical / UI containers with the values added)
	this._array = this._decorate_method_push(this._array, this._arrow);
	
	return {array: this._array, arrow: this._arrow};
}

array_UI.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//creates an array of ArrayElement's, with maximum size length
	//each child in the array is a container containing an ArrayElement, when we're adding values, the values are added to they're associated container
	//each child is decorated with a _ namespace that is used later to add functionality
	//each child is decorated with a _.index property that matches its index in the array
	//the Container containing the the children is decorated with a _ namespace, to add functionality
	//the Container containing the the children is decorated with a _.length property to indicate its maximum size
	_make_array : function(length) {
		var offsetX = 0;
		var outer_container = new this._createjs.Container();
		
		for (var i = 0; i < length; i++) {
			//create the array element in a container, so 
			var arrayElement = new this._lib.ArrayElement();
			var inner_container = new this._createjs.Container();
			inner_container.addChild(arrayElement);
			
			//offset each subcontainer by the size of the array element box
			inner_container.x = offsetX;
			
			//create a new namespace to decorate into
			inner_container._ = {};
			
			//BUG:
			//for some reason the width as returned by getBounds() is about half of the ArrayElement length as shown on the canvas
			//	using 50px as workaround
			//offsetX += arrayElement.getBounds().width;
			offsetX += 50;
			
			//setting associated index (displays below ArrayElement figure, configured by AA)
			arrayElement.index_txt.text = String(i);
			inner_container._.index = i;	//setting index for iteration by the tail arrow
			
			outer_container.addChild(inner_container);
		}
		
		//set bounds on the array, for using place() later
		//NOTE: having to guess at the height of the container, as arrayElement's don't have correct bounds
		outer_container.setBounds(0, 0, offsetX, 50 + 20);
		
		//create a namespace to decorate into
		outer_container._ = {};
		
		//add a length property, to show the maximum size of the array
		outer_container._.length = length;
		
		return outer_container;
	},
	
	//TODO: modify these to be local to the array, since we just use globalToLocal() to keep track of the position of the children with respect to the container
	//decorates the child containers of each child in an array with functions that return global (x, y) coordinates for positions near each child ArrayElement object
	//coordinates are compatible with the move() library, that will allow tweening of stage object to points near the ArrayElement objects
	_decorate_coordinates : function(array) {
		for (var i = 0; i < array.children.length; i++) {
			var arrayElement = array.children[i];
			
			//create functions in the _ namespace for each type of move we need
			//call a function (with the current child index) that returns a function of that child and its parent coordinates
			//	this allows updating of the position of the coordinates as the parent container moves or is placed in a different location
			//	via the magic of closures
			arrayElement._.below = (function(j) {
				return function() {
					return {x:array.x + array.children[j].x + 22, y:array.y + 70};
				}
			})(i);
			
			arrayElement._.on = (function(j) {
				return function() {
					return {x:array.x + array.children[j].x + 9, y:array.y + 15};
				}
			})(i);
		}
		
		return array;
	},
	
	//decorates a values array onto the array Container, that is meant to contain the numeric values added to the array
	_decorate_value_array : function(array) {
		array._.values = [];
		return array;
	},
	
	//add an arrow pointing at the 0th position of the array, labeled "tail"
	//the tail acts as a UI element and iterator, such that it will logically traverse the values array (above)
	//as well as move() itself on the stage when its next() function is called
	//the arrow is added as a child of the array Container to allow for relative positioning, this is NOT traversed to on a call to next()
	//	as next() tracks indices according to the size of the array NOT using the size of the array.children array as its guide to how many children there are
	_setup_tail_arrow : function(array) {
		var arrow_UI = require('lib/UI/arrow_UI');
		
		//NOTE:
		//`this`, in a next function refers to the arrow object
		/* as such it has properties in this configuration:
		{
			move: move
			name: "tail",
			pointed_at: <some UI object>,
			next : <the next() function (assigned below)>
			}
		so addressing said properties is not done via the _ namespace, but rather directly on the `this` object itself */
		function tail_arrow_next() {
			if (this.pointed_at._.index + 1 >= array._.length) {
				//going to be out of bounds case
				return {done : true};
			} else {
				//increment to the next child, return its value and done === false
				//	move() arrow below next child
				var new_index = this.pointed_at._.index + 1;
				this.pointed_at = array.children[new_index];
				
				//translate the global position below() to local with respect to the array, then move() to it
				var next_point_below = array.globalToLocal(array.children[new_index]._.below().x, array.children[new_index]._.below().y);
				this.move.to(next_point_below);
				
				//value is always undefined, as we use the arrow to point to indices in the array which have no content (as it's the tail arrow)
				return {value : undefined, done : false};
			}
		};
		
		var args = {
			name: "tail",
			//place the arrow initially under the 0th child, as there are not values in the array yet
			position: array.children[0]._.below(),
			//arrow is pointing at the 0th child
			pointed_at: array.children[0],
			//define how to iterate the arrow
			next: tail_arrow_next,
		};
		
		//add the arrow to the array to do relative positioning inside the array container
		var arrow = arrow_UI(args);
		array.addChild(arrow);
		
		return arrow;
	},
	
	//add a method to push values onto the array
	//takes a createjs Text object, whose value is a number
	//tweens the Text object to the first available position in the UI array
	//	the index where the tail arrow is currently pointing, before move()d to the next position in the array
	//adds the value in the Text object to the "values" array (decorated in the _ namespace, above)
	//returns an error if the array is full
	_decorate_method_push : function(array, arrow) {
		array._.push = function(value) {
			//value should be a createjs.Text object, whose text value is a number
			if(check.not.instanceStrict(value, createjs.Text) || check.not.number(Number(value.text))) {
				throw new TypeError("Requires a createjs.Text object whose value is a number.");
			}
			
			//error if array is full
			if (array._.values.length === array._.length) {
				throw new RangeError("Array is full, cannot push() new value.");
			}
			
			//get the index where we can insert (from arrow)
			var insertion_index = arrow._.pointed_at._.index;
			
			//move() value to that index
			var move = require('lib/util/move');
			var value_move = move(value);
			
			//store the intial point (from the global stage)
			var global_initial_point = {x: value.x, y: value.y};
			
			//add the value to the array as a child of the container at the insertion_index
			array.children[insertion_index].addChild(value);
			
			//translate the initial point of the value, to the local coordinate space of the array
			var local_initial_point = array.globalToLocal(value.x, value.y);
			value.x = local_initial_point.x;
			value.y = local_initial_point.y;
			
			//then move from that point, to the point on the array (on() returns the global position)
			//	where globalToLocal() translates the global point from on() to the local coordinate system with respect to the array container
			//	and globalToLocal() returns a point object {x, y} as move() expects
			
			//NOTE:
			//we add the value to the container at the index we want to insert to
			//since this makes the value part of a SUB-CONTAINER (inside the array container)
			//it has ITS OWN coordinate system, separate from the array or the stage at large
			//so we need to use globalToLocal() ON THAT CHILD CONTAINER to get correct positioning, instead of on the array
			//then as on() returns global coords we can feed it to globalToLocal() to get the correct positioning
			value_move.to(
				array.children[insertion_index].globalToLocal(array.children[insertion_index]._.on().x, array.children[insertion_index]._.on().y)
			);
			
			//add Number(value.text) to values array
			array._.values.push(Number(value.text));
			
			//return the new length of the array, as per Array.prototype.push()
			return array._.values.length;
		};
		
		return array;
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_lib : undefined,			//holds a reference to the lib object, created by AA and used to access objects created by AA
	_array : undefined,			//internal reference to the array created
	_arrow : undefined,			//internal reference to the associated arrow to the array
};