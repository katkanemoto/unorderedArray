module.exports = array_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function array_UI(options) {
	if (!(this instanceof array_UI)) return new array_UI(options);
	
	//requires primitives.lib and primitives.createjs
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._lib = primitives.get('lib');
	if (check.undefined(this._lib) || check.not.object(this._lib)) {
		throw new ReferenceError("'lib' undefined or not object in primitives object.");
	}
	
	//requires argument length, how big to make the array (should be integer > 0)
	if (check.undefined(options) || check.undefined(options.length) || check.not.integer(options.length) || options.length <= 0) {
		throw new TypeError("Require argument object with property 'length'. 'length' should be an integer > 0.");
	}
	
	//check for arrow specific options, optional
	var arrow_options = {
		name : "tail",
	};
	if (check.not.undefined(options) && check.not.undefined(options.arrow) && check.object(options.arrow)) {
		if (check.not.undefined(options.arrow.name)) {
			if (check.string(options.arrow.name)) {
				arrow_options.name = options.arrow.name;
			} else {
				throw new TypeError("Optional argument: arrow.name, should be String.");
			}
		}
	}
	
	//TODO: remove containers and just make container of ArrayElements
	//create an array of containers containing ArrayElements, we'll place the Text objects in the inner containers later when we assign a value to an index
	this._array = this._make_array(options.length);
	
	//decorate outer container with an array that will map to the values contained in the array holding the UI elements
	//	when they're added with the methods added below
	this._array = this._decorate_value_array(this._array);
	
	//decorate the outer container with an iterator() method, to get a UI arrow that acts as an iterator over the array
	this.array = this._decorate_iterator(this._array);
	
	//get the arrow associated with the array, points at the first elements in the array
	//	the arrow implements the iterator protocol and is assigned a next() function that will traverse the array,
	//	returning values in the array as well as move()ing the UI arrow to the next position in the array
	this._arrow = this._iterator(this._array, arrow_options.name);
	//adding the arrow to the array container to allow relative positioning of both UI elements as a unit
	//(the arrow is NOT traversed by a call to next() on the arrow, even though it is in the array container)
	this._array.addChild(this._arrow);
	//decorate the arrow onto the array, to allow referencing by calling functions
	this._array._.arrow = this._arrow;
	
	//decorate outer container with convenience methods that:
	//	handle adding values to the array
	//		this methods handles the UI aspects of adding value (move()) and the logical aspect (updating the internal logical / UI containers with the values added)
	this._array = this._decorate_method_push(this._array, this._arrow);
	
	//add the move() method to the array
	this._array = this._decorate_move(this._array);
	
	//add the pop() method to the array
	this._array = this._decorate_method_pop(this._array, this._arrow);
	
	//add move_within()
	this._array = this._decorate_method_move_within(this._array, this._arrow);
	
	return this._array;
}

array_UI.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//creates an array of ArrayElement's, with maximum size length
	//each child in the array is a container containing an ArrayElement, when we're adding values, the values are added to they're associated container
	//each child is decorated with a _ namespace that is used later to add functionality
	//each child is decorated with a _.index property that matches its index in the array
	//the Container containing the the children is decorated with a _ namespace, to add functionality
	//the Container containing the the children is decorated with a _.length property to indicate its maximum size
	_make_array : function(length) {
		var offsetX = 0;
		var outer_container = new this._createjs.Container();
		
		for (var i = 0; i < length; i++) {
			//create the array element in a container, so 
			var arrayElement = new this._lib.ArrayElement();
			var inner_container = new this._createjs.Container();
			inner_container.addChild(arrayElement);
			
			//offset each subcontainer by the size of the array element box
			inner_container.x = offsetX;
			
			//create a new namespace to decorate into
			inner_container._ = {};
			
			//BUG:
			//for some reason the width as returned by getBounds() is about half of the ArrayElement length as shown on the canvas
			//	using 50px as workaround
			//offsetX += arrayElement.getBounds().width;
			offsetX += 50;
			
			//setting associated index (displays below ArrayElement figure, configured by AA)
			arrayElement.index_txt.text = String(i);
			//inner_container._.index = i;	//setting index for iteration by the tail arrow
			
			outer_container.addChild(inner_container);
		}
		
		//set bounds on the array, for using place() later
		//NOTE: having to guess at the height of the container, as arrayElement's don't have correct bounds
		outer_container.setBounds(0, 0, offsetX, 50 + 20);
		
		//create a namespace to decorate into
		outer_container._ = {};
		
		//add a length property, to show the maximum size of the array
		outer_container._.length = length;
		
		return outer_container;
	},
	
	//decorates a values array onto the array Container, that is meant to contain the numeric values added to the array
	_decorate_value_array : function(array) {
		array._.values = [];
		return array;
	},
	
	//add a method to the array to return an iterator arrow over the array
	//(name is required and cannot be empty)
	_decorate_iterator : function(array) {
		var instance = this;
		array._.iterator = function(name) {
			if(check.undefined(name) || check.emptyString(name)) {
				throw new TypeError("Required argument 'name' missing, should be non-empty String");
			}
			
			return instance._iterator(array, name);
		}
	},
	
	//TODO: adjust arrow_UI to allow for empty labels
	//add an arrow pointing at the 0th position of the array, labeled name (name is required and cannot be empty)
	//the arrow acts as a UI element and iterator, such that it will logically traverse the values array (above)
	//	as well as move() itself on the stage when its next() / prev() / set() function is called
	//	as next() / prev() / set() tracks indices according to the size of the array NOT using the size of the array.children array as its guide to how many children there are
	//decorates an "index" property into the _ namespace of the arrow, to track which index in the array the arrow is pointing to
	_iterator : function(array, name) {
		var array_arrow_UI = require('lib/UI/array_arrow_UI');
		var arrow = array_arrow_UI({name:name, array:array});
		
		return arrow;
	},
	
	//add a method to push values onto the array
	//takes a createjs Text object, whose value is a number
	//tweens the Text object to the first available position in the UI array
	//	the index where the tail arrow is currently pointing, before move()d to the next position in the array
	//adds the value in the Text object to the "values" array (decorated in the _ namespace, above)
	//returns an error if the array is full
	_decorate_method_push : function(array, arrow) {
		var instance = this;
		
		array._.push = function(options) {
			if (check.undefined(options) || check.not.object(options)) {
				throw new TypeError("Requires a options object.");
			}
			
			//value should be a createjs.Text object, whose text value is a number
			if(check.not.instanceStrict(options.value, createjs.Text) || check.not.number(Number(options.value.text))) {
				throw new TypeError("Required argument: 'value', should be a createjs.Text object whose value is a number.");
			}
			
			//cleanup the array of any extraneous null items in the values array
			array = instance._cleanup_values_array(array, arrow);
			
			//error if array is full
			if (array._.values.length === array._.length) {
				throw new RangeError("Array is full, cannot push() new value.");
			}
			
			//determines whether push() will tween the object around the stage or simply place it in the array
			var tween = true;
			if (check.not.undefined(options.tween)) {
				if (check.not.boolean(options.tween)) {
					throw new TypeError("Optional argument: 'tween', should be true or false.");
				} else {
					tween = options.tween;
				}
			}
			
			var value = options.value;
			
			//get the index where we can insert (from arrow)
			var insertion_index = arrow._.index;
			
			if (tween) {
				//move() value to that index
				var move = require('lib/util/move');
				var value_move = move(value);
				
				var initial_point;
				//BUG: Equality testing does not work when comparing the stage to itself
				if (check.null(value.parent.parent)) {
					//if value is on the stage, then:
					//translate the initial point of the value, to the local coordinate space of the array
					initial_point = array.children[insertion_index].globalToLocal(value.x, value.y);
				} else {
					//else the object is inside some container, so translate the coordinates from inside that container, to the coordinates of the target container
					initial_point = value.localToLocal(value.x, value.y, array.children[insertion_index]);
					
					//if the container has a _.values decorated array, then subtract the value from the array at the source
					var possible_array = value.parent.parent;
					
					if(check.object(possible_array._) && check.array(possible_array._.values)) {
						//find the value in the source's values array
						var index = possible_array._.values.findIndex(function(element, index, array) {
							if (element === Number(value.text)) return true;
							return false;
						});
						
						//if found (return was not -1) ...
						if (index >= 0) {
							//...then remove the value at that index
							possible_array._.values.splice(index, 1);
						} else {
							//...if not, throw to alert the user of some issue
							throw new Error("Unknown error, when attempting to push() a value (" + Number(value.text) + ") onto this array, the source array containing that value did NOT have that value in its internal values array (source_array._.values)");
						}
					}
				}
				
				//before moving the value into the array container, set its position such that it will appear not to have moved after translating to the new coordinate space inside the container
				value.x = initial_point.x;
				value.y = initial_point.y;
				
				//add the value to the array as a child of the container at the insertion_index
				array.children[insertion_index].addChild(value);
				
				//just move the value to the location within the child container inside the array, since each ArrayElement has its own container, we place relative to that, which is always within the same position relative to the ArrayElement on the canvas
				value_move.to( {x:9, y:15} );
			} else {
				//else if we're not moving, then just add it to the array with manual positioning
				array.children[insertion_index].addChild(value);
				value.x = 9;
				value.y = 15;
			}
			
			//add Number(value.text) to values array
			array._.values.push(Number(value.text));
			
			//return the new length of the array, as per Array.prototype.push()
			return array._.values.length;
		};
		
		return array;
	},
	
	_decorate_move : function(array) {
		var move = require('lib/util/move');
		array._.move = move(array);
		return array;
	},
	
	//add a method pop({index:i}), either removes the last item in the array (as determined by its tail arrow) or an item at index i (optional)
	//	removed items are set to "null" to indicate a gap in the array (as shown in the UI), these are removed by move_within() (below)
	_decorate_method_pop : function(array, arrow) {
		var instance = this;
		
		//DEBUG
		/* console.log(array);
		console.log(arrow); */
		
		array._.pop = function(options) {
			var index = arrow._.index - 1;
			//optional argument: index, should be integer and in bounds on the array
			if (check.not.undefined(options) && check.not.undefined(options.index)) {
				if (check.not.integer(options.index)) {
					throw new TypeError("Optional argument 'index', should be an integer within the range 0...tail.");
				} else {
					if (options.index >= 0 && options.index < arrow._.index) {
						index = options.index
					} else {
						throw new RangeError("Optional argument 'index', should be an integer within the range 0...tail.");
					}
				}
			}
			
			if (array._.values.length === 0) {
				throw new RangeError("pop() from an empty array");
			}
			
			if (check.null(array._.values[index])) {
				throw new RangeError("pop() at empty index in the array.");
			}
			
			//cleanup the array of any extraneous null items in the values array
			array = instance._cleanup_values_array(array, arrow);
			
			//remove the item from values array and get the value for returning later
			//	using null here to signify a "gap" in the array, that the UI shows, but a real array would not show
			var ret = array._.values[index];
			array._.values[index] = null;
			
			//remove the item from the UI
			array.children[index].removeChildAt(1);
			
			return ret;
		};
		
		return array;
	},
	
	//add a method move_within(src, dst, options), where `src` and `dst` are required and should be indices in the array
	//the createjs.Text element within the UI array at index `src` is moved to index `dst`
	//	it is an error if `src` has no element to move
	//	any element at index `dst` is overwritten
	//	optional argument: tween (boolean), causes the process to be tweened in the UI (default) via move(), 
	//		otherwise the `src` element is simply removed from its index and added to its `dst` container (no animation)
	_decorate_method_move_within : function(array, arrow) {
		var instance = this;
		
		array._.move_within = function(src, dst, options) {
			//error on empty array case
			if (array._.values.length === 0) {
				throw new RangeError("move_within() from an empty array");
			}
			
			//required arguments: `src` & `dst` should be integers within the bounds of possible values in the array
			function check_src_and_dst(arg, name) {
				if (check.not.integer(arg)) {
					throw new TypeError("Required argument '" + String(name) + "', should be an integer within the range 0...tail.")
				}
				
				if(arg < 0 || arg >= arrow._.index) {
					throw new RangeError("Required argument '" + String(name) + "', should be an integer within the range 0...tail.");
				}
				
				return arg;
			}
			
			var source = check_src_and_dst(src, "source");
			var destination = check_src_and_dst(dst, "destination");
			
			//if source and destination are equal, just return without doing anything
			if (source === destination) return false;
			
			//source index should have a createjs.Text element at that index to move
			if (array.children[source].children.length <= 1) {
				throw new ReferenceError("No element to move, at source index: " + String(source));
			}
			
			//if options is defined and has a property `tween` then it should be a boolean
			var tween = true;
			if (check.not.undefined(options) && check.not.undefined(options.tween)) {
				if (check.not.boolean(options.tween)) {
					throw new TypeError("Optional argument: 'tween', should be true or false.");
				} else {
					tween = options.tween;
				}
			}
			
			//cleanup the array of any extraneous null items in the values array
			array = instance._cleanup_values_array(array, arrow);
			
			//if there is an element at destination index, then remove it first
			if (array.children[destination].children.length > 1) {
				array.children[destination].removeChildAt(1);
			}
			
			//add the source element to the destination index
			var source_element = array.children[source].children[1];
			array.children[destination].addChild(source_element);	//addChild() side effect is removing from its original container
			
			//if we're tweening, then set the source elements' coordinates to values such that it appears in the same position as it was originally
			//	then move() to (9, 15)
			if (tween) {
				var offset = array.children[source].x - array.children[destination].x;
				source_element.x += offset;
				
				var move = require('lib/util/move');
				var element_move = move(source_element);
				element_move.to({x:9, y:15});
			}
			
			//update the values array to show the move
			array._.values[destination] = array._.values[source];	//put the source value in the destination index
			array._.values[source] = null;	//remove the source
			
			//return the modified array to caller
			return array._.values;
		};
		
		return array;
	},
	
	//traverse backwards through the array._.values array checking for null values, if we find nulls, then remove them, stopping once we've examined the index that the arrow is pointing at
	_cleanup_values_array : function(array, arrow) {
		var index = array._.length - 1;
		while(true) {
			if (index === arrow._.index - 1) break;
			
			if (check.null(array._.values[index])) array._.values.pop();
			
			index -= 1;
		}
		
		return array;
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_lib : undefined,			//holds a reference to the lib object, created by AA and used to access objects created by AA
	_array : undefined,			//internal reference to the array created
	_arrow : undefined,			//internal reference to the associated arrow to the array
};

//NOTE: removed check for push() here, as allocating the tail arrow on the array,
//requires the array as an argument and push() requires an allocated tail arrow in order to work;
//creating a circular dependency, so adjusted to the below properties to identify an array instead
array_UI.is_array = function(obj) {
	if (check.object(obj) &&
		check.object(obj._) &&
		check.array(obj._.values) &&
		check.integer(obj._.length)
		) {
			return true;
		}
	return false;
};