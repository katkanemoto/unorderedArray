module.exports = array_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function array_UI(options) {
	if (!(this instanceof array_UI)) return new array_UI(options);
	
	//requires primitives.lib and primitives.createjs
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._lib = primitives.get('lib');
	if (check.undefined(this._lib) || check.not.object(this._lib)) {
		throw new ReferenceError("'lib' undefined or not object in primitives object.");
	}
	
	//requires argument length, how big to make the array (should be integer > 0)
	if (check.undefined(options) || check.undefined(options.length) || check.not.integer(options.length) || options.length <= 0) {
		throw new TypeError("Require argument objet with property 'length'. 'length' should be an integer > 0.");
	}
	
	//create an array of containers containing ArrayElements, we'll place the Text objects in the inner containers later when we assign a value to an index
	this._array = this._make_array(options.length);
	
	//decorate the inner containers with coordinates to place UI elements below / on the arrayElements in the array
	this._array = this._decorate_coordinates(this._array);
	
	//decorate outer container with an array that will map to the values contained in the array holding the UI elements
	//	when they're added with the methods added below
	this._array = this._decorate_value_array(this._array);
	
	//get the arrow associated with the arrow, points at the first elements in the array
	this._arrow = this._setup_tail_arrow(this._array);
	
	//decorate outer container with convenience methods that:
	//	handle adding values to the array
	//		this methods handles the UI aspects of adding value (move()) and the logical aspect (updating the internal logical / UI containers with the values added)
	//	a method to get an iterator over the values in the array
	//	a method to check if the array is empty
	//this._array = this._decorate_method_push(this._array);
	
	/* //create a new namespace to decorate into
	outer_container._ = {};
	
	//decorate a value of the length onto the array, for use by other methods (e.g. checking for out of bounds)
	outer_container._.length = length; */
	
	return this._array;
}

array_UI.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	_make_array : function(length) {
		var offsetX = 0;
		var outer_container = new this._createjs.Container();
		
		for (var i = 0; i < length; i++) {
			//create the array element in a container, so 
			var arrayElement = new this._lib.ArrayElement();
			var inner_container = new this._createjs.Container();
			inner_container.addChild(arrayElement);
			
			//offset each subcontainer by the size of the array element box
			inner_container.x = offsetX;
			
			//create a new namespace to decorate into
			inner_container._ = {};
			
			//BUG:
			//for some reason the width as returned by getBounds() is about half of the ArrayElement length as shown on the canvas
			//	using 50px as workaround
			//offsetX += arrayElement.getBounds().width;
			offsetX += 50;
			
			//setting associated index (displays below ArrayElement figure, configured by AA)
			arrayElement.index_txt.text = String(i);
			inner_container._.index = i;	//setting index for iteration by the tail arrow
			
			outer_container.addChild(inner_container);
		}
		
		//set bounds on the array, for using place() later
		//NOTE: having to guess at the height of the container, as arrayElement's don't have correct bounds
		outer_container.setBounds(0, 0, offsetX, 50 + 20);
		
		//create a namespace to decorate into
		outer_container._ = {};
		
		return outer_container;
	},
	
	_decorate_coordinates : function(array) {
		for (var i = 0; i < array.children.length; i++) {
			var arrayElement = array.children[i];
			
			//create functions in the _ namespace for each type of move we need
			//call a function (with the current child index) that returns a function of that child and its parent coordinates
			//	this allows updating of the position of the coordinates as the parent container moves or is placed in a different location
			//	via the magic of closures
			arrayElement._.below = (function(j) {
				return function() {
					return {x:array.x + array.children[j].x + 22, y:array.y + 70};
				}
			})(i);
			
			arrayElement._.on = (function(j) {
				return function() {
					return {x:array.x + array.children[j].x + 9, y:array.y + 15};
				}
			})(i);
		}
		
		return array;
	},
	
	//add an arrow pointing at the 0th position of the array, labeled "tail"
	_setup_tail_arrow : function(array) {
		var arrow_UI = require('lib/UI/arrow_UI');
		
		function tail_arrow_next() {
			if (this._.pointed_at._.index + 1 >= array.length) {
				//out of bounds case
				return {done : true};
			} else {
				//increment to next child, return its value and done === false
				//	move() arrow below next child
				var new_index = this._.pointed_at._.index + 1;
				this._.pointed_at = array[new_index];
				this._.move.to(array[new_index]._.below());
				return {value : array._.values[new_index], done : false};
			}
		};
		
		var args = {
			name: "tail",
			//place the arrow initially under the 0th child, as there are not values in the array yet
			position: array.children[0]._.below(),
			//arrow is pointing at the 0th child
			pointed_at: array.children[0],
			//define how to iterate the arrow
			next: tail_arrow_next,
		};
		
		return arrow_UI(args);
	},
	
	_decorate_value_array : function(array) {
		array._.values = [];
		return array;
	},
	
	_decorate_method_push : function(array) {
		//takes a createjs Text object, whose value is a number
		//tweens the Text object to the first available position in the UI array
		//adds the value in the Text object to the "values" array (decorated in the _ namespace)
		//returns an error if the array is full
		array._.push = function(value) {
			//value should be a Text object, whose text value is a number
			if(check.not.instanceStrict(value, createjs.Text) || check.not.number(Number(value.text))) {
				throw new TypeError("Requires a createjs.Text object whose value is a number.");
			}
			
			//error if array is full
			if (array._.values.length === array._.length) {
				throw new RangeError("Array is full, cannot push() new value.");
			}
		};
		
		return array;
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_lib : undefined,			//holds a reference to the lib object, created by AA and used to access objects created by AA
	_array : undefined,			//internal reference to the array created
	_arrow : undefined,			//internal reference to the associated arrow to the array
};