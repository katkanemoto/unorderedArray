module.exports = array_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function array_UI(options) {
	if (!(this instanceof array_UI)) return new array_UI(options);
	
	//requires primitives.lib and primitives.createjs
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._lib = primitives.get('lib');
	if (check.undefined(this._lib) || check.not.object(this._lib)) {
		throw new ReferenceError("'lib' undefined or not object in primitives object.");
	}
	
	//requires argument length, how big to make the array (should be integer > 0)
	if (check.undefined(options) || check.undefined(options.length) || check.not.integer(options.length) || options.length <= 0) {
		throw new TypeError("Require argument object with property 'length'. 'length' should be an integer > 0.");
	}
	
	//TODO: remove containers and just make container of ArrayElements
	//create an array of containers containing ArrayElements, we'll place the Text objects in the inner containers later when we assign a value to an index
	this._array = this._make_array(options.length);
	
	//decorate outer container with an array that will map to the values contained in the array holding the UI elements
	//	when they're added with the methods added below
	this._array = this._decorate_value_array(this._array);
	
	//decorate the outer container with an iterator() method, to get a UI arrow that acts as an iterator over the array
	this.array = this._decorate_iterator(this._array);
	
	//get the arrow associated with the array, points at the first elements in the array
	//	the arrow implements the iterator protocol and is assigned a next() function that will traverse the array,
	//	returning values in the array as well as move()ing the UI arrow to the next position in the array
	this._arrow = this._iterator(this._array, "tail");
	
	//decorate outer container with convenience methods that:
	//	handle adding values to the array
	//		this methods handles the UI aspects of adding value (move()) and the logical aspect (updating the internal logical / UI containers with the values added)
	this._array = this._decorate_method_push(this._array, this._arrow);
	
	return {array: this._array, arrow: this._arrow};
}

array_UI.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//creates an array of ArrayElement's, with maximum size length
	//each child in the array is a container containing an ArrayElement, when we're adding values, the values are added to they're associated container
	//each child is decorated with a _ namespace that is used later to add functionality
	//each child is decorated with a _.index property that matches its index in the array
	//the Container containing the the children is decorated with a _ namespace, to add functionality
	//the Container containing the the children is decorated with a _.length property to indicate its maximum size
	_make_array : function(length) {
		var offsetX = 0;
		var outer_container = new this._createjs.Container();
		
		for (var i = 0; i < length; i++) {
			//create the array element in a container, so 
			var arrayElement = new this._lib.ArrayElement();
			var inner_container = new this._createjs.Container();
			inner_container.addChild(arrayElement);
			
			//offset each subcontainer by the size of the array element box
			inner_container.x = offsetX;
			
			//create a new namespace to decorate into
			inner_container._ = {};
			
			//BUG:
			//for some reason the width as returned by getBounds() is about half of the ArrayElement length as shown on the canvas
			//	using 50px as workaround
			//offsetX += arrayElement.getBounds().width;
			offsetX += 50;
			
			//setting associated index (displays below ArrayElement figure, configured by AA)
			arrayElement.index_txt.text = String(i);
			inner_container._.index = i;	//setting index for iteration by the tail arrow
			
			outer_container.addChild(inner_container);
		}
		
		//set bounds on the array, for using place() later
		//NOTE: having to guess at the height of the container, as arrayElement's don't have correct bounds
		outer_container.setBounds(0, 0, offsetX, 50 + 20);
		
		//create a namespace to decorate into
		outer_container._ = {};
		
		//add a length property, to show the maximum size of the array
		outer_container._.length = length;
		
		return outer_container;
	},
	
	//decorates a values array onto the array Container, that is meant to contain the numeric values added to the array
	_decorate_value_array : function(array) {
		array._.values = [];
		return array;
	},
	
	//add a method to the array to return an iterator arrow over the array
	//(name is required and cannot be empty)
	_decorate_iterator : function(array) {
		var instance = this;
		array._.iterator = function(name) {
			if(check.undefined(name) || check.emptyString(name)) {
				throw new TypeError("Required argument 'name' missing, should be non-empty String");
			}
			
			return instance._iterator(array, name);
		}
	},
	
	//TODO: adjust arrow_UI to allow for empty labels
	//add an arrow pointing at the 0th position of the array, labeled name (name is required and cannot be empty)
	//the arrow acts as a UI element and iterator, such that it will logically traverse the values array (above)
	//	as well as move() itself on the stage when its next() function is called
	//	the arrow is added as a child of the array Container to allow for relative positioning, this is NOT traversed to on a call to next()
	//	as next() tracks indices according to the size of the array NOT using the size of the array.children array as its guide to how many children there are
	_iterator : function(array, name) {
		var arrow_UI = require('lib/UI/arrow_UI');
		
		//NOTE:
		//`this`, in a next function refers to the arrow object
		/* as such it has properties in this configuration:
		{
			move: move
			name: "tail",
			pointed_at: <some UI object>,
			next : <the next() function (assigned below)>
			index : <some integer>
			}
		so addressing said properties is not done via the _ namespace, but rather directly on the `this` object itself */
		function arrow_next() {
			if (this.index + 1 > array._.length) {
				//going to be out of bounds case
				return {done : true};
			} else {
				//increment to the next child, return its value and done === false
				//	move() arrow below next child
				var new_index = this.index + 1;
				if (new_index < array._.length) {
					this.pointed_at = array.children[new_index];
				} else {
					this.pointed_at = undefined;
				}
				
				//update the internal index to reflect the move
				this.index = new_index;
				
				//move 50 px beyond the last child (this handles moving underneath children AND moving beyond the array)
				this.move.to({x:array.children[new_index - 1].x + 50 + 22, y:70});
				
				//value is always undefined, as we use the arrow to point to indices in the array which have no content (as it's the tail arrow)
				return {value : undefined, done : false};
			}
		};
		
		var args = {
			name: String(name),
			//place the arrow initially under the 0th child, as there are not values in the array yet
			position: {x:array.children[0].x + 22, y:70},
			//arrow is pointing at the 0th child
			pointed_at: array.children[0],
			//define how to iterate the arrow
			next: arrow_next,
			//which index it's pointing to
			index : 0,
		};
		
		//add the arrow to the array to do relative positioning inside the array container
		var arrow = arrow_UI(args);
		array.addChild(arrow);
		
		return arrow;
	},
	
	//add a method to push values onto the array
	//takes a createjs Text object, whose value is a number
	//tweens the Text object to the first available position in the UI array
	//	the index where the tail arrow is currently pointing, before move()d to the next position in the array
	//adds the value in the Text object to the "values" array (decorated in the _ namespace, above)
	//returns an error if the array is full
	_decorate_method_push : function(array, arrow) {
		array._.push = function(value) {
			//value should be a createjs.Text object, whose text value is a number
			if(check.not.instanceStrict(value, createjs.Text) || check.not.number(Number(value.text))) {
				throw new TypeError("Requires a createjs.Text object whose value is a number.");
			}
			
			//error if array is full
			if (array._.values.length === array._.length) {
				throw new RangeError("Array is full, cannot push() new value.");
			}
			
			//get the index where we can insert (from arrow)
			var insertion_index = arrow._.pointed_at._.index;
			
			//move() value to that index
			var move = require('lib/util/move');
			var value_move = move(value);
			
			var initial_point;
			//BUG: Equality testing does not work when comparing the stage to itself
			if (check.null(value.parent.parent)) {
				//if value is on the stge, then:
				//translate the initial point of the value, to the local coordinate space of the array
				initial_point = array.children[insertion_index].globalToLocal(value.x, value.y);
			} else {
				//else the object is inside some container, so translate the coordinates from inside that container, to the coordinates of the target container
				initial_point = value.localToLocal(value.x, value.y, array.children[insertion_index]);
			}
			
			//before moving the value into the array container, set its position such that it will appear not to have moved after translating to the new coordinate space inside the container
			value.x = initial_point.x;
			value.y = initial_point.y;
			
			//add the value to the array as a child of the container at the insertion_index
			array.children[insertion_index].addChild(value);
			
			//just move the value to the location within the child container inside the array, since each ArrayElement has its own container, we place relative to that, which is always within the same position relative to the ArrayElement on the canvas
			value_move.to( {x:9, y:15} );
			
			//add Number(value.text) to values array
			array._.values.push(Number(value.text));
			
			//return the new length of the array, as per Array.prototype.push()
			return array._.values.length;
		};
		
		return array;
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_lib : undefined,			//holds a reference to the lib object, created by AA and used to access objects created by AA
	_array : undefined,			//internal reference to the array created
	_arrow : undefined,			//internal reference to the associated arrow to the array
};