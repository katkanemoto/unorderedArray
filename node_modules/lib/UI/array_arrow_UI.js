var check = require('check-types');
var primitives = require("lib/util/primitives");

function array_arrow_UI(options) {
	if (!(this instanceof array_arrow_UI)) return new array_arrow_UI(options);
	
	//requires primitives.createjs
	//TODO: will need primitives.lib once we're done using mock arrow
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	if (check.undefined(options)) {
		throw new TypeError("Require argument object.");
	}
	
	//required argument: name (makes a createjs.Text object associated with the arrow)
	if (check.undefined(options.name) || check.not.string(options.name)) {
		throw new TypeError("Require argument object with property 'name', should be String.");
	}
	
	//require argument: array, should be array_UI the arrow is associated with
	var array_UI = require('lib/UI/array_UI');
	if (!array_UI.is_array(options.array)) {
		throw new TypeError("Required argument 'array', should be array_UI.");
	}
	
	//optional argument: index, defaults to 0, otherwise should be integer and in bounds on the array
	//	including the index immediately following the end of the array
	if (check.not.undefined(options.index)) {
		if (check.not.integer(options.index) || (options.index < -1) || (options.array._.length < options.index)) {
			throw new TypeError("Argument 'index', should be integer and in bounds on the array.");
		}
	} else {
		options.index = 0;
	}
	
	//make the UI object for the arrow
	this._arrow = this._make_arrow(options.name);
	
	//decorate basic properties and methods onto the arrow
	this._arrow = this._decorate(this._arrow, options);
	
	//setup the set() function for future moves
	this._arrow = this._decorate_set(this._arrow, options);
	
	//set the initial position for the arrow
	this._arrow._.set(options.index, {tween:false});
	
	//setup additional public methods
	this._arrow = this._decorate_utility_methods(this._arrow, options);
	
	return this._arrow;
};

array_arrow_UI.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	_make_arrow : function(name) {
		var arrow_factory = require('lib/factory/arrow_factory');
		var af = arrow_factory();
		af.arrow({direction: "up"});
		
		var arrow = af.get();
		
		var c = new this._createjs.Container();
		c.addChild(arrow);
		
		//append the name to the arrow and decorate onto the arrow for reference
		var text_factory = require('lib/factory/text_factory');
		var tf = text_factory();
		tf.text({text:name});
		var label = tf.get();
		
		//lifted from 'lib/util/place', below()
		label.x = arrow.x - label.getBounds().x;
		label.y = arrow.y + arrow.getBounds().height - label.getBounds().y;
		
		//slight correction: down and to the left, to be centered under the arrow
		label.y += 5;
		label.x += -10;
		
		c.addChild(label);
		
		return c;
	},
		
	_decorate : function(arrow, options) {
		//setup a decoration namespace
		arrow._ = {};
		
		//decorate with the name of the arrow
		arrow._.name = options.name;
		
		//for storing a reference of the object the arrow is pointed at
		arrow._.pointed_at = null;
		
		//add move() functionality
		var move = require('lib/util/move');
		arrow._.move = move(arrow);
		
		//store the index in the array where the arrow is pointed at
		arrow._.index = options.index;
		
		return arrow;
	},
	
	_decorate_set : function(arrow, options) {
		var array = options.array;
		
		//set the arrow (either tween / set position manually) the arrow with respect to an element in the array
		arrow._.set = function(index, options) {
			if (check.not.integer(index) || (index < -1) || (index > array._.length)) {
				throw new TypeError("Argument 'index', should be integer and in bounds on the array.");
			}
			
			var tween = true;
			if (check.not.undefined(options)) {
				if (check.not.undefined(options.tween)) {
					if (check.not.boolean(options.tween)) {
						throw new TypeError("Optional argument: 'tween', should be true or false.");
					} else {
						tween = options.tween;
					}
				}
			}
			
			//set the arrow to logically point at the item at the index passed
			arrow._.index = index;
			//if we're at the tail end of the array or before the beginning of the array, then set undefined
			if(index === array._.length || index === -1) {
				arrow._.pointed_at = undefined;
			} else {
				arrow._.pointed_at = array.children[index];
			}
			
			//position the arrow
			var new_x;
			var new_y = 70;
			
			//handle the special cases of being at 0 or -1
			if (index === 0) {
				new_x = array.children[index].x + 22;
			}
			
			if (index === -1) {
				new_x = array.children[index + 1].x - 50 + 22;
			} 
			
			if (index > 0) {
				//else just offset from the previous array element, which will handle the case of being at the tail end of the array
				new_x = array.children[index - 1].x + 50 + 22;
			}
			
			if (tween) {
				arrow._.move.to({x:new_x, y:new_y});
			} else {
				arrow.x = new_x;
				arrow.y = new_y;
			}
		};
		
		return arrow;
	},
	
	_decorate_utility_methods : function(arrow, options) {
		var array = options.array;
		arrow._.next = function(options) {
			//end of the array case
			if (arrow._.index === array._.length) {
				return {done:true};
			}
			
			var new_index = arrow._.index + 1;
			arrow._.set(new_index, options);
			
			return {value:array._.values[new_index], done:false};
		};
		
		arrow._.prev = function(options) {
			//beginning of the array case
			if (arrow._.index === 0) {
				return {done:true};
			}
			
			var new_index = arrow._.index - 1;
			arrow._.set(new_index, options);
			
			return {value:array._.values[new_index], done:false};
		}
		
		return arrow;
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_arrow : undefined,			//internal reference to the arrow created
};

array_arrow_UI.is_arrow = function(obj) {
	if (check.object(obj) &&
		check.object(obj._) &&
		check.string(obj._.name) &&
		check.integer(obj._.index) &&
		check.function(obj._.set)
		) {
			return true;
		}
	return false;
};

module.exports = array_arrow_UI;