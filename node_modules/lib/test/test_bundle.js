(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
require('lib/test/factory/test_arrow_factory');
require('lib/test/factory/test_html_factory');
require('lib/test/factory/test_shape_factory');
require('lib/test/factory/test_text_factory');

require('lib/test/lesson/test_unordered_array_lesson');

require('lib/test/UI/test_lesson_UI');
require('lib/test/UI/test_array_UI');
require('lib/test/UI/test_arrow_UI');

require('lib/test/util/test_add_to_stage');
require('lib/test/util/test_append_to');
require('lib/test/util/test_argument_check');
require('lib/test/util/test_move');
require('lib/test/util/test_primitives');
require('lib/test/util/test_random_color');
require('lib/test/util/test_random_hex');
require('lib/test/util/test_random_integer');
require('lib/test/util/test_type_of');
require('lib/test/util/test_unique_id');


},{"lib/test/UI/test_array_UI":49,"lib/test/UI/test_arrow_UI":50,"lib/test/UI/test_lesson_UI":51,"lib/test/factory/test_arrow_factory":52,"lib/test/factory/test_html_factory":53,"lib/test/factory/test_shape_factory":54,"lib/test/factory/test_text_factory":55,"lib/test/lesson/test_unordered_array_lesson":56,"lib/test/util/test_add_to_stage":58,"lib/test/util/test_append_to":59,"lib/test/util/test_argument_check":60,"lib/test/util/test_move":61,"lib/test/util/test_primitives":62,"lib/test/util/test_random_color":63,"lib/test/util/test_random_hex":64,"lib/test/util/test_random_integer":65,"lib/test/util/test_type_of":66,"lib/test/util/test_unique_id":67}],2:[function(require,module,exports){
'use strict'

exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"buffer":5}],5:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  that.write(string, encoding)
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

function arrayIndexOf (arr, val, byteOffset, encoding) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var foundIndex = -1
  for (var i = byteOffset; i < arrLength; ++i) {
    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
      if (foundIndex === -1) foundIndex = i
      if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
    } else {
      if (foundIndex !== -1) i -= i - foundIndex
      foundIndex = -1
    }
  }

  return -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  if (Buffer.isBuffer(val)) {
    // special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(this, val, byteOffset, encoding)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset, encoding)
  }

  throw new TypeError('val must be string, number or Buffer')
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":2,"ieee754":35,"isarray":40}],6:[function(require,module,exports){
/*globals define, module, Symbol */

(function (globals) {
  'use strict';

  var strings, messages, predicates, functions,
      assert, not, maybe, collections, slice;

  strings = {
    v: 'value',
    n: 'number',
    s: 'string',
    b: 'boolean',
    o: 'object',
    t: 'type',
    a: 'array',
    al: 'array-like',
    i: 'iterable',
    d: 'date',
    f: 'function',
    l: 'length'
  };

  messages = {};
  predicates = {};

  [
    { n: 'equal', f: equal, s: 'v' },
    { n: 'undefined', f: isUndefined, s: 'v' },
    { n: 'null', f: isNull, s: 'v' },
    { n: 'assigned', f: assigned, s: 'v' },
    { n: 'includes', f: includes, s: 'v' },
    { n: 'zero', f: zero, s: 'n' },
    { n: 'infinity', f: infinity, s: 'n' },
    { n: 'number', f: number, s: 'n' },
    { n: 'integer', f: integer, s: 'n' },
    { n: 'even', f: even, s: 'n' },
    { n: 'odd', f: odd, s: 'n' },
    { n: 'greater', f: greater, s: 'n' },
    { n: 'less', f: less, s: 'n' },
    { n: 'between', f: between, s: 'n' },
    { n: 'greaterOrEqual', f: greaterOrEqual, s: 'n' },
    { n: 'lessOrEqual', f: lessOrEqual, s: 'n' },
    { n: 'inRange', f: inRange, s: 'n' },
    { n: 'positive', f: positive, s: 'n' },
    { n: 'negative', f: negative, s: 'n' },
    { n: 'string', f: string, s: 's' },
    { n: 'emptyString', f: emptyString, s: 's' },
    { n: 'nonEmptyString', f: nonEmptyString, s: 's' },
    { n: 'contains', f: contains, s: 's' },
    { n: 'match', f: match, s: 's' },
    { n: 'boolean', f: boolean, s: 'b' },
    { n: 'object', f: object, s: 'o' },
    { n: 'emptyObject', f: emptyObject, s: 'o' },
    { n: 'instanceStrict', f: instanceStrict, s: 't' },
    { n: 'instance', f: instance, s: 't' },
    { n: 'like', f: like, s: 't' },
    { n: 'array', f: array, s: 'a' },
    { n: 'emptyArray', f: emptyArray, s: 'a' },
    { n: 'arrayLike', f: arrayLike, s: 'al' },
    { n: 'iterable', f: iterable, s: 'i' },
    { n: 'date', f: date, s: 'd' },
    { n: 'function', f: isFunction, s: 'f' },
    { n: 'hasLength', f: hasLength, s: 'l' },
  ].map(function (data) {
    messages[data.n] = 'Invalid ' + strings[data.s];
    predicates[data.n] = data.f;
  });

  functions = {
    apply: apply,
    map: map,
    all: all,
    any: any
  };

  collections = [ 'array', 'arrayLike', 'iterable', 'object' ];
  slice = Array.prototype.slice;

  functions = mixin(functions, predicates);
  assert = createModifiedPredicates(assertModifier, assertImpl);
  not = createModifiedPredicates(notModifier, notImpl);
  maybe = createModifiedPredicates(maybeModifier, maybeImpl);
  assert.not = createModifiedModifier(assertModifier, not);
  assert.maybe = createModifiedModifier(assertModifier, maybe);

  collections.forEach(createOfPredicates);
  createOfModifiers(assert, assertModifier);
  createOfModifiers(not, notModifier);
  collections.forEach(createMaybeOfModifiers);

  exportFunctions(mixin(functions, {
    assert: assert,
    not: not,
    maybe: maybe
  }));

  /**
   * Public function `equal`.
   *
   * Returns true if `lhs` and `rhs` are strictly equal, without coercion.
   * Returns false otherwise.
   */
  function equal (lhs, rhs) {
    return lhs === rhs;
  }

  /**
   * Public function `undefined`.
   *
   * Returns true if `data` is undefined, false otherwise.
   */
  function isUndefined (data) {
    return data === undefined;
  }

  /**
   * Public function `null`.
   *
   * Returns true if `data` is null, false otherwise.
   */
  function isNull (data) {
    return data === null;
  }

  /**
   * Public function `assigned`.
   *
   * Returns true if `data` is not null or undefined, false otherwise.
   */
  function assigned (data) {
    return ! isUndefined(data) && ! isNull(data);
  }

  /**
   * Public function `zero`.
   *
   * Returns true if `data` is zero, false otherwise.
   */
  function zero (data) {
    return data === 0;
  }

  /**
   * Public function `infinity`.
   *
   * Returns true if `data` is positive or negative infinity, false otherwise.
   */
  function infinity (data) {
    return data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY;
  }

  /**
   * Public function `number`.
   *
   * Returns true if `data` is a number, false otherwise.
   */
  function number (data) {
    return typeof data === 'number' &&
      isNaN(data) === false &&
      data !== Number.POSITIVE_INFINITY &&
      data !== Number.NEGATIVE_INFINITY;
  }

  /**
   * Public function `integer`.
   *
   * Returns true if `data` is an integer, false otherwise.
   */
  function integer (data) {
    return number(data) && data % 1 === 0;
  }

  /**
   * Public function `even`.
   *
   * Returns true if `data` is an even number, false otherwise.
   */
  function even (data) {
    return number(data) && data % 2 === 0;
  }

  /**
   * Public function `odd`.
   *
   * Returns true if `data` is an odd number, false otherwise.
   */
  function odd (data) {
    return integer(data) && !even(data);
  }

  /**
   * Public function `greater`.
   *
   * Returns true if `lhs` is a number greater than `rhs`, false otherwise.
   */
  function greater (lhs, rhs) {
    return number(lhs) && lhs > rhs;
  }

  /**
   * Public function `less`.
   *
   * Returns true if `lhs` is a number less than `rhs`, false otherwise.
   */
  function less (lhs, rhs) {
    return number(lhs) && lhs < rhs;
  }

  /**
   * Public function `between`.
   *
   * Returns true if `data` is a number between `x` and `y`, false otherwise.
   */
  function between (data, x, y) {
    if (x < y) {
      return greater(data, x) && less(data, y);
    }

    return less(data, x) && greater(data, y);
  }

  /**
   * Public function `greaterOrEqual`.
   *
   * Returns true if `lhs` is a number greater than or equal to `rhs`, false
   * otherwise.
   */
  function greaterOrEqual (lhs, rhs) {
    return number(lhs) && lhs >= rhs;
  }

  /**
   * Public function `lessOrEqual`.
   *
   * Returns true if `lhs` is a number less than or equal to `rhs`, false
   * otherwise.
   */
  function lessOrEqual (lhs, rhs) {
    return number(lhs) && lhs <= rhs;
  }

  /**
   * Public function `inRange`.
   *
   * Returns true if `data` is a number in the range `x..y`, false otherwise.
   */
  function inRange (data, x, y) {
    if (x < y) {
      return greaterOrEqual(data, x) && lessOrEqual(data, y);
    }

    return lessOrEqual(data, x) && greaterOrEqual(data, y);
  }

  /**
   * Public function `positive`.
   *
   * Returns true if `data` is a positive number, false otherwise.
   */
  function positive (data) {
    return greater(data, 0);
  }

  /**
   * Public function `negative`.
   *
   * Returns true if `data` is a negative number, false otherwise.
   */
  function negative (data) {
    return less(data, 0);
  }

  /**
   * Public function `string`.
   *
   * Returns true if `data` is a string, false otherwise.
   */
  function string (data) {
    return typeof data === 'string';
  }

  /**
   * Public function `emptyString`.
   *
   * Returns true if `data` is the empty string, false otherwise.
   */
  function emptyString (data) {
    return data === '';
  }

  /**
   * Public function `nonEmptyString`.
   *
   * Returns true if `data` is a non-empty string, false otherwise.
   */
  function nonEmptyString (data) {
    return string(data) && data !== '';
  }

  /**
   * Public function `contains`.
   *
   * Returns true if `data` is a string that contains `substring`, false
   * otherwise.
   */
  function contains (data, substring) {
    return string(data) && data.indexOf(substring) !== -1;
  }

  /**
   * Public function `match`.
   *
   * Returns true if `data` is a string that matches `regex`, false otherwise.
   */
  function match (data, regex) {
    return string(data) && !! data.match(regex);
  }

  /**
   * Public function `boolean`.
   *
   * Returns true if `data` is a boolean value, false otherwise.
   */
  function boolean (data) {
    return data === false || data === true;
  }

  /**
   * Public function `object`.
   *
   * Returns true if `data` is a plain-old JS object, false otherwise.
   */
  function object (data) {
    return Object.prototype.toString.call(data) === '[object Object]';
  }

  /**
   * Public function `emptyObject`.
   *
   * Returns true if `data` is an empty object, false otherwise.
   */
  function emptyObject (data) {
    return object(data) && Object.keys(data).length === 0;
  }

  /**
   * Public function `instanceStrict`.
   *
   * Returns true if `data` is an instance of `prototype`, false otherwise.
   */
  function instanceStrict (data, prototype) {
    try {
      return data instanceof prototype;
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `instance`.
   *
   * Returns true if `data` is an instance of `prototype`, false otherwise.
   * Falls back to testing constructor.name and Object.prototype.toString
   * if the initial instanceof test fails.
   */
  function instance (data, prototype) {
    try {
      return instanceStrict(data, prototype) ||
        data.constructor.name === prototype.name ||
        Object.prototype.toString.call(data) === '[object ' + prototype.name + ']';
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `like`.
   *
   * Tests whether `data` 'quacks like a duck'. Returns true if `data` has all
   * of the properties of `archetype` (the 'duck'), false otherwise.
   */
  function like (data, archetype) {
    var name;

    for (name in archetype) {
      if (archetype.hasOwnProperty(name)) {
        if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof archetype[name]) {
          return false;
        }

        if (object(data[name]) && like(data[name], archetype[name]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Public function `array`.
   *
   * Returns true if `data` is an array, false otherwise.
   */
  function array (data) {
    return Array.isArray(data);
  }

  /**
   * Public function `emptyArray`.
   *
   * Returns true if `data` is an empty array, false otherwise.
   */
  function emptyArray (data) {
    return array(data) && data.length === 0;
  }

  /**
   * Public function `arrayLike`.
   *
   * Returns true if `data` is an array-like object, false otherwise.
   */
  function arrayLike (data) {
    return assigned(data) && number(data.length);
  }

  /**
   * Public function `iterable`.
   *
   * Returns true if `data` is an iterable, false otherwise.
   */
  function iterable (data) {
    if (typeof Symbol === 'undefined') {
      // Fall back to `arrayLike` predicate in pre-ES6 environments.
      return arrayLike(data);
    }

    return assigned(data) && isFunction(data[Symbol.iterator]);
  }

  /**
   * Public function `includes`.
   *
   * Returns true if `data` contains `value`, false otherwise.
   */
  function includes (data, value) {
    var iterator, iteration;

    if (not.assigned(data)) {
      return false;
    }

    try {
      if (typeof Symbol !== 'undefined' && data[Symbol.iterator] && isFunction(data.values)) {
        iterator = data.values();

        do {
          iteration = iterator.next();

          if (iteration.value === value) {
            return true;
          }
        } while (! iteration.done);

        return false;
      }

      Object.keys(data).forEach(function (key) {
        if (data[key] === value) {
          throw 0;
        }
      });
    } catch (ignore) {
      return true;
    }

    return false;
  }

  /**
   * Public function `hasLength`.
   *
   * Returns true if `data` has a length property that equals `length`, false
   * otherwise.
   */
  function hasLength (data, length) {
    return assigned(data) && data.length === length;
  }

  /**
   * Public function `date`.
   *
   * Returns true if `data` is a valid date, false otherwise.
   */
  function date (data) {
    try {
      return instance(data, Date) && integer(data.getTime());
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `function`.
   *
   * Returns true if `data` is a function, false otherwise.
   */
  function isFunction (data) {
    return typeof data === 'function';
  }

  /**
   * Public function `apply`.
   *
   * Maps each value from the `data` to the corresponding predicate and returns
   * the result array. If the same function is to be applied across all of the
   * data, a single predicate function may be passed in.
   *
   */
  function apply (data, predicates) {
    assert.array(data);

    if (isFunction(predicates)) {
      return data.map(function (value) {
        return predicates(value);
      });
    }

    assert.array(predicates);
    assert.hasLength(data, predicates.length);

    return data.map(function (value, index) {
      return predicates[index](value);
    });
  }

  /**
   * Public function `map`.
   *
   * Maps each value from the `data` to the corresponding predicate and returns
   * the result object. Supports nested objects. If the `data` is not nested and
   * the same function is to be applied across all of it, a single predicate
   * function may be passed in.
   *
   */
  function map (data, predicates) {
    assert.object(data);

    if (isFunction(predicates)) {
      return mapSimple(data, predicates);
    }

    assert.object(predicates);

    return mapComplex(data, predicates);
  }

  function mapSimple (data, predicate) {
    var result = {};

    Object.keys(data).forEach(function (key) {
      result[key] = predicate(data[key]);
    });

    return result;
  }

  function mapComplex (data, predicates) {
    var result = {};

    Object.keys(predicates).forEach(function (key) {
      var predicate = predicates[key];

      if (isFunction(predicate)) {
        if (not.assigned(data)) {
          result[key] = !!predicate._isMaybefied;
        } else {
          result[key] = predicate(data[key]);
        }
      } else if (object(predicate)) {
        result[key] = mapComplex(data[key], predicate);
      }
    });

    return result;
  }

  /**
   * Public function `all`
   *
   * Check that all boolean values are true
   * in an array (returned from `apply`)
   * or object (returned from `map`).
   *
   */
  function all (data) {
    if (array(data)) {
      return testArray(data, false);
    }

    assert.object(data);

    return testObject(data, false);
  }

  function testArray (data, result) {
    var i;

    for (i = 0; i < data.length; i += 1) {
      if (data[i] === result) {
        return result;
      }
    }

    return !result;
  }

  function testObject (data, result) {
    var key, value;

    for (key in data) {
      if (data.hasOwnProperty(key)) {
        value = data[key];

        if (object(value) && testObject(value, result) === result) {
          return result;
        }

        if (value === result) {
          return result;
        }
      }
    }

    return !result;
  }

  /**
   * Public function `any`
   *
   * Check that at least one boolean value is true
   * in an array (returned from `apply`)
   * or object (returned from `map`).
   *
   */
  function any (data) {
    if (array(data)) {
      return testArray(data, true);
    }

    assert.object(data);

    return testObject(data, true);
  }

  function mixin (target, source) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });

    return target;
  }

  /**
   * Public modifier `assert`.
   *
   * Throws if `predicate` returns false.
   */
  function assertModifier (predicate, defaultMessage) {
    return function () {
      assertPredicate(predicate, arguments, defaultMessage);
    };
  }

  function assertPredicate (predicate, args, defaultMessage) {
    var message = args[args.length - 1];
    assertImpl(predicate.apply(null, args), nonEmptyString(message) ? message : defaultMessage);
  }

  function assertImpl (value, message) {
    if (value === false) {
      throw new Error(message || 'Assertion failed');
    }
  }

  /**
   * Public modifier `not`.
   *
   * Negates `predicate`.
   */
  function notModifier (predicate) {
    return function () {
      return notImpl(predicate.apply(null, arguments));
    };
  }

  function notImpl (value) {
    return !value;
  }

  /**
   * Public modifier `maybe`.
   *
   * Returns true if predicate argument is  null or undefined,
   * otherwise propagates the return value from `predicate`.
   */
  function maybeModifier (predicate) {
    var modifiedPredicate = function () {
      if (not.assigned(arguments[0])) {
        return true;
      }

      return predicate.apply(null, arguments);
    };

    // Hackishly indicate that this is a maybe.xxx predicate.
    // Without this flag, the alternative would be to iterate
    // through the maybe predicates or use indexOf to check,
    // which would be time-consuming.
    modifiedPredicate._isMaybefied = true;

    return modifiedPredicate;
  }

  function maybeImpl (value) {
    if (assigned(value) === false) {
      return true;
    }

    return value;
  }

  /**
   * Public modifier `of`.
   *
   * Applies the chained predicate to members of the collection.
   */
  function ofModifier (target, type, predicate) {
    return function () {
      var collection, args;

      collection = arguments[0];

      if (target === 'maybe' && not.assigned(collection)) {
        return true;
      }

      if (!type(collection)) {
        return false;
      }

      collection = coerceCollection(type, collection);
      args = slice.call(arguments, 1);

      try {
        collection.forEach(function (item) {
          if (
            (target !== 'maybe' || assigned(item)) &&
            !predicate.apply(null, [ item ].concat(args))
          ) {
            // TODO: Replace with for...of when ES6 is required.
            throw 0;
          }
        });
      } catch (ignore) {
        return false;
      }

      return true;
    };
  }

  function coerceCollection (type, collection) {
    switch (type) {
      case arrayLike:
        return slice.call(collection);
      case object:
        return Object.keys(collection).map(function (key) {
          return collection[key];
        });
      default:
        return collection;
    }
  }

  function createModifiedPredicates (modifier, object) {
    return createModifiedFunctions([ modifier, predicates, object ]);
  }

  function createModifiedFunctions (args) {
    var modifier, object, functions, result;

    modifier = args.shift();
    object = args.pop();
    functions = args.pop();

    result = object || {};

    Object.keys(functions).forEach(function (key) {
      Object.defineProperty(result, key, {
        configurable: false,
        enumerable: true,
        writable: false,
        value: modifier.apply(null, args.concat(functions[key], messages[key]))
      });
    });

    return result;
  }

  function createModifiedModifier (modifier, modified) {
    return createModifiedFunctions([ modifier, modified, null ]);
  }

  function createOfPredicates (key) {
    predicates[key].of = createModifiedFunctions(
      [ ofModifier.bind(null, null), predicates[key], predicates, null ]
    );
  }

  function createOfModifiers (base, modifier) {
    collections.forEach(function (key) {
      base[key].of = createModifiedModifier(modifier, predicates[key].of);
    });
  }

  function createMaybeOfModifiers (key) {
    maybe[key].of = createModifiedFunctions(
      [ ofModifier.bind(null, 'maybe'), predicates[key], predicates, null ]
    );
    assert.maybe[key].of = createModifiedModifier(assertModifier, maybe[key].of);
    assert.not[key].of = createModifiedModifier(assertModifier, not[key].of);
  }

  function exportFunctions (functions) {
    if (typeof define === 'function' && define.amd) {
      define(function () {
        return functions;
      });
    } else if (typeof module !== 'undefined' && module !== null && module.exports) {
      module.exports = functions;
    } else {
      globals.check = functions;
    }
  }
}(this));

},{}],7:[function(require,module,exports){
module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};
},{}],8:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');
var swizzle = require('simple-swizzle');

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-fA-F0-9]{3})$/;
	var hex = /^#([a-fA-F0-9]{6})$/;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;

	if (match = string.match(abbr)) {
		match = match[1];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}
	} else if (match = string.match(hex)) {
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	}

	for (i = 0; i < rgb.length; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}
};

cs.to.hex = function (rgb) {
	return '#' + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ')'
		: 'rgba(' + rgba[0] + ', ' + rgba[1] + ', ' + rgba[2] + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

},{"color-name":7,"simple-swizzle":101}],9:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":38}],10:[function(require,module,exports){
module.exports=[
	"xx-small",
	"x-small",
	"small",
	"medium",
	"large",
	"x-large",
	"xx-large",
	"larger",
	"smaller"
]

},{}],11:[function(require,module,exports){
module.exports=[
	"normal",
	"condensed",
	"semi-condensed",
	"extra-condensed",
	"ultra-condensed",
	"expanded",
	"semi-expanded",
	"extra-expanded",
	"ultra-expanded"
]

},{}],12:[function(require,module,exports){
module.exports=[
	"normal",
	"italic",
	"oblique"
]

},{}],13:[function(require,module,exports){
module.exports=[
	"normal",
	"bold",
	"bolder",
	"lighter",
	"100",
	"200",
	"300",
	"400",
	"500",
	"600",
	"700",
	"800",
	"900"
]

},{}],14:[function(require,module,exports){
module.exports=[
	"inherit",
	"initial",
	"unset"
]

},{}],15:[function(require,module,exports){
var t = require('tcomb');

var Options = t.struct({
	last: t.maybe(t.Boolean)
});

var helpers = {

	split: function(value, separators, options) {
		return split(value, separators, options || {});
	},

	splitBySpaces: t.func(t.String, t.Array).of(
		function(value) {
			var spaces = [' ', '\n', '\t'];
			return helpers.split(value, spaces);
		}
	),

	splitByCommas: t.func(t.String, t.Array).of(
		function(value) {
			var comma = ',';
			return helpers.split(value, [comma], { last: true });
		}
	)

};

var split = t.func([t.String, t.Array, Options], t.Array).of(
	function(value, separators, options) {
		var array   = [];
		var current = '';
		var split   = false;

		var func    = 0;
		var quote   = false;
		var escape  = false;

		for (var i = 0; i < value.length; i++) {
			var char = value[i];

			if (quote) {
				if (escape) {
					escape = false;
				} else if (char === '\\') {
					escape = true;
				} else if (char === quote) {
					quote = false;
				}
			} else if (char === '"' || char === '\'') {
				quote = char;
			} else if (char === '(') {
				func += 1;
			} else if (char === ')') {
				if (func > 0) {
					func -= 1;
				}
			} else if (func === 0) {
				if (separators.indexOf(char) !== -1) {
					split = true;
				}
			}

			if (split) {
				if (current !== '') {
					array.push(current.trim());
				}
				current = '';
				split = false;
			} else {
				current += char;
			}
		}

		if (options.last || current !== '') {
			array.push(current.trim());
		}
		return array;
	}
);

module.exports = helpers;

},{"tcomb":112}],16:[function(require,module,exports){
module.exports=[
	"caption",
	"icon",
	"menu",
	"message-box",
	"small-caption",
	"status-bar"
]

},{}],17:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":18,"./lib/keys.js":19}],18:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],19:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],20:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var foreach = require('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":30,"object-keys":80}],21:[function(require,module,exports){
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],22:[function(require,module,exports){
'use strict';

var $isNaN = require('./helpers/isNaN');
var $isFinite = require('./helpers/isFinite');

var sign = require('./helpers/sign');
var mod = require('./helpers/mod');

var IsCallable = require('is-callable');
var toPrimitive = require('es-to-primitive/es5');

// https://es5.github.io/#x9
var ES5 = {
	ToPrimitive: toPrimitive,

	ToBoolean: function ToBoolean(value) {
		return Boolean(value);
	},
	ToNumber: function ToNumber(value) {
		return Number(value);
	},
	ToInteger: function ToInteger(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number)) { return 0; }
		if (number === 0 || !$isFinite(number)) { return number; }
		return sign(number) * Math.floor(Math.abs(number));
	},
	ToInt32: function ToInt32(x) {
		return this.ToNumber(x) >> 0;
	},
	ToUint32: function ToUint32(x) {
		return this.ToNumber(x) >>> 0;
	},
	ToUint16: function ToUint16(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x10000);
	},
	ToString: function ToString(value) {
		return String(value);
	},
	ToObject: function ToObject(value) {
		this.CheckObjectCoercible(value);
		return Object(value);
	},
	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
		/* jshint eqnull:true */
		if (value == null) {
			throw new TypeError(optMessage || 'Cannot call method on ' + value);
		}
		return value;
	},
	IsCallable: IsCallable,
	SameValue: function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
		return $isNaN(x) && $isNaN(y);
	}
};

module.exports = ES5;

},{"./helpers/isFinite":23,"./helpers/isNaN":24,"./helpers/mod":25,"./helpers/sign":26,"es-to-primitive/es5":27,"is-callable":39}],23:[function(require,module,exports){
var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

},{}],24:[function(require,module,exports){
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};

},{}],25:[function(require,module,exports){
module.exports = function mod(number, modulo) {
	var remain = number % modulo;
	return Math.floor(remain >= 0 ? remain : remain + modulo);
};

},{}],26:[function(require,module,exports){
module.exports = function sign(number) {
	return number >= 0 ? 1 : -1;
};

},{}],27:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

var isPrimitive = require('./helpers/isPrimitive');

var isCallable = require('is-callable');

// https://es5.github.io/#x8.12
var ES5internalSlots = {
	'[[DefaultValue]]': function (O, hint) {
		var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// https://es5.github.io/#x9
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
};

},{"./helpers/isPrimitive":28,"is-callable":39}],28:[function(require,module,exports){
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],30:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],31:[function(require,module,exports){
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],32:[function(require,module,exports){
var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":31}],33:[function(require,module,exports){
var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":32}],34:[function(require,module,exports){
'use strict';
module.exports = function (hex) {
	if (typeof hex !== 'string') {
		throw new TypeError('Expected a string');
	}

	hex = hex.replace(/^#/, '');

	if (hex.length === 3) {
		hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
	}

	var num = parseInt(hex, 16);

	return [num >> 16, num >> 8 & 255, num & 255];
};

},{}],35:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],36:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],37:[function(require,module,exports){
'use strict';

module.exports = function isArrayish(obj) {
	if (!obj) {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

},{}],38:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],39:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class /;
var isES6ClassFn = function isES6ClassFn(value) {
	try {
		var fnStr = fnToStr.call(value);
		var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
		var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
		var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
		return constructorRegex.test(spaceStripped);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionObject(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],40:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],41:[function(require,module,exports){
module.exports = array_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function array_UI(options) {
	if (!(this instanceof array_UI)) return new array_UI(options);
	
	//requires primitives.lib and primitives.createjs
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._lib = primitives.get('lib');
	if (check.undefined(this._lib) || check.not.object(this._lib)) {
		throw new ReferenceError("'lib' undefined or not object in primitives object.");
	}
	
	//requires argument length, how big to make the array (should be integer > 0)
	if (check.undefined(options) || check.undefined(options.length) || check.not.integer(options.length) || options.length <= 0) {
		throw new TypeError("Require argument object with property 'length'. 'length' should be an integer > 0.");
	}
	
	//TODO: remove containers and just make container of ArrayElements
	//create an array of containers containing ArrayElements, we'll place the Text objects in the inner containers later when we assign a value to an index
	this._array = this._make_array(options.length);
	
	//decorate the inner containers with coordinates to place UI elements below / on the arrayElements in the array
	this._array = this._decorate_coordinates(this._array);
	
	//decorate outer container with an array that will map to the values contained in the array holding the UI elements
	//	when they're added with the methods added below
	this._array = this._decorate_value_array(this._array);
	
	//get the arrow associated with the array, points at the first elements in the array
	//	the arrow implements the iterator protocol and is assigned a next() function that will traverse the array,
	//	returning values in the array as well as move()ing the UI arrow to the next position in the array
	this._arrow = this._setup_tail_arrow(this._array);
	
	//decorate outer container with convenience methods that:
	//	handle adding values to the array
	//		this methods handles the UI aspects of adding value (move()) and the logical aspect (updating the internal logical / UI containers with the values added)
	this._array = this._decorate_method_push(this._array, this._arrow);
	
	return {array: this._array, arrow: this._arrow};
}

array_UI.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//creates an array of ArrayElement's, with maximum size length
	//each child in the array is a container containing an ArrayElement, when we're adding values, the values are added to they're associated container
	//each child is decorated with a _ namespace that is used later to add functionality
	//each child is decorated with a _.index property that matches its index in the array
	//the Container containing the the children is decorated with a _ namespace, to add functionality
	//the Container containing the the children is decorated with a _.length property to indicate its maximum size
	_make_array : function(length) {
		var offsetX = 0;
		var outer_container = new this._createjs.Container();
		
		for (var i = 0; i < length; i++) {
			//create the array element in a container, so 
			var arrayElement = new this._lib.ArrayElement();
			var inner_container = new this._createjs.Container();
			inner_container.addChild(arrayElement);
			
			//offset each subcontainer by the size of the array element box
			inner_container.x = offsetX;
			
			//create a new namespace to decorate into
			inner_container._ = {};
			
			//BUG:
			//for some reason the width as returned by getBounds() is about half of the ArrayElement length as shown on the canvas
			//	using 50px as workaround
			//offsetX += arrayElement.getBounds().width;
			offsetX += 50;
			
			//setting associated index (displays below ArrayElement figure, configured by AA)
			arrayElement.index_txt.text = String(i);
			inner_container._.index = i;	//setting index for iteration by the tail arrow
			
			outer_container.addChild(inner_container);
		}
		
		//set bounds on the array, for using place() later
		//NOTE: having to guess at the height of the container, as arrayElement's don't have correct bounds
		outer_container.setBounds(0, 0, offsetX, 50 + 20);
		
		//create a namespace to decorate into
		outer_container._ = {};
		
		//add a length property, to show the maximum size of the array
		outer_container._.length = length;
		
		return outer_container;
	},
	
	//TODO: modify these to be local to the array, since we just use globalToLocal() to keep track of the position of the children with respect to the container
	//decorates the child containers of each child in an array with functions that return global (x, y) coordinates for positions near each child ArrayElement object
	//coordinates are compatible with the move() library, that will allow tweening of stage object to points near the ArrayElement objects
	_decorate_coordinates : function(array) {
		for (var i = 0; i < array.children.length; i++) {
			var arrayElement = array.children[i];
			
			//create functions in the _ namespace for each type of move we need
			//call a function (with the current child index) that returns a function of that child and its parent coordinates
			//	this allows updating of the position of the coordinates as the parent container moves or is placed in a different location
			//	via the magic of closures
			arrayElement._.below = (function(j) {
				return function() {
					return {x:array.x + array.children[j].x + 22, y:array.y + 70};
				}
			})(i);
			
			arrayElement._.on = (function(j) {
				return function() {
					return {x:array.x + array.children[j].x + 9, y:array.y + 15};
				}
			})(i);
		}
		
		return array;
	},
	
	//decorates a values array onto the array Container, that is meant to contain the numeric values added to the array
	_decorate_value_array : function(array) {
		array._.values = [];
		return array;
	},
	
	//add an arrow pointing at the 0th position of the array, labeled "tail"
	//the tail acts as a UI element and iterator, such that it will logically traverse the values array (above)
	//as well as move() itself on the stage when its next() function is called
	//the arrow is added as a child of the array Container to allow for relative positioning, this is NOT traversed to on a call to next()
	//	as next() tracks indices according to the size of the array NOT using the size of the array.children array as its guide to how many children there are
	_setup_tail_arrow : function(array) {
		var arrow_UI = require('lib/UI/arrow_UI');
		
		//NOTE:
		//`this`, in a next function refers to the arrow object
		/* as such it has properties in this configuration:
		{
			move: move
			name: "tail",
			pointed_at: <some UI object>,
			next : <the next() function (assigned below)>
			}
		so addressing said properties is not done via the _ namespace, but rather directly on the `this` object itself */
		function tail_arrow_next() {
			if (this.pointed_at._.index + 1 >= array._.length) {
				//going to be out of bounds case
				return {done : true};
			} else {
				//increment to the next child, return its value and done === false
				//	move() arrow below next child
				var new_index = this.pointed_at._.index + 1;
				this.pointed_at = array.children[new_index];
				
				//translate the global position below() to local with respect to the array, then move() to it
				var next_point_below = array.globalToLocal(array.children[new_index]._.below().x, array.children[new_index]._.below().y);
				this.move.to(next_point_below);
				
				//value is always undefined, as we use the arrow to point to indices in the array which have no content (as it's the tail arrow)
				return {value : undefined, done : false};
			}
		};
		
		var args = {
			name: "tail",
			//place the arrow initially under the 0th child, as there are not values in the array yet
			position: array.children[0]._.below(),
			//arrow is pointing at the 0th child
			pointed_at: array.children[0],
			//define how to iterate the arrow
			next: tail_arrow_next,
		};
		
		//add the arrow to the array to do relative positioning inside the array container
		var arrow = arrow_UI(args);
		array.addChild(arrow);
		
		return arrow;
	},
	
	//add a method to push values onto the array
	//takes a createjs Text object, whose value is a number
	//tweens the Text object to the first available position in the UI array
	//	the index where the tail arrow is currently pointing, before move()d to the next position in the array
	//adds the value in the Text object to the "values" array (decorated in the _ namespace, above)
	//returns an error if the array is full
	_decorate_method_push : function(array, arrow) {
		array._.push = function(value) {
			//value should be a createjs.Text object, whose text value is a number
			if(check.not.instanceStrict(value, createjs.Text) || check.not.number(Number(value.text))) {
				throw new TypeError("Requires a createjs.Text object whose value is a number.");
			}
			
			//error if array is full
			if (array._.values.length === array._.length) {
				throw new RangeError("Array is full, cannot push() new value.");
			}
			
			//get the index where we can insert (from arrow)
			var insertion_index = arrow._.pointed_at._.index;
			
			//move() value to that index
			var move = require('lib/util/move');
			var value_move = move(value);
			
			//store the intial point (from the global stage)
			var global_initial_point = {x: value.x, y: value.y};
			
			//add the value to the array as a child of the container at the insertion_index
			array.children[insertion_index].addChild(value);
			
			//translate the initial point of the value, to the local coordinate space of the array
			var local_initial_point = array.globalToLocal(value.x, value.y);
			value.x = local_initial_point.x;
			value.y = local_initial_point.y;
			
			//then move from that point, to the point on the array (on() returns the global position)
			//	where globalToLocal() translates the global point from on() to the local coordinate system with respect to the array container
			//	and globalToLocal() returns a point object {x, y} as move() expects
			
			//NOTE:
			//we add the value to the container at the index we want to insert to
			//since this makes the value part of a SUB-CONTAINER (inside the array container)
			//it has ITS OWN coordinate system, separate from the array or the stage at large
			//so we need to use globalToLocal() ON THAT CHILD CONTAINER to get correct positioning, instead of on the array
			//then as on() returns global coords we can feed it to globalToLocal() to get the correct positioning
			value_move.to(
				array.children[insertion_index].globalToLocal(array.children[insertion_index]._.on().x, array.children[insertion_index]._.on().y)
			);
			
			//add Number(value.text) to values array
			array._.values.push(Number(value.text));
			
			//return the new length of the array, as per Array.prototype.push()
			return array._.values.length;
		};
		
		return array;
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_lib : undefined,			//holds a reference to the lib object, created by AA and used to access objects created by AA
	_array : undefined,			//internal reference to the array created
	_arrow : undefined,			//internal reference to the associated arrow to the array
};
},{"check-types":6,"lib/UI/arrow_UI":42,"lib/util/move":71,"lib/util/primitives":73}],42:[function(require,module,exports){
module.exports = arrow_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function arrow_UI(options) {
	if (!(this instanceof arrow_UI)) return new arrow_UI(options);
	
	//requires primitives.createjs
	//TODO: will need primitives.lib once we're done using mock arrow
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	if (check.undefined(options)) {
		throw new TypeError("Require argument object.");
	}
	
	//required argument: name (makes a createjs.Text object associated with the arrow)
	if (check.undefined(options.name) || check.not.string(options.name)) {
		throw new TypeError("Require argument object with property 'name', should be String.");
	}
	
	//required argument: position (object with x and y properties, that are both numeric)
	//	where to initially position the arrow on the stage
	if (check.undefined(options.position) || check.not.object(options.position) || check.not.number(options.position.x) || check.not.number(options.position.y)) {
		throw new TypeError("Require argument object with property 'position', should be Object with numeric properties x and y.");
	}
	
	//required argument: pointed_at (object)
	//	a reference to the UI object that the arrow is pointed at
	if (check.undefined(options.pointed_at) || check.not.object(options.pointed_at)) {
		throw new TypeError("Require argument object with property 'pointed_at', should be Object.");
	}
	
	//required argument: next (function)
	//	manipulates the arrow as it iterates (moves around the stage, updates its internal variables, etc)
	if (check.undefined(options.next) || check.not.function(options.next)) {
		throw new TypeError("Require argument object with property 'next', should be function.");
	}
	
	this._arrow = this._make_arrow(options.name);
	
	this._arrow = this._decorate(this._arrow, options);
	
	return this._arrow;
};

arrow_UI.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	_make_arrow : function(name) {
		var arrow_factory = require('lib/factory/arrow_factory');
		var af = arrow_factory();
		af.arrow({direction: "up"});
		
		var arrow = af.get();
		
		var c = new this._createjs.Container();
		c.addChild(arrow);
		
		//append the name to the arrow and decorate onto the arrow for reference
		var text_factory = require('lib/factory/text_factory');
		var tf = text_factory();
		tf.text({text:name});
		var label = tf.get();
		
		//lifted from 'lib/util/place', below()
		label.x = arrow.x - label.getBounds().x;
		label.y = arrow.y + arrow.getBounds().height - label.getBounds().y;
		
		//slight correction: down and to the left, to be centered under the arrow
		label.y += 5;
		label.x += -10;
		
		c.addChild(label);
		
		return c;
	},
	
	_decorate : function(arrow, options) {
		//setup namespace to decorate into
		arrow._ = {};
		
		//decorate with the name of the arrow
		arrow._.name = options.name;
		
		//position the arrow
		arrow.x = options.position.x
		arrow.y = options.position.y
		
		//store the reference of the object the arrow is pointed at
		arrow._.pointed_at = options.pointed_at
		
		//add the next function
		arrow._.next = options.next;
		
		//add move() functionality
		var move = require('lib/util/move');
		arrow._.move = move(arrow);
		
		return arrow;
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_arrow : undefined,			//internal reference to the arrow created
};
},{"check-types":6,"lib/factory/arrow_factory":44,"lib/factory/text_factory":47,"lib/util/move":71,"lib/util/primitives":73}],43:[function(require,module,exports){
module.exports = lesson_UI;

var check = require('check-types');
var primitives = require("lib/util/primitives");

function lesson_UI(options) {
	if (!(this instanceof lesson_UI)) return new lesson_UI(options);
	
	//if we don't have a stage, createjs or lib object, can't continue, error
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._stage = primitives.get('stage');
	if (check.undefined(this._stage) || check.not.object(this._stage)) {
		throw new ReferenceError("'stage' undefined or not object in primitives object.");
	}
	
	this._lib = primitives.get('lib');
	if (check.undefined(this._lib) || check.not.object(this._lib)) {
		throw new ReferenceError("'lib' undefined or not object in primitives object.");
	}
	
	//TODO: singleton
	
	this._state = this._INIT;
	
	//setup UI elements
	this._setup_title_screen();
	this._setup_start_button();
	this._setup_array_screen();
	this._setup_array();
	
	this._state = this._PRE_LESSON;
	
	//play the initial title screen animation
	this._title_screen.gotoAndPlay("open");
};

lesson_UI.prototype = {
	_setup_title_screen : function() {
		this._title_screen = new this._lib.TitleScreen();
		this._title_screen.x = 192;
		this._title_screen.y = 256;
		
		this._stage.addChild(this._title_screen);	//add the title screen to the stage
	},
	
	_setup_start_button : function() {
		//insert_btn is automatically populated inside the title screen object by AA
		this._start_button = this._title_screen.insert_btn;
		
		//on button press for the insert button
		//next() to transition to the next state and play the close animation on the title screen
		var instance = this;
		this._start_button.addEventListener("click", function() {
			instance.next();
		});
	},
	
	_setup_array_screen : function() {
		this._array_screen = new this._lib.ArrayScreen();	//setup by AA
		this._array_screen.x = 0;
		this._array_screen.y = 0;
	},
	
	_setup_array : function() {
		var size = 5;
		var array_UI = require('lib/UI/array_UI');
		var result = array_UI({length:size});
		
		this._array = result.array;
		this._tail_arrow = result.arrow;
		
		//TODO: allow config of positioning
		//positioning array
		this._array.x = 100;
		this._array.y = 200;
		
		/* //positioning tail arrow
		this._tail_arrow.x += this._array.x;
		this._tail_arrow.y += this._array.y; */
	},
	
	//add a text input to the array_screen to capture user input
	_setup_text_input : function() {
		//get the text input
		var html_factory = require('lib/factory/html_factory');
		var hf = html_factory();
		hf.html({type:'text'});
		this._text_input = hf.get();
		
		//get the canvas_container div to attach to
		var canvas_container = document.getElementById('canvas_container');
		
		//position the text input
		this._text_input.x = 100;
		this._text_input.y = 100;
		
		var instance = this;
		//decorate method to get value of text input
		this._text_input._.get = function() {
			//no matter what is entered the "value" property is always a string
			//emtpy string case / no input, Number returns 0 for this?
			if (instance._text_input.children[0].htmlElement.value.length === 0) {
				return Number.NaN;
			}
			
			//despite the docs, this is a static method, so allocating it as per the docs (new Number), results in NaN on non-number input being wrapped in an object in a non-standard way that is undetectable by:
			//Number.Nan, equality checking with NaN, Number.isNaN() and typeof
			return Number(instance._text_input.children[0].htmlElement.value);
		};
		
		//...and a method to set the value
		this._text_input._.set = function(value) {
			instance._text_input.children[0].htmlElement.value = String(value);
		};
		
		//...and a convenience method to clear the text input
		this._text_input._.clear = function() {
			instance._text_input.children[0].htmlElement.value = "";
		};
		
		//make text_input a child of the canvas_container
		this._text_input._.append_to(canvas_container);
		
		//add it as a child of the array_screen
		this._array_screen.addChild(this._text_input);
	},
	
	//add a button "insert" to the array screen to control the lesson
	_setup_insert_button : function() {
		var shape_factory = require('lib/factory/shape_factory');
		var sf = shape_factory();
		sf.color({color:'red'});
		sf.text({text:"Insert"});
		sf.shape({type:"box"});
		
		this._insert_button = sf.get();
		
		//position next to the text input
		this._insert_button.x = 300;
		this._insert_button.y = 100;
		
		//adding pub/sub to event listener, so we can subscribe to click events later
		var pub_sub = require('pubsub-js');
		
		//add an event handler to the shape to listen for clicks
		this._insert_button.children[0].addEventListener("click", function() {
			pub_sub.publish("click.insert_button");
		});
		
		//decorate pub_sub on the object
		this._insert_button._.pub_sub = pub_sub;
		
		//add it as a child of the array_screen to appear when the array screen is added to the stage
		this._array_screen.addChild(this._insert_button);
	},
	
	//add a button "next" to the array screen to control stepping through the lesson
	_setup_next_button : function() {
		var shape_factory = require('lib/factory/shape_factory');
		var sf = shape_factory();
		sf.color({color:'green'});
		sf.text({text:"Next"});
		sf.shape({type:"box"});
		
		this._next_button = sf.get();
		
		//position at the bottom of the screen
		this._next_button.x = 200;
		this._next_button.y = 400;
		
		//adding pub/sub to event listener, so we can subscribe to click events later
		var pub_sub = require('pubsub-js');
		
		//add an event handler to the shape to listen for clicks
		this._next_button.children[0].addEventListener("click", function() {
			pub_sub.publish("click.next_button");
		});
		
		//decorate pub_sub on the object
		this._next_button._.pub_sub = pub_sub;
		
		//add it as a child of the array_screen to appear when the array screen is added to the stage
		this._array_screen.addChild(this._next_button);
	},
	
	//setup the text output and expose a control object with conenience methods
	_setup_text_output : function() {
		var text_factory = require('lib/factory/text_factory');
		var tf = text_factory();
		tf.text({text:""});	//set blank initially
		var output = tf.get();
		
		//decorate with convenience methods
		function get() {
			return output.text;
		}
		
		function set(value) {
			output.text = String(value);
		}
		
		function clear() {
			output.text = "";
		}
		
		this._text_output = output;
		this._text_output._.set = set;
		this._text_output._.get = get;
		this._text_output._.clear = clear;
		
		//position the text at the bottom of the screen, just below the next button
		//lifted from 'lib/util/place', below()
		this._text_output.x = 100;	//aligned with the array and the text input
		this._text_output.y = this._next_button.y + this._next_button.getBounds().height;
		
		this._array_screen.addChild(this._text_output);
	},
	
	//public
	//proceed through the states of the lesson
	next : function() {
		if (this._state === this._INIT) return;	//do nothing if in the INIT state
		
		//handling for title screen, before the lesson UI is displayed
		//	called from click of the "insert" button on the title screen
		if (this._state === this._PRE_LESSON) {
			//set the state into lesson to allow the transition to the lesson logic
			this._state = this._LESSON;
			
			//TODO: add code here to delete title screen object from the stage and the reference here, to free memory
			this._title_screen.gotoAndPlay("close");
			
			this.next();
			
			return;
		}
		
		//handling for lesson screen, after pre-lesson has ended
		//	called by the PRE_LESSON handler on title screen close
		if (this._state === this._LESSON) {
			this._array_screen.gotoAndPlay("open");	//do the opening animation for the array screen
			//TODO: rework these _setup function to allow adding them to the _array_screen in this block, rather than in their own methods
			//	ending with adding the _array_screen to the _stage
			
			//add the generated array to the screen
			this._array_screen.addChild(this._array);
			
			//add the array screen to the stage to draw it and all of its children
			this._stage.addChild(this._array_screen);
			
			//add the text input HTML to the array screen
			//	cannot add earlier as appears over canvas even though not added to stage
			this._setup_text_input();
			
			//add an insert button next to the text input to control the start of the lesson
			this._setup_insert_button();
			
			//add a next button at the bottom of the lesson
			this._setup_next_button();
			
			//setup a createjs.Text object at the bottom of the screen to give the user instruction
			this._setup_text_output();
			
			//TEST
			/* this._text_input._.set(2);
			var result = this._text_input_to_canvas();
			console.log(result); */
			
			return;
		}
	},
	
	//public
	//return a proxy object that allows control of the UI by the lesson code
	get_proxy : function() {
		if (this._state !== this._LESSON) return undefined;
		
		return {
			input : {
				get : this._text_input._.get,
				set : this._text_input._.set,
				clear : this._text_input._.clear,
				get_canvas_element : this._text_input_to_canvas,
			},
			output : {
				get : this._text_output._.get,
				set : this._text_output._.set,
				clear : this._text_output._.clear,
			},
			insert_button : this._insert_button,
			next_button : this._next_button,
			array : {
				working : this._array,
			},
			arrow : {
				working : this._tail_arrow,
			},
		};
	},
	
	//private
	//method to create a createjs.Text object to tween on the canvas, that visually appears near the text input
	//	visualizes inputing information from the text input into the UI array
	_text_input_to_canvas : function() {
		if (this._state !== this._LESSON) return;
		
		input = this._text_input._.get();
		if (Number.isNaN(input)) return;
		
		var text_factory = require('lib/factory/text_factory');
		var tf = text_factory();
		tf.text({text:input});
		var ret = tf.get();
		
		//position near text input, to be ready for tweening
		//	the text input overlays any canvas element, so make the input appear just below the text input
		ret.x = this._text_input.x;
		ret.y = this._text_input.y + 20;
		
		//clear the text input
		this._text_input._.clear();
		
		//add the Text object to the stage
		ret._.add_to_stage();
		
		//return the text object so it can be tweened by the caller
		return ret;
	},
	
	//internal variables
	_stage : undefined,			//holds a reference to the createjs stage (of type lib.unorderedArray, created in AA)
	_createjs : undefined,		//holds a reference to the local createjs instance, avoiding the global
	_lib : undefined,			//holds a reference to the lib object, created by AA and used to access objects created by AA
	_title_screen : undefined,	//reference to an object of type TitleScreen (created in AA)
	_start_button : undefined,	//reference to the insert button object (AA)
	_array_screen : undefined,	//reference to the array screen object (AA)
	_array : undefined,			//reference to the array created for the array screen
	_text_input : undefined,	//reference to the text input created, that's attached to the array screen
	_insert_button : undefined,	//reference to the insert button, used in the lesson, to start the lesson
	_next_button : undefined,	//reference to the next button, used in lesson, to continue the lesson once started
	_tail_arrow : undefined,	//reference to the arrow pointing at the "tail" position of the current working array
	
	//state tracking variables
	_state : undefined,
	_INIT : 0,
	_PRE_LESSON : 1,
	_LESSON : 2,
};
},{"check-types":6,"lib/UI/array_UI":41,"lib/factory/html_factory":45,"lib/factory/shape_factory":46,"lib/factory/text_factory":47,"lib/util/primitives":73,"pubsub-js":87}],44:[function(require,module,exports){
//used to construct UI arrow (three strokes, forming a <- pattern)
//defaults from LaFore: 20px long, 12px wide, red, poiting to the left
//	the vertical distance along the arrow body that the arrowhead extends, is also 6px

var check = require('check-types');
var argument_check = require("lib/util/argument_check");
var type_of = require('lib/util/type_of');
var primitives = require("lib/util/primitives");

module.exports = arrow_factory;

function arrow_factory(options) {
	if (!(this instanceof arrow_factory)) return new arrow_factory(options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
		
	//angle is counted as rotating to the RIGHT for positive values (counterintuitively)
	//so a left facing arrow has an angle value of -180 degrees
	//the below code will build an arrow that faces to the left by default, so initial angle is zero
	this._arrow_options = {length: 20, width: 12, color: 'red', angle: 0};
	
	this._container_options = {x:0, y:0};
	
	this._default_directions = {'left':0, 'right':-180, 'up':-270, 'down':-90};
}

arrow_factory.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//sets up a new arrow, with optional argument: length, width, color, angle and direction
	//	where direction is a convenience alias for angle and accepts: 'left', 'right', 'up' and 'down'
	//	angle is internally translated from standard standard left hand rotation (e.g. 90 degrees points up as normal, instead of down as per the canvas)
	arrow : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object or undefined.");
		}
		
		//validated options: type, id
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//check arguments unique to arrow construction
		//validated options: angle, length, direction
		if(!(check.number(validated_options.angle) || check.undefined(validated_options.angle))) {
			throw new TypeError("Variable: " + "angle" + " was " + type_of(validated_options.angle) + ", should be: " + "number");
		}
		if(!(check.number(validated_options.length) || check.undefined(validated_options.length))) {
			throw new TypeError("Variable: " + "length" + " was " + type_of(validated_options.length) + ", should be: " + "number");
		} else {
			if (check.number(validated_options.length) && validated_options.length <= 0) {
				throw new TypeError("Variable: " + "length" + " was " + validated_options.length + ", should be greater than zero.");
			}
		}
		if(!(check.string(validated_options.direction) || check.undefined(validated_options.direction))) {
			throw new TypeError("Variable: " + "direction" + " was " + type_of(validated_options.direction) + ", should be: " + "string");
		} else {
			if (check.string(validated_options.direction) && !(validated_options.direction in this._default_directions)) {
				throw new TypeError("Variable: " + "direction" + " was " + validated_options.direction + ", should be: " 
				+ "one of these: " + "'left', 'right', 'up' or 'down'");
			}
		}
		
		//it's an error to have both angle and direction passed
		if (check.number(validated_options.angle) && check.string(validated_options.direction)) {
			throw new Error('Cannot have options "angle" and "direction" defined at the same time.');
		}
		
		//translate normal angle notation to special angle notation used by canvas
		if (check.number(validated_options.angle)) {
			validated_options.angle = -validated_options.angle;
		}
		
		//if direction is set, then translate that into an angle and unset direction before setting options on _arrow_options
		if(check.string(validated_options.direction)) {
			validated_options.angle = this._default_directions[validated_options.direction];
			delete validated_options.direction;
		}
		
		//copy settings for arrow creation on get()
		for (option in validated_options) {
			this._arrow_options[option] = validated_options[option];
		}
	},
	
	//return a createjs Shape of the tip of the arrow
	_get_tip : function() {
		var tip = new this._createjs.Shape();
		
		//start drawing at the top, then move to the very end of the tip, then to the bottom
		//creating an open ended triangle whose base is twice as long as it is tall
		tip.graphics.beginStroke(this._arrow_options.color)
			.moveTo((this._arrow_options.width/2), -(this._arrow_options.width/2))
			.lineTo(0, 0)
			.lineTo((this._arrow_options.width/2), (this._arrow_options.width/2));
			
		return tip;
	},
	
	//return a createjs Shape of the line composing the rest of the arrow
	_get_line : function() {
		var line = new this._createjs.Shape();
		
		//start at the tip of the arrow (0, 0) and create a line that is as long as the length property
		line.graphics.setStrokeStyle(1)
			.beginStroke(this._arrow_options.color).moveTo(0, 0).lineTo(this._arrow_options.length, 0);
			
		return line;
	},
	
	//return a createjs Container, containing the tip and line, forming the arrow
	_bundle : function(tip, line) {
		var container = new this._createjs.Container();
		container.addChild(tip);
		container.addChild(line);
		return container;
	},
	
	_decorate : function(container) {
		container._ = {};
		
		//apply bounds of the arrow
		container.setBounds(0, 0, this._arrow_options.length, this._arrow_options.width);
		
		//add placing functionality to container
		var place = require('lib/util/place');
		container._.place = place(container);
		
		//add add_to_stage functionality
		var add_to_stage = require('lib/util/add_to_stage');
		container._.add_to_stage = add_to_stage(container);
		
		return container;
	},
	
	//set user options (positioning) as passed to get(), then apply angle of rotation to the container
	_set_props : function(container, options) {
		//copy settings for arrow creation on get()
		for (option in options) {
			this._container_options[option] = options[option];
		}
		
		//copy container options to container for return
		for (option in this._container_options) {
			container[option] = this._container_options[option];
		}
		
		//apply the angle of rotation to the arrow
		container.rotation = this._arrow_options.angle;
		
		return container;
	},
	
	//takes positioning (and other) options on the container
	get : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated options: x, y
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		var tip = this._get_tip();
		var line = this._get_line();
		var container = this._bundle(tip, line);
		container = this._decorate(container);
		return this._set_props(container, validated_options);
	},
	
	//TODO
	//takes two points, resturns an arrow whose origin is origin and whose terminal point (which point it points at) is terminal
	//	points are of the form: [x, y] (where x and y are numbers)
	/* get_arrow_between : function(origin, terminal) {
		if (!(
			check.array(origin) && 
			check.array(terminal) && 
			check.number(origin[0]) && 
			check.number(origin[1]) && 
			check.number(terminal[0]) && 
			check.number(terminal[1])
			)
			) {
			throw new TypeError("Incorrect argument type, should be array: [x, y] (where x and y are numbers)");
		}
		
		//calculate distance between the points
		var distance = require('euclidean-distance');
		var l = distance(origin, terminal);
		
		//then update the arrow, so that it is that length
		this.arrow({length:l});
		
		//calculate the angle needed to have the tip of the arrow rest on the terminal, given that the initial point is at origin
		
		//get an arrow, such that it's initial point is set at origin
		var a = this.get({x:origin[0], y:origin[1]});
		
		
	}, */
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_arrow_options : {},			//holds options for arrows
	_default_directions : {},		//default direction strings that an arrow accepts mapping to angle values
	_container_options : {},		//options applied to the container, used for positiong of the figure, etc
};
},{"check-types":6,"lib/util/add_to_stage":68,"lib/util/argument_check":70,"lib/util/place":72,"lib/util/primitives":73,"lib/util/type_of":77}],45:[function(require,module,exports){
//create a variety of HTML input controls
//each element is created via the document global then wrapped in a createjs.DOMElement for positioning through createjs
//then the DOMElement and an optional text field are wrapped in a createjs.Container
//each container is then appended with properties / methods:
//	allow access to the underlying HTML
//	a method apply_to(), that allows it to be attached to another HTML element in the DOM
//	e.g.
//		var target = document.getElementById(dom_element);
//		target.appendChild(html_element);

//initial supported HTML input controls supported:
//	button, radio button & text input

//	TODO: breakout handling of different types of HTML controls into their own code and require() here
module.exports = html_factory;

var check = require('check-types');
var argument_check = require("lib/util/argument_check");
var primitives = require("lib/util/primitives");

function html_factory(options) {
	//get an instance if we just call it
	if(!(this instanceof html_factory)) return new html_factory(options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	//create the text factory instance for getting Text for our Shapes
	var text_factory = require('lib/factory/text_factory');
	this._text_factory = text_factory();
	//default text should be empty string
	this._text_factory.text({text:''});
	
	//options for the raw HTML element
	this._html_options = {};
	
	//options for the container
	this._container_options = {x:0, y:0};
	
	//default HTML types
	this._default_types = ['radio', 'text', 'button'];
	
	this._name = '';
};

html_factory.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//public
	//configures the value of the text, defaults to an empty string
	//optionally takes text positioning and configuration options (font, color, x, y, etc)
	//	and text (a String()-able object or a createjs Text object) to set the value of the text to
	//pass in empty string for empty text
	text : function(options) {
		this._text_factory.text(options)
	},
	
	//TODO: if 'type' option already set, then don't complain about 'type' not being an argument
	//public
	//configures the raw HTML input element as returned from document.createElement
	//	validated options: type, id (is String'd if present)
	//	type is required, id is optional
	//	if id is undefined, then a unique id is generated and exposed as a decorated property at get() time
	html : function(options) {
		if(!check.object(options)) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated options: type, id
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//if type isn't passed...
		if (!("type" in validated_options)) {
			throw new TypeError("argument 'type' is required, should be non-empty String");
		}
		
		//type was passed, but unsupported type
		if (this._default_types.indexOf(validated_options.type) === -1) {
			throw new TypeError("argument 'type' was unsupported: " + String(validated_options.type));
		}
		
		//generate an id if we need one
		if(!("id" in validated_options)) {
			var unique_id = require('lib/util/unique_id');
			var id_str = unique_id(validated_options.type);
			validated_options.id = id_str;
		} else {
			//...else if the user passed us one, just String it
			validated_options.id = String(validated_options.id);
		}
		
		//if the type was 'button', then we can take an optional 'label' argument, but not allowed on any other HTML type
		if (validated_options.type !== 'button' && !(check.undefined(validated_options.label))) {
			throw new TypeError("argument 'label' is only used with 'button' HTML type");
		}
			
		//set HTML options for producing HTML in _get_html() later		
		for (option in validated_options) {
			this._html_options[option] = validated_options[option];
		}
	},
	
	//public
	//decorate an optional name value on the HTML for identification purposes
	name : function(value) {
		if(!check.undefined(value)) this._name = String(value);
	},
	
	//private
	//returns a configured createjs Text() object as configured in text()
	_get_text : function() {
		return this._text_factory.get();
	},
	
	//private
	//returns a configured HTML option as configured in html()
	_get_html : function() {
		var html = document.createElement('input');
		html.type = this._html_options.type;
		html.id = this._html_options.id;
		//positions html at (0, 0) on canvas
		html.style.top = 0;
		html.style.left = 0;
		
		//copy any other user options to the html object
		for (option in this._html_options) {
			if (option === 'label') {
				//string anything the user passed in for the label
				//NOTE: as incorrectly documented on MDN, to apply a label to a button use the 'value' property instead of 'label'
				//https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
				html.value = String(this._html_options['label']);
				continue;
			}
			html[option] = this._html_options[option];
		}
		
		return html;
	},
	
	//private
	//wraps the raw HTML object in a createjs.DOMElement
	//	where the raw HTML can be found as the htmlElement property on the DOMElement object
	_get_dom_element : function (html) {
		return new this._createjs.DOMElement(html);
	},
	
	//private
	//bundle the DOMElement and text together in a createjs.container
	//adding properties for convenience methods on the container from the html and text
	_bundle : function(DOMElement, text) {
		var container = new this._createjs.Container();
		
		//adding text last, such that it appears above the HTML
		container.addChild(DOMElement);
		container.addChild(text);
		
		//adding convenience methods for accessing internal objects for later
		//	within the _ namespace
		container._ = {};
		container._.htmlElement = DOMElement.htmlElement;
		container._.text = text.text;	//get the value of the text, not the Text object
		
		return container;
	},
	
	//private
	//add additional convenience methods to the container for ease of accessing and using the HTML object
	_decorate : function(container) {
		var append_to = require('lib/util/append_to');
		container._.append_to = append_to(container);
		
		//TODO, setup place commands on container for easy positioning
		//	the DOMElement can't calculate its own bounds, so we have no reliable way to getting the bounds of the HTML object
		//	the Element interface DOES have some ways of calculating the dimensions of the elements, but they're marked as experimental at this time:
		//	https://developer.mozilla.org/en-US/docs/Web/API/Element
		/* var place = require('lib/util/place');
		container._.place = place(container); */
		
		//add add_to_stage functionality
		var add_to_stage = require('lib/util/add_to_stage');
		container._.add_to_stage = add_to_stage(container);
		
		//add optional name
		//if name is unset, attempt to attach 'label' property as name on container
		//otherwise 'name' is ''
		if (this._name.length === 0) {
			if (!(check.undefined(this._html_options.label))) container._.name = String(this._html_options.label);
		} else {
			container._.name = this._name;
		}
		
		return container;
	},
	
	_set_props : function(container, options) {
		//save the user options
		for (option in options) {
			this._container_options[option] = options[option];
		}
		
		//...and apply any new options to the container
		for (option in this._container_options) {
			container[option] = this._container_options[option];
		}
		
		return container;
	},
	
	get : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		if (!("type" in this._html_options)) {
			throw new TypeError("Unknown type of HTML to create, run html() first before calling get()");
		}
		
		//validated options: x, y
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		var html = this._get_html();							//get the raw HTML
		var text = this._get_text();							//get the optional Text
		var de = this._get_dom_element(html);					//wrap the raw HTML in a createjs.DOMElement
		var container = this._bundle(de, text);					//bundle the DOMElement and text together in a createjs.container
		container = this._decorate(container)					//add additional convenience methods specific to the HTML to the container
		return this._set_props(container, validated_options);	//set last minute user defined properties on the container
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_text_factory : undefined,	//holds the text_factory instance
	_html_options : {},			//options for the raw HTML element
	_container_options : {},	//options for the container
	_default_types : [],		//default HTML types
	_shape_type : undefined,	//HTML input type setup in html()
	_name : '',					//optional name to attach to the HTML
	_createjs : undefined,		//local reference to the createjs object
};
},{"check-types":6,"lib/factory/text_factory":47,"lib/util/add_to_stage":68,"lib/util/append_to":69,"lib/util/argument_check":70,"lib/util/primitives":73,"lib/util/unique_id":78}],46:[function(require,module,exports){
module.exports = shape_factory;

var check = require('check-types');
var argument_check = require("lib/util/argument_check");
var primitives = require("lib/util/primitives");

function shape_factory(options) {
	//get an instance if we just call it
	if(!(this instanceof shape_factory)) return new shape_factory(options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	//configure defaults for color of Shape
	this._color_options = {fill:undefined, stroke:null}
	
	//create the text factory instance for getting Text for our Shapes
	var text_factory = require('lib/factory/text_factory');
	this._text_factory = text_factory();
	
	//default sizing and positioning options for the Shape
	//	default h and w for rect shapes come from LaFore defaults
	//TODO: radius = 1, is a placeholder until we can measure the radius of circles used in LaFore
	this._shape_options = {radius: 1, height:18, width:36, x:0, y:0},
	
	//default options for the container (that will hold both the Shape and Text)
	//users can set persistent options for the container by passing options to get()
	this._container_options = {x:0, y:0};
	
	//configure default shapes the factory knows about
	//'rectangle' and 'box' are aliases for 'rect'
	this._default_shapes = ["circle", "rect", "rectangle", "box"];
	
	//configured in shape() then used in _get_shape() to return the Shape object
	this._shape_type = undefined;
};

shape_factory.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//public
	//configures the fill and stroke of the shape returned
	//default behavior for the fill is getting a random color that has good contrast with the text color
	//default for stroke is null
	//takes optional values for fill and stroke
	color : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated options: color (alias for fill), fill, stroke
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		if ('fill' in validated_options) {
			this._color_options['fill'] = validated_options['fill'];
		}
		
		if ('color' in validated_options) {
			this._color_options['fill'] = validated_options['color'];
		}
		
		if ('stroke' in validated_options) {
			this._color_options['stroke'] = validated_options['stroke'];
		}
	},
	
	//public
	//configures the value of the text, defaults to a random integer between 0 and 1000
	//optionally takes text positioning and configuration options (font, color, x, y, etc)
	//	and text (a String()-able object or a createjs Text object) to set the value of the text to
	//pass in empty string for empty text
	text : function(options) {
		this._text_factory.text(options)
	},
	
	//public
	//configures the type of shape to return, 'type' must be a known string (circle, rect, etc)
	//includes defaults for size
	shape : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated options:
		//	height, width (for rect shapes)
		//	radius (for circle shapes)
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//if type isn't passed...
		if (!("type" in validated_options)) {
			throw new TypeError("argument 'type' is required, should be non-empty String");
		}
		
		if(this._default_shapes.indexOf(validated_options.type) === -1) {
			throw new TypeError("argument 'type' was unknown shape type: " + String(validated_options.type));
		}
		
		if (validated_options.type === "circle") {
			//if there are configuration options, then use them, otherwise the defaults
			if(validated_options.radius) this._shape_options.radius = validated_options.radius;
			
			this._shape_type = "circle"
			return;
		}
		
		if (validated_options.type === "rectangle" || validated_options.type === "rect" || validated_options.type === "box") {
			//if there are confgiuration options, then use them, otherwise the defaults
			if(validated_options.width) this._shape_options.width = validated_options.width;
			if(validated_options.height) this._shape_options.height = validated_options.height;
			
			this._shape_type = "rect"
			return;
		}
	},
	
	//private
	//configured by color(), returns user defined CSS hex color string(s) if supplied
	//	otherwise a random fill color that has good contrast with the text color and null for the stroke
	_get_color : function() {
		var fill, stroke;
		
		//if the fill is undefined (the default) then get a random color with good constrast with the text color
		if (check.undefined(this._color_options.fill)) {
			fill = (require('lib/util/random_color'))(this._text_factory.color());
		} else {
			fill = this._color_options.fill;
		}
		stroke = this._color_options.stroke;
		
		return {fill:fill, stroke:stroke};
	},
	
	//private
	//returns a configured createjs Text() object as configured in text()
	_get_text : function() {
		return this._text_factory.get();
	},
	
	//private
	//returns a configured createjs Shape object, as configured by shape()
	_get_shape : function(shape_color) {
		if (check.undefined(this._shape_type)) {
			throw new TypeError("Unknown type of Shape to create, run shape() first before calling get()");
		}
		
		var shape = new this._createjs.Shape();
		
		//assign color (stroke and fill) BEFORE applying shape for some reason (createjs idiom)
		shape.graphics.beginFill(shape_color.fill);
		shape.graphics.beginStroke(shape_color.stroke);
		
		//assign (x, y) coordinates to the Shape in _get_shape() rather than on the Graphic (createjs idiom)
		shape.x = this._shape_options.x;
		shape.y = this._shape_options.y;
		
		//circle specific Shape handling
		if (this._shape_type === 'circle') {
			shape.graphics.drawCircle(0, 0, this._shape_options.radius);
			
			//set bounds on the Shape for later
			//Note: we set the (x, y) coordinates to the top left hand corner of the "bounding box"
			//	as such the (x, y) coordinates are always negative, as we are always above and to the left of center
			//	where the (x, y) coordinates of how the Shape is placed is figured by createjs
			shape.setBounds(-this._shape_options.radius, 
				-this._shape_options.radius, 
				2*this._shape_options.radius,
				2*this._shape_options.radius
				);
		}
		
		//rectangle specific Shape handling
		if (this._shape_type === 'rect') {
			shape.graphics.drawRect(0, 0, this._shape_options.width, this._shape_options.height);
			
			//set bounds on the Shape for later
			shape.setBounds(0, 0,
				this._shape_options.width,
				this._shape_options.height
				);
		}
		
		//assign any other user options to the Shape
		for (shape_option in this._shape_options) {
			//...except for those we've already covered
			if (shape_option in {radius:null, height:null, width:null, x:null, y:null}) continue;
			shape[shape_option] = this._shape_options[shape_option];
		}
		
		//return the Shape
		return shape;
	},
	
	//private
	//returns a createjs container with the configured shape and text objects inside
	//	such that the text is viewable, overlaying the Shape
	_bundle : function(shape, text) {
		var container = new this._createjs.Container();
		container.addChild(shape);
		container.addChild(text);
		return container;
	},
	
	//private
	//set convenience accessor properties on the container, as well as any positioning / transform options passed to get()
	_set_props : function(container, options) {
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//set user options in _container_options to save state
		for (option in validated_options) {
			this._container_options[option] = validated_options[option];
		}
		
		//... and then apply to container
		for (option in this._container_options) {
			container[option] = this._container_options[option];
		}
		
		return container;
	},
	
	//TODO: modify to have color items decorated on to shape object
	//	then just append them to the container in _decorate here
	_decorate : function(container, color) {
		var shape = container.children[0];
		var text = container.children[1];
		
		container._ = {};
		
		//set the container's event listener methods, to point to the Shape's event listener methods
		container._.on = shape.on;
		container._.off = shape.off;
		container._.addEventListener = shape.addEventListener;
		container._.hasEventListener = shape.hasEventListener;
		container._.removeAllEventListeners = shape.removeAllEventListeners;
		container._.removeEventListener = shape.removeEventListener;
		
		//manually set container bounds to Shape bounds
		//as the container bounds can inherit from the Text bounds which are apparently set automatically while the Shape is not?
		container.setBounds(shape.getBounds().x, shape.getBounds().y, shape.getBounds().width, shape.getBounds().height);
		
		//setup place commands on container for easy positioning
		var place = require('lib/util/place');
		container._.place = place(container);
		
		//add add_to_stage functionality
		var add_to_stage = require('lib/util/add_to_stage');
		container._.add_to_stage = add_to_stage(container);
		
		//setup properties for the Shape stroke and fill
		container._.shape_fill = color.fill;
		container._.shape_stroke = color.stroke;
		
		return container;
	},
	
	//public
	//allocate a new shape of the configured type
	get : function (options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//template pattern, build the shape object
		//where options can be positioning and transform options as applied to the container
		var shape_color = this._get_color();				//get the color string used in shape construction
		var shape_text = this._get_text();					//the text value to display with the shape
		var shape = this._get_shape(shape_color);			//get the shape itself
		var container = this._bundle(shape, shape_text);	//bundle the shape and text into a createjs container
		container = this._decorate(container, shape_color);	//add additional convenience methods specific to the Shape to the container
		return this._set_props(container, options);			//add properties user propertier to container
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	//private
	//the color used on the shape, if undefined then just use random
	_color_options : {},
	//private
	//text factory, used in setting up Text objects for Shape's
	_text_factory : undefined,
	//private
	//shape options and type as set in shape()
	_shape_options : {},
	//private
	//defines what method is used to construct the Shape, once configured in shape()
	_shape_type : undefined,
	//private
	//options for the container pased back to the caller
	_container_options : {},
	
	_createjs : undefined,		//local reference to the createjs object
};
},{"check-types":6,"lib/factory/text_factory":47,"lib/util/add_to_stage":68,"lib/util/argument_check":70,"lib/util/place":72,"lib/util/primitives":73,"lib/util/random_color":74}],47:[function(require,module,exports){
module.exports = text_factory;

var check = require('check-types');
var argument_check = require("lib/util/argument_check");
var primitives = require("lib/util/primitives");

function text_factory(options) {
	//get an instance if we just call it
	if(!(this instanceof text_factory)) return new text_factory(options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	//configure defaults for Text
	this._text_options = {color:"black", font:"18px Arial", text:undefined};
};

text_factory.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//public
	//returns the createjs.Text object as configured in text()
	//if there are last minute options by the user, then shortcut to configure via text() and return the configured object
	get : function(options) {
		if (options) this.text(options);
		var text = this._get_text();
		return this._decorate(text);
	},
	
	//public
	//configures the value of the text, defaults to a random integer between 0 and 1000
	//optionally takes text positioning and configuration options (font, color, x, y, etc)
	//	and text (a String()-able object or a createjs Text object) to set the value of the text to
	//pass in empty string for blank text
	text : function(options) {
		if(!(check.object(options) || check.undefined(options))) {
			throw new TypeError("Incorrect argument type, requires Object.");
		}
		
		//validated arguments: color, font, x, y, text, textAlign
		var validated_options;
		try {
			validated_options = argument_check(options);
		} catch(error) {
			throw error;
		}
		
		//text handler
		//if text is set, then verify it's either a createjs Text() object or something we can String()
		if(!check.undefined(validated_options.text)) {
			if (!(check.instance(validated_options.text, this._createjs.Text))) {
				validated_options.text = String(validated_options.text);
			}
		}
		
		//append / overwrite any options passed in
		for (variable in validated_options) {
			this._text_options[variable] = validated_options[variable];
		}
	},
	
	//public
	//getter functions, used for exposing internal options
	color : function() {return this._text_options.color;},
	font : function() {return this._text_options.font;},
	
	//private
	//returns a configured createjs Text() object as configured in text()
	_get_text : function() {
		var value;
		//if default, then create a random number to assign to the Text
		if (check.undefined(this._text_options.text)) {
			var random_integer = require('lib/util/random_integer');
			value = String(random_integer());
		}
		
		//if user defined, then assign it (always a String)
		if (check.string(this._text_options.text)) {
			value = this._text_options.text;
		}
		
		//if a Text object, then just return that
		if (check.instance(this._text_options.text, this._createjs.Text)) {
			return this._text_options.text;
		}
		
		//...otherwise create new Text object, initialize to value
		var text = new this._createjs.Text(value);
		
		//...and copy options that was set in text() to the Text object
		for (text_option in this._text_options) {
			//skipping text, as we don't want to overwrite what we initialized it to
			if (text_option === 'text') continue;
			text[text_option] = this._text_options[text_option];
		}
		
		return text;
	},
	
	//private
	//returns a decorated text object
	_decorate : function(text) {
		text._ = {};
		
		//TODO: why does this do it this way?
		//NOTE: this wierdly makes tests in other factories fail, claiming that bounds are not set on the object?
		//UPDATE: this might have something to do with empty string Text objects do NOT have bounds set on them
		//add place() functionality
		/* var place = require('lib/util/place');
		text._.place = place(text); */
		
		//add add_to_stage functionality
		var add_to_stage = require('lib/util/add_to_stage');
		text._.add_to_stage = add_to_stage(text);
		
		return text;
	},

	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	
	//private
	_text_options : {},		//text options and values as set by text()
	_createjs : undefined,	//internal refrence to the createjs object
};
},{"check-types":6,"lib/util/add_to_stage":68,"lib/util/argument_check":70,"lib/util/primitives":73,"lib/util/random_integer":76}],48:[function(require,module,exports){
var check = require('check-types')

function lesson(options) {
	if (!(this instanceof lesson)) return new lesson(options);
	
	//if we don't have a UI object, can't continue, error
	if (!(check.object(options) && check.object(options.UI))) {
		throw new TypeError("Argument 'UI' (object) is required, argument should be object.");
	}
	
	this._UI = options.UI;
	
	//SETUP
	//initial setup state
	this._state = this._INIT;
	
	var next = this.next;
	var pre_start = this.pre_start;
	//attach event handler for 'insert' button
	this._UI.insert_button.addEventListener("click", function() {
		pre_start();
	});
	
	//attach even handler for 'next' button
	this._UI.next_button.addEventListener("click", function() {
		next();
	});
	
	//all done with initial setup
	this._state = this._READY;
};

lesson.prototype = {
	//public
	//method used before the start of the lesson
	//	checks user input, gathers state of the UI, etc
	//	does nothing if traversing a lesson
	pre_start : function() {
		if (this._state !== this._READY) {
			//do nothing if we're setting up or in the middle of a lesson
			return;
		}
		
		//get user input to use during the lesson
		this._input_tmp = this._UI.input.get();
		
		//if user input is NaN, then unusable, print error and return
		//NOTE: Number.isNaN() returns true on undefined
		if (Number.isNaN(this._input_tmp)) {
			this._UI.output.set("The input is not a number.\n Please enter a number and press the insert button to insert the number into the array.");
			this._input_tmp = undefined;
			return;
		}
		
		//gather the state of the working array before lesson start
		if (this._UI.array.working.length === this._UI.array.working.size) {
			this._array_full = true;
		} else {
			this._array_full = false;
		}
		
		//change state to enter lesson
		this._state = this._RUN;
		this._step_state = this._STEP_1;
		
		//call the first step in the lesson
		return this.next();
	},
	//public
	//once running the lesson, used to get the next step in the lesson
	//	does nothing if not traversing a lesson
	next : function() {
		if (this._state !== this._RUN) {
			//do nothing as we're not in the lesson yet
			return;
		}
		
		if (this._array_full) {
			//array full case
			
			//create new array step
			if (this._step_state === this._STEP_1) {
				//allocate the new array and store a reference
				this._array_tmp = this._UI.array.get({size:this._UI.array.working.size*2, nodes:0});
				
				//allocate a new tail arrow for the new array
				this._arrow_tmp = this._UI.arrow.get({name:'tail', array:this._array_tmp, index:0});
				
				var message = "Array is full. Allocating new array of twice the length of the old one.";
				this._UI.output.set(message);
				
				this._step_state = this._STEP_2;
				
				return {value:message, done:false};
			}
			
			//create a move pointer, step
			if (this._step_state === this._STEP_2) {
				//allocate a new move arrow, on the old array, at index 0
				this._move_pointer = this._UI.arrow.get({name:'move', array:this._UI.array.working, index:0});
				
				var message = "Creating a move pointer at index 0 on the old array.";
				this._UI.output.set(message);
				
				this._step_state = this._STEP_MOVING;
				
				return {value:message, done:false};
			}
			
			//move content from old array to new array, step
			if (this._step_state === this._STEP_MOVING) {
				//exit condition
				//if the move pointer is pointing at the same index as the tail pointer in the old array
				if (this._move_pointer.index === this._UI.arrow.working.index) {
					var message = "The 'move' pointer is at the same index as the 'tail' pointer on the old array, we've finished moving the values.";
					this._UI.output.set(message);
				
					this._step_state = this._STEP_3;
					return {value:message, done:false};
				}
				
				//else, move the value at the current index
				var src_idx = this._move_pointer.index;
				var dst_idx = this._arrow_tmp.index;
				
				this._UI.array.move(
					{
						from_array: this._UI.array.working,
						from_index: src_idx,
						to_array: this._array_tmp,
						to_index: dst_idx,
					}
				);
				
				this._array_tmp[dst_idx] = this._UI.array.working[src_idx];
				//not removing value from old array, wait until array de-allocates
				
				//increment the move pointer
				this._move_pointer.increment();
				
				//increment the pointer in the new array, since we just put in a new value
				this._arrow_tmp.increment();
				
				var message = "Moved value " + String(this._array_tmp[dst_idx]) + ", from old array to new.";
				this._UI.output.set(message);
				
				return {value:message, done:false};
			}
			
			if (this._step_state === this._STEP_3) {
				//set array_full to false, now that we have a new array with more space
				this._array_full = false;
				
				//remove the old array and arrow from the UI
				this._UI.array.del(this._UI.array.working);
				this._UI.arrow.del(this._UI.arrow.working);
				
				//update the working array, to be the array we just got finished moving to
				this._UI.array.working = this._array_tmp;
				this._UI.arrow.working = this._arrow_tmp;
				this._array_tmp = undefined;
				this._arrow_tmp = undefined;
				
				//remove the 'move' arrow
				this._UI.arrow.del(this._move_pointer);
				this._move_pointer = undefined;
				
				var message = "Removing the old array and the move pointer.";
				this._UI.output.set(message);
				
				//set step and array_full to the appropriate values such that on next()
				//	we will re-use the logic below to copy the value from the input to the new array, that now has room
				this._step_state = this._STEP_1;
				
				return {value:message, done:false};
			}
		} else {
			//array not full case
			
			//move step
			if (this._step_state === this._STEP_1) {
				//move user input from input array to working array, at "tail" pointer location
				this._UI.array.move(
					{
						from_array: this._UI.array.input,
						from_index: 0,	//only a single index in input array
						to_array: this._UI.array.working,
						to_index: this._UI.arrow.working.index,
					}
				);
				
				//moving logic
				//NOTE: instead of using delete using pop(), as delete does not properly update length?
				//delete this._UI.array.input[0];
				this._UI.array.input.pop();
				this._UI.array.working[this._UI.arrow.working.index] = this._input_tmp;
				
				//set output to state what's been done
				var message = "Added the value " + String(this._input_tmp) + " to the array."
				this._UI.output.set(message);
				
				this._input_tmp = undefined;
				
				//increment the step state to do the next step on next()
				this._step_state = this._STEP_2;
				
				return {value:message, done:false};
			}
			
			//tail pointer increment step
			if (this._step_state === this._STEP_2) {
				this._UI.arrow.working.increment();	//increment tail pointer
				
				//set output to state what's been done
				var message = "Moved the 'tail' pointer to index: " + String(this._UI.arrow.working.index) + ", to prepare for the next insertion.";
				this._UI.output.set(message);
				
				//reset step state for next call
				this._step_state = undefined;
				
				//set state of lesson to accept another user input for insertion
				this._state = this._READY;
				
				//return done
				return {value:message, done:true};
			}
		}
	},
	
	//private variables
	_UI : 			undefined,	//local pointer to the UI object
	_input_tmp :	undefined,	//local storage for input while traversing a lesson
	_array_full : 	false,		//marks the case of the array being full or not, causing different lesson logic
	_array_tmp :	undefined,	//holds a reference to a new array object, used on _array_full === true case to allocate a new larger array
	_arrow_tmp :	undefined,	//holds a reference to a new arrow object for the a new array, on _array_full === true case
	_move_pointer : undefined,	//holds a reference to an arrow object, used in copy on _array_full === true case
	
	//state and constants associated
	_RUN : 2,			//currently traversing the lesson
	_READY : 1,			//ready to start the lesson, done with all of the setup, not currently in the lesson
	_INIT : 0,			//initial state, setting up object for lesson, should not be able to interact at this step
	_state : undefined,	//tracks the state of the lesson
	
	//states for when stepping through a lesson
	_STEP_3 : 3,
	_STEP_MOVING : 0,
	_STEP_2 : 2,
	_STEP_1 : 1,
	_step_state : undefined,
};

module.exports = lesson;
},{"check-types":6}],49:[function(require,module,exports){
var array_UI = require('lib/UI/array_UI');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var mock_lib = {
		TitleScreen : function() {
			return {
				insert_btn : {
					addEventListener : function() {},
				},
				gotoAndPlay : function() {},
			};
		},
		ArrayScreen : function() {
			return {};
		},
		ArrayElement : function() {
			var ae = new createjs.Shape();
			ae.index_txt = {
				text : '',
			};
			
			return ae;
		},
	};
	
	primitives.set('lib', mock_lib);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test("[array_UI] incorrect, 'lib' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('lib', '');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/lib/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'lib' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('lib');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/lib/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('createjs');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, no argument", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, but no property", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, with length property, but wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({length:"some bad type"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, with length property, right type, but invalid value", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({length:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] correct", function (t) {
	//SETUP
	SETUP();
	
	//TEST
	var result = array_UI({length:1});
	
	t.ok(check.object(result), "got back an object");
	t.ok(check.instanceStrict(result.array, createjs.Container), "the array object");
	t.ok(check.instanceStrict(result.arrow, createjs.Container), "the arrow object");
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._make_array] correct', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_createjs : primitives.get('createjs'),
		_lib : primitives.get('lib'),
		_array : undefined,
	};
	
	//TEST
	var result = array_UI.prototype._make_array.call(mock_this, 1);
	
	t.ok(check.instanceStrict(result, createjs.Container), "got back a container");
	t.equal(result.children.length, 1, "should have only one arrayElement");
	t.ok(check.instanceStrict(result.children[0], createjs.Container), "children are containers");
	t.ok(check.object(result.children[0]._), "each child has a _ namespace for decoration");
	t.ok(check.number(result.children[0]._.index), "each child has an index associated");
	t.equal(result.children[0]._.index, 0, "...and the index matches the arrayElement's position in the array");
	t.ok(check.object(result.getBounds()), "bounds have been set");
	t.ok(check.object(result._), "decorated _ namespace is present");
	t.ok(check.number(result._.length), "_length is present");
	t.equal(result._.length, 1, "...and equal to the length of the array");
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._decorate_coordinates] correct', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	for (var i = 0; i < 3; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
	}
	
	//TEST
	var result = array_UI.prototype._decorate_coordinates.call(mock_this, outer_container);
	
	//initial placement, such that the parent array is at (0, 0)
	//	use this to test that the values of the coordinates update as the parent moves in the next step
	result.x = 0;
	result.y = 0;
	
	//this should increase, as we check arrayElements that are more to the right on the screen (larger x values on their positions)
	var previous_on_x = 0;
	//this should stay the same, as the arrayElements are all in a line (do not vary up or down on the screen)
	var previous_on_y = result.children[0]._.on().y;
	
	//record coordinate values, for comparison later when we change the position of the parent container
	var on_values = [];
	
	//similar characteristics of the values of below.x and below.y
	var previous_below_x = 0;
	var previous_below_y = result.children[0]._.below().y;
	
	var below_values = [];
	
	for (var i = 0; i < result.children.length; i++) {
		t.ok(check.object(result.children[i]._), "child " + String(i) + " has a '_' namepsace");
		t.ok(check.function(result.children[i]._.on), "child " + String(i) + " has a 'on' property");
		t.ok(check.function(result.children[i]._.below), "child " + String(i) + " has a 'below' property");
		
		var on = result.children[i]._.on();
		
		t.ok(check.number(on.x), "child " + String(i) + " has a numeric 'on.x' property");
		t.ok(check.number(on.y), "child " + String(i) + " has a numeric 'on.y' property");
		
		t.ok(on.x > previous_on_x, "child " + String(i) + ", 'on.x' greater than previous");
		previous_on_x = on.x;
		
		t.equal(on.y, previous_on_y, "child " + String(i) + ", 'on.y' equal to previous");
		previous_on_y = on.y;
		
		on_values.push({x:on.x, y:on.y});
		
		var below = result.children[i]._.below();
		
		t.ok(check.number(below.x), "child " + String(i) + " has a numeric 'below.x' property");
		t.ok(check.number(below.y), "child " + String(i) + " has a numeric 'below.y' property");
		
		t.ok(below.x > previous_below_x, "child " + String(i) + ", 'below.x' greater than previous");
		previous_below_x = below.x;
		
		t.equal(below.y, previous_below_y, "child " + String(i) + ", 'below.y' equal to previous");
		previous_below_y = below.y;
		
		below_values.push({x:below.x, y:below.y});
	}
	
	result.x = 100;
	result.y = 100;
	
	for (var i = 0; i < result.children.length; i++) {
		var on = result.children[i]._.on();
		
		t.ok(on.x > on_values[i].x, "should see larger value on current x, since we moved the parent");
		t.ok(on.y > on_values[i].y, "should see larger value on current y, since we moved the parent");
		t.equal(on.x - on_values[i].x, 100, "the difference between the old placement and the new should be how far we moved the parent");
		t.equal(on.y - on_values[i].y, 100, "the difference between the old placement and the new should be how far we moved the parent");
		
		var below = result.children[i]._.below();
		
		t.ok(below.x > below_values[i].x, "should see larger value on current x, since we moved the parent");
		t.ok(below.y > below_values[i].y, "should see larger value on current y, since we moved the parent");
		t.equal(below.x - below_values[i].x, 100, "the difference between the old placement and the new should be how far we moved the parent");
		t.equal(below.y - below_values[i].y, 100, "the difference between the old placement and the new should be how far we moved the parent");
	}
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._setup_tail_arrow] correct', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	for (var i = 0; i < 3; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		inner_container._.index = i;
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
	}
	
	outer_container._ = {};
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	for (var i = 0; i < outer_container.children.length; i++) {
		outer_container.children[i]._.below = function() {
			return {x:0, y:0}
		}
	}
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	
	//TEST
	var result = array_UI.prototype._setup_tail_arrow.call(mock_this, outer_container);
	
	t.ok(check.instanceStrict(result, createjs.Container), "got back a container");
	t.ok(check.object(result._), "that has a _ namespace");
	t.ok(check.object(result._.move), "_.move is defined");
	t.equal(result._.name, "tail", "arrow should be named 'tail'");
	t.ok(check.function(result._.next), "next is defined");
	t.ok(check.object(result._.pointed_at), "it should be pointed at an object");
	t.deepEqual(result._.pointed_at, outer_container.children[0], "which should be the first child in the array");
	t.equal(outer_container.children.length, 4, "added the arrow to the array container");
	t.deepEqual(outer_container.children[3], result, "added the arrow to the array container");
	
	t.end();
});

test('[array_UI._setup_tail_arrow] correct, next() correct from start of the array', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	outer_container._ = {};
	outer_container._.values = [];
	
	for (var i = 0; i < 3; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		inner_container._.index = i;
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
		
		outer_container._.values.push(i);
	}
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	outer_container.children[0]._.below = function() {
		return {x:0, y:0}
	};
	
	outer_container.children[1]._.below = function() {
		return {x:1, y:1}
	};
	
	outer_container.children[2]._.below = function() {
		return {x:2, y:2}
	};
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	
	//TEST
	var result = array_UI.prototype._setup_tail_arrow.call(mock_this, outer_container);
	var next_result = result._.next();
	
	t.ok(check.object(result._.pointed_at), "arrow should be pointed at an object");
	t.deepEqual(result._.pointed_at, outer_container.children[1], "...which should be the SECOND child post next()");
	
	t.notOk(next_result.done, "the return value should show we're not done iterating");
	
	setTimeout(function() {
		t.ok(result.x > 0 && result.x < 1, 'coordinates should be on the way to (1, 1), but not equal');
		t.ok(result.y > 0 && result.y < 1, 'coordinates should be on the way to (1, 1), but not equal');
	}, 500);
	
	setTimeout(function() {
		t.equal(result.x, 1, "arrow should be at (1, 1) after the move() is finished");
		t.equal(result.y, 1, "arrow should be at (1, 1) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._setup_tail_arrow] correct, next() correct from start of the array (array positioned at (100, 100))', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	outer_container._ = {};
	outer_container._.values = [];
	
	for (var i = 0; i < 3; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		inner_container._.index = i;
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
		
		outer_container._.values.push(i);
	}
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	//adjusting mock values for below() to take into account relocation of the outer_container
	var array = outer_container;
	array.children[0]._.below = (function(j) {
		return function() {
			return {x:array.x + array.children[j].x + 22, y:array.y + 70};
		}
	})(0)
	
	array.children[1]._.below = (function(j) {
		return function() {
			return {x:array.x + array.children[j].x + 22, y:array.y + 70};
		}
	})(1)
	
	array.children[2]._.below = (function(j) {
		return function() {
			return {x:array.x + array.children[j].x + 22, y:array.y + 70};
		}
	})(2)
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	
	//TEST
	var result = array_UI.prototype._setup_tail_arrow.call(mock_this, outer_container);
	
	//simulating positioning of array after the array has been created
	outer_container.x = 100;
	outer_container.y = 100;
		
	var next_result = result._.next();
	
	t.ok(check.object(result._.pointed_at), "arrow should be pointed at an object");
	t.deepEqual(result._.pointed_at, outer_container.children[1], "...which should be the SECOND child post next()");
	
	t.notOk(next_result.done, "the return value should show we're not done iterating");
	
	setTimeout(function() {
		t.ok(result.x > 22 && result.x < 72, 'coordinates should be on the way to (72, 70), but not equal');
		t.equal(result.y, 70, 'y should not change');
	}, 500);
	
	setTimeout(function() {
		t.ok(result.x, 72, 'arrow should be at (72, 70), after the move() is finished');
		t.equal(result.y, 70, 'y should not change');
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._setup_tail_arrow] correct, next() correct to the end of the array', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	outer_container._ = {};
	outer_container._.values = [];
	outer_container._.length = 1;
	
	for (var i = 0; i < outer_container._.length; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		inner_container._.index = i;
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
		
		outer_container._.values.push(i);
	}
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	outer_container.children[0]._.below = function() {
		return {x:0, y:0}
	};
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	
	//TEST
	var result = array_UI.prototype._setup_tail_arrow.call(mock_this, outer_container);
	var next_result = result._.next();
	
	t.ok(check.object(result._.pointed_at), "arrow should be pointed at an object");
	t.deepEqual(result._.pointed_at, outer_container.children[0], "...which should still be the first child");
	
	t.ok(next_result.done, "the return value should show we're done iterating.");
	
	t.equal(result.x, 0, "arrow should never have moved.");
	t.equal(result.y, 0, "arrow should never have moved.");
	
	t.end();
});

test('[array_UI._decorate_value_array] correct', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_this = {};
	
	//TEST
	var result = array_UI.prototype._decorate_value_array.call(mock_this, {_:{}});
	
	t.ok(check.array(result._.values), "values array decorated");
});

test('[array_UI._decorate_method_push] correct', function (t) {
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	t.ok(check.function(result._.push), "push() is decorated");
	
	t.end();
});

test('[array_UI._decorate_method_push] incorrect, no argument', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	try {
		result._.push()
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/Requires a createjs.Text object/), 'should be Text');
		t.ok(message.match(/value is a number/), 'should be a number');
	}
});

test('[array_UI._decorate_method_push] incorrect, bad argument', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	try {
		result._.push("some bad argument")
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/Requires a createjs.Text object/), 'should be Text');
		t.ok(message.match(/value is a number/), 'should be a number');
	}
});

test('[array_UI._decorate_method_push] incorrect, correct argument type, empty value', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text();
	
	try {
		result._.push(arg)
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/Requires a createjs.Text object/), 'should be Text');
		t.ok(message.match(/value is a number/), 'should be a number');
	}
});

test('[array_UI._decorate_method_push] incorrect, correct argument type, bad value', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text("some bad value");
	
	try {
		result._.push(arg)
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/Requires a createjs.Text object/), 'should be Text');
		t.ok(message.match(/value is a number/), 'should be a number');
	}
});

test('[array_UI._decorate_method_push] incorrect, array is full', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {
		_:{
			values : [1, 2, 3],
			length : 3,
		},
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text("0");
	
	try {
		result._.push(arg)
	} catch(error) {
		t.ok(check.instanceStrict(error, RangeError), 'we should get back a RangeError');
		var message = error.toString();
		t.ok(message.match(/Array is full/), "tells you what's wrong");
		t.ok(message.match(/cannot push\(\) new value/), "cannot push()");
	}
});

test('[array_UI._decorate_method_push] correct, empty array', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	mock_child._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {
		_ : {
			index : 0,
		},
	};
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//before the push
	t.equal(arg.x, 0, "the position of the value has not been tweened");
	t.equal(arg.y, 0, "the position of the value has not been tweened");
	t.equal(mock_child.children.length, 1, "there should only be a single child in position 0 of the array, the ArrayElement object");
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	
	result._.push(arg);
	
	//after the push
	t.equal(mock_child.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child.children[1].text, "0", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	
	setTimeout(function() {
		t.ok(arg.x > 0 && arg.x < 100, 'coordinates should be on the way to (100, 100), but not equal');
		t.ok(arg.y > 0 && arg.y < 100, 'coordinates should be on the way to (100, 100), but not equal');
	}, 500);
	
	setTimeout(function() {
		t.equal(arg.x, 100, "value should be at (100, 100) after the move() is finished");
		t.equal(arg.y, 100, "value should be at (100, 100) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, empty array, (array positioned at (100, 100))', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//adding on() positioning to the child
	mock_child._.on = (function(j) {
		return function() {
			return {x:mock_array.x + mock_array.children[j].x + 9, y:mock_array.y + 15};
		}
	})(0);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {
		_ : {
			index : 0,
		},
	};
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//adding arrow to the array container
	mock_array.addChild(mock_arrow);
	
	//positioning array
	mock_array.x = 100;
	mock_array.y = 100;
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//before the push
	t.equal(arg.x, 0, "the position of the value has not been tweened");
	t.equal(arg.y, 0, "the position of the value has not been tweened");
	t.equal(mock_child.children.length, 1, "there should only be a single child in position 0 of the array, the ArrayElement object");
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	
	result._.push(arg);
	
	//after the push
	t.equal(mock_child.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child.children[1].text, "0", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	
	setTimeout(function() {
		//value is repositioned with respect to the ArrayElement container, since (0, 0) globally is (-100, -100) with respect to the container
		//	half way through the tween from its translated global position to on(), it should increase from (-100, -100) to (9, 15)
		t.ok(arg.x > -100 && arg.x < 9, 'coordinates should be on the way to (9, 15), but not equal');
		t.ok(arg.y > -100 && arg.y < 15, 'coordinates should be on the way to (9, 15), but not equal');
	}, 500);
	
	setTimeout(function() {
		//NOTE: value is added to the array's child container (that contains the ArrayElement and the value)
		//	as such it is repositioned to a value in that container that maps to its original global position
		//	then tweened to the position on() the ArrayElement
		//	which, with respect to the child container, is always (9, 15)
		t.equal(arg.x, 9, "value should be at (9, 15) after the move() is finished");
		t.equal(arg.y, 15, "value should be at (9, 15) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, non-empty array', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child1 = new createjs.Container();
	mock_child1._ = {};
	mock_child1._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_child2 = new createjs.Container();
	mock_child2._ = {};
	mock_child2._.on = function() {
		return {x:200, y:200};
	};
	
	var mock_ArrayElement1 = new createjs.Shape();
	mock_ArrayElement1.x = 100;
	mock_ArrayElement1.y = 100;
	mock_child1.addChild(mock_ArrayElement1);
	
	//there's already a value in position 1
	var value1 = new createjs.Text("0");
	mock_child1.addChild(value1);
	mock_child1.x = 100;
	mock_child1.y = 100;
	
	//but no value in position 2
	var mock_ArrayElement2 = new createjs.Shape();
	mock_ArrayElement2.x = 200;
	mock_ArrayElement2.y = 200;
	mock_child2.addChild(mock_ArrayElement2);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [0];
	mock_array._.length = 3;
	mock_array.addChild(mock_child1);
	mock_array.addChild(mock_child2);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {
		_ : {
			index : 1,
		},
	};
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("1");
	arg.x = 0;
	arg.y = 0;
	
	result._.push(arg);
	
	//after the push
	t.equal(mock_child2.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child2.children[1].text, "1", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 2, "values array should have the new value in it");
	t.equal(mock_array._.values[1], 1, "values array should have the new value in it");
	
	setTimeout(function() {
		t.equal(arg.x, 200, "value should be at (200, 200) after the move() is finished");
		t.equal(arg.y, 200, "value should be at (200, 200) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, non-empty array (array positioned at (100, 100))', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child1 = new createjs.Container();
	mock_child1._ = {};
	//adding 100 to each coordinate to compensate for the positioning of the array, since on() returns global coordinates
	mock_child1._.on = function() {
		return {x:100+100, y:100+100};
	};
	
	var mock_child2 = new createjs.Container();
	mock_child2._ = {};
	mock_child2._.on = function() {
		return {x:200+100, y:200+100};
	};
	
	var mock_ArrayElement1 = new createjs.Shape();
	mock_ArrayElement1.x = 100;
	mock_ArrayElement1.y = 100;
	mock_child1.addChild(mock_ArrayElement1);
	
	//there's already a value in position 1
	var value1 = new createjs.Text("0");
	mock_child1.addChild(value1);
	mock_child1.x = 100;
	mock_child1.y = 100;
	
	//but no value in position 2
	var mock_ArrayElement2 = new createjs.Shape();
	mock_ArrayElement2.x = 200;
	mock_ArrayElement2.y = 200;
	mock_child2.addChild(mock_ArrayElement2);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [0];
	mock_array._.length = 3;
	mock_array.addChild(mock_child1);
	mock_array.addChild(mock_child2);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {
		_ : {
			index : 1,
		},
	};
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	mock_array.addChild(mock_arrow);
	
	//positioning array
	mock_array.x = 100;
	mock_array.y = 100;
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("1");
	arg.x = 0;
	arg.y = 0;
	
	result._.push(arg);
	
	//after the push
	t.equal(mock_child2.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child2.children[1].text, "1", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 2, "values array should have the new value in it");
	t.equal(mock_array._.values[1], 1, "values array should have the new value in it");
	
	setTimeout(function() {
		t.equal(arg.x, 200, "value should be at (200, 200) after the move() is finished");
		t.equal(arg.y, 200, "value should be at (200, 200) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

//tail
},{"check-types":6,"lib/UI/array_UI":41,"lib/util/primitives":73,"tape":108}],50:[function(require,module,exports){
var arrow_UI = require('lib/UI/arrow_UI');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var mock_lib = {
		TitleScreen : function() {
			return {
				insert_btn : {
					addEventListener : function() {},
				},
				gotoAndPlay : function() {},
			};
		},
		ArrayScreen : function() {
			return {};
		},
		ArrayElement : function() {
			var ae = new createjs.Shape();
			ae.index_txt = {
				text : '',
			};
			
			return ae;
		},
	};
	
	primitives.set('lib', mock_lib);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test("[arrow_UI] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		arrow_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('createjs');
	
	//TEST
	try {
		arrow_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, no argument", function (t) {
	t.plan(2);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object/), "tells you what's wrong");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, but no properties", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'name'/), "tells you what's wrong");
		t.ok(message.match(/should be String/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, with name property, but wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'name'/), "tells you what's wrong");
		t.ok(message.match(/should be String/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, name correct, but position undefined", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:"test"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'position'/), "tells you what's wrong");
		t.ok(message.match(/should be Object with numeric properties x and y/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, name correct, position defined but no properties", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:"test", position:{}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'position'/), "tells you what's wrong");
		t.ok(message.match(/should be Object with numeric properties x and y/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, name correct, position defined, x property wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:"test", position:{x:"some bad type"}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'position'/), "tells you what's wrong");
		t.ok(message.match(/should be Object with numeric properties x and y/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, name correct, position defined, y property wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:"test", position:{x:0, y:"some bad type"}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'position'/), "tells you what's wrong");
		t.ok(message.match(/should be Object with numeric properties x and y/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, name correct, position correct, pointed_at undefined", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:"test", position:{x:0, y:0}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'pointed_at'/), "tells you what's wrong");
		t.ok(message.match(/should be Object/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, name correct, position correct, pointed_at wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:"test", position:{x:0, y:0}, pointed_at:"some bad type"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'pointed_at'/), "tells you what's wrong");
		t.ok(message.match(/should be Object/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, name correct, position correct, pointed_at correct, next undefined", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:"test", position:{x:0, y:0}, pointed_at:{}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'next'/), "tells you what's wrong");
		t.ok(message.match(/should be function/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] incorrect, argument object, name correct, position correct, pointed_at correct, next wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		arrow_UI({name:"test", position:{x:0, y:0}, pointed_at:{}, next:"some bad type"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'next'/), "tells you what's wrong");
		t.ok(message.match(/should be function/), "and what type should be");
	}
	
	TEARDOWN();
});

test("[arrow_UI] correct", function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var args = {name:"test", position:{x:0, y:0}, pointed_at:{}, next:function(){}}
	
	//TEST
	var result = arrow_UI(args);
	
	t.ok(check.instanceStrict(result, createjs.Container), "got back a container");
	
	TEARDOWN();
});

test('[arrow_UI._make_arrow], correct', function (t) {
	t.plan(4);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	var mock_this = {
		_createjs : primitives.get('createjs'),
	};
	
	//TEST
	var result = arrow_UI.prototype._make_arrow.call(mock_this, "test");
	
	t.ok(check.instanceStrict(result, createjs.Container), "got back a container");
	t.ok(check.instanceStrict(result.children[0], createjs.Container), "first child is the container holding the arrow");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child is the label");
	t.equal(result.children[1].text, "test", "and the label should be the string we passed");
	
	TEARDOWN();
});

test('[arrow_UI._decorate], correct', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	var mock_arrow = {
		x : undefined,
		y : undefined,
	};
	var mock_options = {
		name: "test",
		position: {x:0, y:0},
		pointed_at:{},
		next:function(){},
	};
	
	//TEST
	var result = arrow_UI.prototype._decorate.call(mock_this, mock_arrow, mock_options);
	
	t.ok(check.object(result), "get back an object");
	t.ok(check.object(result._), "with a _ namespace");
	t.equal(result._.name, "test", "name should be assigned");
	t.equal(result.x, 0, "arrow should be positioned");
	t.equal(result.y, 0, "arrow should be positioned");
	t.deepEqual(mock_options.pointed_at, result._.pointed_at, "arrow should be pointed at something");
	t.ok(check.function(result._.next), "and should have a next() function assigned");
	t.ok(check.object(result._.move), "move should be decorated");
	
	TEARDOWN();
	
	t.end();
});
},{"check-types":6,"lib/UI/arrow_UI":42,"lib/util/primitives":73,"tape":108}],51:[function(require,module,exports){
var lesson_UI = require('lib/UI/lesson_UI');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
	
	var mock_lib = {
		TitleScreen : function() {
			return {
				insert_btn : {
					addEventListener : function() {},
				},
				gotoAndPlay : function() {},
			};
		},
		ArrayScreen : function() {
			return {};
		},
		ArrayElement : function() {
			var ae = new createjs.Shape();
			ae.index_txt = {
				text : '',
			};
			
			return ae;
		},
	};
	
	primitives.set('lib', mock_lib);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test("[lesson_UI] incorrect, 'stage' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('stage', '');
	
	//TEST
	try {
		lesson_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/stage/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[lesson_UI] incorrect, 'stage' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('stage');
	
	//TEST
	try {
		lesson_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/stage/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[lesson_UI] incorrect, 'lib' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('lib', '');
	
	//TEST
	try {
		lesson_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/lib/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[lesson_UI] incorrect, 'lib' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('lib');
	
	//TEST
	try {
		lesson_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/lib/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[lesson_UI] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		lesson_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[lesson_UI] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('createjs');
	
	//TEST
	try {
		lesson_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test('[lesson_UI._setup_title_screen] correct', function (t) {
	t.plan(4);
	
	//SETUP
	var mock_lib = {
		TitleScreen : function() {
			return {};
		},
	};
	
	var add_child_called = false;
	var mock_this = {
		_title_screen : undefined,
		_stage : {
			addChild : function() {
				add_child_called = true;
			}
		},
		_lib : mock_lib,
	};
	
	//TEST
	lesson_UI.prototype._setup_title_screen.call(mock_this);
	
	t.ok(check.object(mock_this._title_screen), 'a title screen object was defined');
	t.ok(check.not.undefined(mock_this._title_screen.x), 'defined the x');
	t.ok(check.not.undefined(mock_this._title_screen.y), 'and the y');
	t.ok(add_child_called, 'added the title screen to the stage');
});

test('[lesson_UI._setup_start_button] correct', function (t) {
	t.plan(2);
	
	//SETUP
	var addEventListener_called = false;
	var mock_this = {
		_title_screen : {
			insert_btn : {
				addEventListener : function() {
					addEventListener_called = true;
				},
			},
			
		},
	};
	
	//TEST
	lesson_UI.prototype._setup_start_button.call(mock_this);
	
	t.ok(check.object(mock_this._start_button), 'made a local reference to the inesrt button on the title screen');
	t.ok(addEventListener_called, 'put an event listener on the insert button');
});

test('[lesson_UI._setup_array_screen] correct', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_lib = {
		ArrayScreen : function() {
			return {};
		},
	};
	
	var mock_this = {
		_lib : mock_lib,
	};
	
	//TEST
	lesson_UI.prototype._setup_array_screen.call(mock_this);
	
	t.ok(check.object(mock_this._array_screen), 'made a new array screen object');
	t.ok(check.not.undefined(mock_this._array_screen.x), 'defined the x');
	t.ok(check.not.undefined(mock_this._array_screen.y), 'and the y');
});

test('[lesson_UI] correct', function (t) {
	//SETUP
	var children = [];
	var mock_createjs = {
		Container : function() {
			return {
				children : children,
				addChild : function(child) {
					children.push(child);
				},
				setBounds : function(x, y, width, height) {},
			};
		},
		Text : function() {
			return {
				x : undefined,
				y : undefined,
			};
		},
	};
	var mock_lib = {
		TitleScreen : function() {
			return {
				insert_btn : {
					addEventListener : function() {},
				},
				gotoAndPlay : function() {},
			};
		},
		ArrayScreen : function() {
			return {};
		},
		ArrayElement : function() {
			var ae = new createjs.Shape();
			ae.index_txt = {
				text : '',
			};
			
			return ae;
		},
	};
	var mock_stage = {
		addChild : function() {},
	};
	
	var primitives = require("lib/util/primitives");
	
	primitives.set('createjs', createjs);
	primitives.set('stage', mock_stage);
	primitives.set('lib', mock_lib);
	
	//TEST
	var ui = lesson_UI();
	
	for (property in ui) {
		if (property === "_text_input") {
			t.ok(check.undefined(ui[property]), String(property) + " is undefined until first call of next()");
			continue;
		}
		
		if (property === "_insert_button") {
			t.ok(check.undefined(ui[property]), String(property) + " is undefined until first call of next()");
			continue;
		}
		
		/* if (property === "_tail_arrow") {
			t.ok(check.undefined(ui[property]), String(property) + " is undefined until first call of next()");
			continue;
		} */
		
		if (property === "_next_button") {
			t.ok(check.undefined(ui[property]), String(property) + " is undefined until first call of next()");
			continue;
		}
		
		t.ok(check.not.undefined(ui[property]), String(property) + " is defined");
	}
	
	t.equal(ui._state, ui._PRE_LESSON, 'in the correct state after setup');
	
	TEARDOWN();
	
	t.end();
});

test('[lesson_UI.next] INIT state', function (t) {
	t.plan(6);
	
	//SETUP
	var _title_screen_gotoAndPlay_called = false;
	var _array_screen_gotoAndPlay_called = false;
	var _array_screen_addChild_called = false;
	var _stage_addChild_called = false;
	var next_called = false;
	var mock_this = {
		_INIT : 0,
		_PRE_LESSON : 1,
		_LESSON : 2,
		_state : undefined,
		
		_title_screen : {
			gotoAndPlay : function() {
				_title_screen_gotoAndPlay_called = true;
			},
		},
		next : function() {
			next_called = true;
		},
		_array_screen : {
			gotoAndPlay : function() {
				_array_screen_gotoAndPlay_called = true;
			},
			addChild : function() {
				_array_screen_addChild_called = true;
			},
		},
		_stage : {
			addChild : function() {
				_stage_addChild_called = true;
			},
		},
	};
	mock_this._state = mock_this._INIT;
	
	//TEST
	var result = lesson_UI.prototype.next.call(mock_this);
	
	//should not change state on INIT
	t.notOk(_title_screen_gotoAndPlay_called);
	t.notOk(_array_screen_gotoAndPlay_called);
	t.notOk(_array_screen_addChild_called);
	t.notOk(_stage_addChild_called);
	t.notOk(next_called);
	t.equal(mock_this._state, lesson_UI.prototype._INIT);
});

test('[lesson_UI.next] _PRE_LESSON state', function (t) {
	t.plan(6);
	
	//SETUP
	var _title_screen_gotoAndPlay_called = false;
	var _array_screen_gotoAndPlay_called = false;
	var _array_screen_addChild_called = false;
	var _stage_addChild_called = false;
	var next_called = false;
	var mock_this = {
		_INIT : 0,
		_PRE_LESSON : 1,
		_LESSON : 2,
		_state : undefined,
		
		_title_screen : {
			gotoAndPlay : function() {
				_title_screen_gotoAndPlay_called = true;
			},
		},
		next : function() {
			next_called = true;
		},
		_array_screen : {
			gotoAndPlay : function() {
				_array_screen_gotoAndPlay_called = true;
			},
			addChild : function() {
				_array_screen_addChild_called = true;
			},
		},
		_stage : {
			addChild : function() {
				_stage_addChild_called = true;
			},
		},
		_setup_text_input : function() {},
		_setup_insert_button : function() {},
		_setup_next_button : function() {},
		_setup_tail_arrow : function() {},
		_setup_text_output : function() {},
	};
	mock_this._state = mock_this._LESSON;
	
	//TEST
	var result = lesson_UI.prototype.next.call(mock_this);
	
	t.notOk(_title_screen_gotoAndPlay_called, 'closing the title screen');
	t.ok(_array_screen_gotoAndPlay_called);
	t.ok(_array_screen_addChild_called);
	t.ok(_stage_addChild_called);
	t.notOk(next_called);
	t.equal(mock_this._state, lesson_UI.prototype._LESSON);
});

test('[lesson_UI._setup_text_input] correct', function (t) {
	//SETUP
	SETUP();
	
	var _array_screen_addChild_called = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				_array_screen_addChild_called = true;
			},
		},
		_text_input : undefined,
	};
	
	//TEST
	var canvas_container = document.getElementById('canvas_container');
	t.equal(canvas_container.childNodes.length, 3, "this is three for some reason");
	
	lesson_UI.prototype._setup_text_input.call(mock_this);
	
	t.equal(canvas_container.childNodes.length, 4, "then one larger once we add the text input");
	
	t.ok(_array_screen_addChild_called, "added text input to array screen");
	
	t.ok(check.not.undefined(mock_this._text_input), "saw the refrence to the text input");
	
	t.ok(mock_this._text_input.x !== 0, "positioned, x property");
	t.ok(mock_this._text_input.y !== 0, "positioned, y property");
	
	TEARDOWN();
	
	t.end();
});

test('[lesson_UI._setup_text_input -> get] correct', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {
		_array_screen : {
			addChild : function() {},
		},
		_text_input : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_input.call(mock_this);
	t.ok(check.function(mock_this._text_input._.get), 'get value should be set');
	
	TEARDOWN();
});

test('[lesson_UI._setup_text_input -> get], correct default', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {
		_array_screen : {
			addChild : function() {},
		},
		_text_input : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_input.call(mock_this);
	t.ok(Number.isNaN(mock_this._text_input._.get()), 'the text input should be empty, so an empty string should be NaN');
	
	TEARDOWN();
});

test('[lesson_UI._setup_text_input -> get], correct, number input', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {
		_array_screen : {
			addChild : function() {},
		},
		_text_input : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_input.call(mock_this);
	
	mock_this._text_input.children[0].htmlElement.value = 2;
	
	t.equal(mock_this._text_input._.get(), 2, 'should get back 2');
	
	TEARDOWN();
});

test('[lesson_UI._setup_text_input -> get], incorrect, string', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {
		_array_screen : {
			addChild : function() {},
		},
		_text_input : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_input.call(mock_this);
	
	mock_this._text_input.children[0].htmlElement.value = 'a';
	
	t.ok(Number.isNaN(mock_this._text_input._.get()), 'shold get back NaN on non-numeric input');
	
	TEARDOWN();
});

test('[lesson_UI._setup_text_input -> get], incorrect, undefined', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {
		_array_screen : {
			addChild : function() {},
		},
		_text_input : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_input.call(mock_this);
	
	mock_this._text_input.children[0].htmlElement.value = undefined;
	
	t.ok(Number.isNaN(mock_this._text_input._.get()), 'shold get back NaN on non-numeric input');
	
	TEARDOWN();
});

test('[lesson_UI._setup_text_input -> set], correct', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {
		_array_screen : {
			addChild : function() {},
		},
		_text_input : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_input.call(mock_this);
	
	mock_this._text_input._.set('some value');
	
	t.equal(mock_this._text_input.children[0].htmlElement.value, 'some value', "should see 'some value' as the text in the text input");
	
	//t.ok(Number.isNaN(mock_this._text_input._.get_text_input_value()), 'shold get back NaN on non-numeric input');
	
	TEARDOWN();
});

test('[lesson_UI._setup_text_input -> clear], correct', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {
		_array_screen : {
			addChild : function() {},
		},
		_text_input : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_input.call(mock_this);
	
	mock_this._text_input.children[0].htmlElement.value = "some mock value";
	mock_this._text_input._.clear();
	
	t.equal(mock_this._text_input.children[0].htmlElement.value, '', "input should be empty after a clear");
	
	TEARDOWN();
});

test('[lesson_UI._setup_insert_button], correct', function (t) {
	t.plan(2);
	
	//SETUP
	SETUP();
	
	var called_addChild = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				called_addChild = true;
			},
		},
		_insert_button : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_insert_button.call(mock_this);
	
	t.ok(called_addChild, "added the insert button to the array_screen");
	t.ok(check.object(mock_this._insert_button), "created the insert button");
	
	TEARDOWN();
});

test('[lesson_UI._setup_insert_button], correct, properties set on _insert_button', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var called_addChild = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				called_addChild = true;
			},
		},
		_insert_button : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_insert_button.call(mock_this);
	
	t.ok(mock_this._insert_button.x !== 0, "x property set");
	t.ok(mock_this._insert_button.y !== 0, "y property set");
	t.ok(check.object(mock_this._insert_button._.pub_sub), "decorated pub_sub");
	
	TEARDOWN();
});

test('[lesson_UI._setup_insert_button], correct, testing pub_sub', function (t) {
	t.plan(2);
	
	//SETUP
	SETUP();
	
	var called_addChild = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				called_addChild = true;
			},
		},
		_insert_button : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_insert_button.call(mock_this);
	
	var pub_sub = mock_this._insert_button._.pub_sub;
	
	pub_sub.subscribe("click", function(msg) {
		t.ok(true, "saw a click event");
		t.equal("click.insert_button", msg, "click event from the insert button");
		
		TEARDOWN();
		pub_sub.clearAllSubscriptions();
	});
	
	mock_this._insert_button.children[0].dispatchEvent(new createjs.Event("click"));
});

test('[lesson_UI._setup_next_button], correct', function (t) {
	t.plan(2);
	
	//SETUP
	SETUP();
	
	var called_addChild = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				called_addChild = true;
			},
		},
		_next_button : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_next_button.call(mock_this);
	
	t.ok(called_addChild, "added the next button to the array_screen");
	t.ok(check.object(mock_this._next_button), "created the next button");
	
	TEARDOWN();
});

test('[lesson_UI._setup_next_button], correct, properties set on _insert_button', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var called_addChild = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				called_addChild = true;
			},
		},
		_next_button : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_next_button.call(mock_this);
	
	t.ok(mock_this._next_button.x !== 0, "x property set");
	t.ok(mock_this._next_button.y !== 0, "y property set");
	t.ok(check.object(mock_this._next_button._.pub_sub), "decorated pub_sub");
	
	TEARDOWN();
});

test('[lesson_UI._setup_next_button], correct, testing pub_sub', function (t) {
	t.plan(2);
	
	//SETUP
	SETUP();
	
	var called_addChild = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				called_addChild = true;
			},
		},
		_next_button : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_next_button.call(mock_this);
	
	var pub_sub = mock_this._next_button._.pub_sub;
	
	pub_sub.subscribe("click", function(msg) {
		t.ok(true, "saw a click event");
		t.equal("click.next_button", msg, "click event from the next button");
		
		TEARDOWN();
		pub_sub.clearAllSubscriptions();
	});
	
	mock_this._next_button.children[0].dispatchEvent(new createjs.Event("click"));
});

test('[lesson_UI._setup_text_output], correct', function (t) {
	t.plan(8);
	
	//SETUP
	SETUP();
	
	var called_addChild = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				called_addChild = true;
			},
		},
		_next_button : {
			x : 0,
			y : 1,
			getBounds : function() {
				return {
					height : 1,
				};
			}
		},
		_text_output : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_output.call(mock_this);
	
	t.ok(called_addChild, "added to array_screen");
	t.ok(check.instanceStrict(mock_this._text_output, createjs.Text), "should get back a Text object");
	t.ok(mock_this._text_output.x !== 0, "should be positioned, x");
	t.ok(mock_this._text_output.y !== 0, "should be positioned, y");
	t.ok(check.object(mock_this._text_output._), "should have the '_' namespace");
	t.ok(check.function(mock_this._text_output._.set), "decorated convenience method, set");
	t.ok(check.function(mock_this._text_output._.get), "decorated convenience method, get");
	t.ok(check.function(mock_this._text_output._.clear), "decorated convenience method, clear");
	
	TEARDOWN();
});

test('[lesson_UI._setup_text_output -> methods], correct', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var called_addChild = false;
	var mock_this = {
		_array_screen : {
			addChild : function() {
				called_addChild = true;
			},
		},
		_next_button : {
			x : 0,
			y : 1,
			getBounds : function() {
				return {
					height : 1,
				};
			}
		},
		_text_output : undefined,
	};
	
	//TEST
	lesson_UI.prototype._setup_text_output.call(mock_this);
	
	mock_this._text_output.text = "some string";
	
	t.equal(mock_this._text_output._.get(), "some string", "get() works");
	
	mock_this._text_output._.set('some other string');
	
	t.equal(mock_this._text_output._.get(), 'some other string', "set() works");
	
	mock_this._text_output._.clear();
	
	t.equal(mock_this._text_output._.get(), '', "clear() works");
	
	TEARDOWN();
});

test('[lesson_UI._setup_array] correct', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//TEST
	lesson_UI.prototype._setup_array.call(mock_this);
	
	t.ok(check.object(mock_this._array), 'made a new array object');
	t.ok(check.object(mock_this._tail_arrow), 'made a new arrow object');
	t.ok(check.not.undefined(mock_this._array.x), 'defined the x');
	t.ok(check.not.undefined(mock_this._array.y), 'and the y');
	
	TEARDOWN();
	
	t.end();
});

test('[lesson_UI._text_input_to_canvas] correct', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {
		_state : undefined,
		_INIT : 0,
		_PRE_LESSON : 1,
		_LESSON : 2,
		
		_text_input : {
			_ : {
				get : function() {
					return "0";
				},
				clear : function() {},
			},
			x : 0,
			y : 0,
		},
	};
	mock_this._state = mock_this._LESSON;
	
	//TEST
	var result = lesson_UI.prototype._text_input_to_canvas.call(mock_this);
	
	t.ok(check.instanceStrict(result, createjs.Text), "got back a Text object");
	t.equal(result.text, "0", "its value matches what was taken from the text input")
	t.equal(result.x, mock_this._text_input.x, "should be positioned under the text input");
	t.ok(result.y > mock_this._text_input.y, "should be positioned under the text input");
	
	TEARDOWN();
	
	t.end();
});

test('[lesson_UI._text_input_to_canvas] incorrect, bad input', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {
		_state : undefined,
		_INIT : 0,
		_PRE_LESSON : 1,
		_LESSON : 2,
		
		_text_input : {
			_ : {
				get : function() {
					return Number.NaN;
				},
				clear : function() {},
			},
			x : 0,
			y : 0,
		},
	};
	mock_this._state = mock_this._LESSON;
	
	//TEST
	var result = lesson_UI.prototype._text_input_to_canvas.call(mock_this);
	
	t.ok(check.undefined(result), "saw bad input, so does nothing");
	
	TEARDOWN();
	
	t.end();
});

test('[lesson_UI._text_input_to_canvas] incorrect, wrong state', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {
		_state : undefined,
		_INIT : 0,
		_PRE_LESSON : 1,
		_LESSON : 2,
		
		_text_input : {
			_ : {
				get : function() {
					return Number.NaN;
				},
				clear : function() {},
			},
			x : 0,
			y : 0,
		},
	};
	//mock_this._state = mock_this._LESSON;
	
	//TEST
	var result = lesson_UI.prototype._text_input_to_canvas.call(mock_this);
	
	t.ok(check.undefined(result), "wrong state, so does nothing");
	
	TEARDOWN();
	
	t.end();
});

test('[lesson_UI.get_proxy] incorrect, wrong state', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {
		_state : undefined,
		_INIT : 0,
		_PRE_LESSON : 1,
		_LESSON : 2,
	};
	//mock_this._state = mock_this._LESSON;
	
	//TEST
	var result = lesson_UI.prototype.get_proxy.call(mock_this);
	
	t.ok(check.undefined(result), "wrong state, so does nothing");
	
	TEARDOWN();
	
	t.end();
});

//tail
},{"check-types":6,"lib/UI/lesson_UI":43,"lib/util/primitives":73,"tape":108}],52:[function(require,module,exports){
var arrow_factory = require('lib/factory/arrow_factory');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[arrow_factory.arrow] correct, defaults', function (t) {
	t.plan(2);
	
	SETUP();
	
	var af = arrow_factory();
	
	t.deepEqual(af._arrow_options, {length: 20, width: 12, color: 'red', angle: 0});
	
	af.arrow();
	
	t.deepEqual(af._arrow_options, {length: 20, width: 12, color: 'red', angle: 0});
	
	TEARDOWN();
});

test('[arrow_factory.arrow] incorrect, angle', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	
	try {
		af.arrow({angle:''});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/angle/), 'error should include variable with incorrect type');
		t.ok(message.match(/number/), 'and should report what type it should be');
	}
	
	TEARDOWN();
});

test('[arrow_factory.arrow] incorrect, length, wrong type', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	
	try {
		af.arrow({length:''});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/length/), 'error should include variable with incorrect type');
		t.ok(message.match(/number/), 'and should report what type it should be');
	}
	
	TEARDOWN();
});

test('[arrow_factory.arrow] incorrect, length, wrong value', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	
	try {
		af.arrow({length:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/length/), 'error should include variable with incorrect type');
		t.ok(message.match(/should be greater than zero/));
	}
	
	TEARDOWN();
});

test('[arrow_factory.arrow] incorrect, direction, wrong type', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	
	try {
		af.arrow({direction:1});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/direction/), 'error should include variable with incorrect type');
		t.ok(message.match(/string/), 'and should report what type it should be');
	}
	
	TEARDOWN();
});

test('[arrow_factory.arrow] incorrect, direction, wrong value', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	
	try {
		af.arrow({direction:"some bad direction"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/direction/), 'error should include variable with incorrect type');
		t.ok(message.match(/one of these/), 'and should report what type it should be');
	}
	
	TEARDOWN();
});

test('[arrow_factory.arrow] incorrect, direction and angle defined together', function (t) {
	t.plan(4);
	
	SETUP();
	
	var af = arrow_factory();
	
	try {
		af.arrow({direction:"left", angle:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, Error), 'we should get back an Error');
		var message = error.toString();
		t.ok(message.match(/direction/), 'error should include variable with incorrect type');
		t.ok(message.match(/angle/), 'error should include variable with incorrect type');
		t.ok(message.match(/defined at the same time/));
	}
	
	TEARDOWN();
});

test('[arrow_factory.arrow] correct, angle defined', function (t) {
	t.plan(1);
	
	SETUP();
	
	var af = arrow_factory();
	
	af.arrow({angle:90});
	
	t.deepEqual(af._arrow_options, {length: 20, width: 12, color: 'red', angle: -90});
	
	TEARDOWN();
});

test('[arrow_factory.arrow] correct, direction defined and of the right type', function (t) {
	t.plan(1);
	
	SETUP();
	
	var af = arrow_factory();
	
	af.arrow({direction:'right'});
	
	t.deepEqual(af._arrow_options, {length: 20, width: 12, color: 'red', angle: -180});
	
	TEARDOWN();
});

test('[arrow_factory._get_tip] correct, defaults', function (t) {
	t.plan(2);
	
	SETUP();
	
	var af = arrow_factory();
	af._arrow_options = {length: 20, width: 12, color: 'red', angle: -180};
	var result = af._get_tip();
	
	//individual commands making up the stroke are buried in private variables
	//but we can test for where the "drawing cursor" stopped at the end of its last move
	t.equal(result.graphics.command.x, 6);
	t.equal(result.graphics.command.y, 6);
	
	TEARDOWN();
});

test('[arrow_factory._get_tip] correct, width is non-default', function (t) {
	t.plan(2);
	
	SETUP();
	
	var af = arrow_factory();
	af._arrow_options = {length: 20, width: 20, color: 'red', angle: -180};
	var result = af._get_tip();
	
	t.equal(result.graphics.command.x, 10);
	t.equal(result.graphics.command.y, 10);
	
	TEARDOWN();
});

test('[arrow_factory._get_line] correct, defaults', function (t) {
	t.plan(2);
	
	SETUP();
	
	var af = arrow_factory();
	var result = af._get_line();
	
	t.equal(result.graphics.command.x, 20);
	t.equal(result.graphics.command.y, 0);
	
	TEARDOWN();
});

test('[arrow_factory._get_line] correct, non-defaults', function (t) {
	t.plan(2);
	
	SETUP();
	
	var af = arrow_factory();
	af._arrow_options = {length: 5, width: 12, color: 'red', angle: -180};
	var result = af._get_line();
	
	
	t.equal(result.graphics.command.x, 5);
	t.equal(result.graphics.command.y, 0);
	
	TEARDOWN();
});

test('[arrow_factory._set_props] correct, defaults', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	var container = new createjs.Container();
	var result = af._set_props(container);
	
	t.equal(result.rotation, 0);
	t.equal(result.x, 0);
	t.equal(result.y, 0);
	
	TEARDOWN();
});

test('[arrow_factory._set_props] correct, passed in options', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	var container = new createjs.Container();
	var result = af._set_props(container, {x:1, y:1});
	
	t.equal(result.rotation, 0);
	t.equal(result.x, 1);
	t.equal(result.y, 1);
	
	TEARDOWN();
});

test('[arrow_factory._set_props] correct, passed in options + angle set ', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	var container = new createjs.Container();
	af._arrow_options = {length: 5, width: 12, color: 'red', angle: 20};
	var result = af._set_props(container, {x:1, y:1});
	
	t.equal(result.rotation, 20);
	t.equal(result.x, 1);
	t.equal(result.y, 1);
	
	TEARDOWN();
});

test('[arrow_factory._decorate] correct, place', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	var container = new createjs.Container();
	af._arrow_options = {length: 5, width: 12, color: 'red', angle: 20};
	var result = af._decorate(container);
	
	t.ok(check.object(result._));
	t.ok(check.object(result._.place));
	t.ok(check.function(result._.place.above));
	//t.deepEqual(result.getBounds(), {x:0, y:0, width:5, height:12});
	
	TEARDOWN();
});

test('[arrow_factory._decorate] correct, bounds', function (t) {
	t.plan(1);
	
	SETUP();
	
	var af = arrow_factory();
	var container = new createjs.Container();
	af._arrow_options = {length: 5, width: 12, color: 'red', angle: 20};
	var result = af._decorate(container);
	
	t.deepEqual(result.getBounds(), {x:0, y:0, width:5, height:12});
	
	TEARDOWN();
});

test('[arrow_factory._decorate] correct, add_to_stage', function (t) {
	t.plan(2);
	
	SETUP();
	
	var af = arrow_factory();
	var container = new createjs.Container();
	af._arrow_options = {length: 5, width: 12, color: 'red', angle: 20};
	var result = af._decorate(container);
	
	t.ok(check.object(result._));
	t.ok(check.function(result._.add_to_stage));
	
	TEARDOWN();
});

test('[arrow_factory.get] integration testing: correct, defaults', function (t) {
	t.plan(8);
	
	SETUP();
	
	var af = arrow_factory();
	var result = af.get();
	
	t.equal(result.children.length, 2, "we should see two child Shapes");
	//this should be the arrow head
	t.equal(result.children[0].graphics.command.x, 6);
	t.equal(result.children[0].graphics.command.y, 6);
	
	//this should be the line
	t.equal(result.children[1].graphics.command.x, 20);
	t.equal(result.children[1].graphics.command.y, 0);
	
	//and the entire figure should be at the default location
	t.equal(result.x, 0);
	t.equal(result.y, 0);

	t.equal(result.rotation, 0, "...and the rotation should be set to the default");
	
	TEARDOWN();
});

test('[arrow_factory.get] integration testing: correct, non-defaults', function (t) {
	t.plan(8);
	
	SETUP();
	
	var af = arrow_factory();
	af.arrow({length:10, width:10, angle:20});
	var result = af.get({x:1, y:1});
	
	t.equal(result.children.length, 2, "we should see two child Shapes");
	//this should be the arrow head
	t.equal(result.children[0].graphics.command.x, 5);
	t.equal(result.children[0].graphics.command.y, 5);
	
	//this should be the line
	t.equal(result.children[1].graphics.command.x, 10);
	t.equal(result.children[1].graphics.command.y, 0);
	
	//and the entire figure should be at the set location
	t.equal(result.x, 1);
	t.equal(result.y, 1);

	t.equal(result.rotation, -20, "...and the rotation should be set");
	
	TEARDOWN();
});

test('[arrow_factory.get] integration testing: correct, non-defaults, multiple arrows', function (t) {
	//t.plan(8);
	
	SETUP();
	
	var af = arrow_factory();
	af.arrow({length:10, width:10, angle:20});
	var result = af.get({x:1, y:1});
	
	t.equal(result.children.length, 2, "we should see two child Shapes");
	//this should be the arrow head
	t.equal(result.children[0].graphics.command.x, 5);
	t.equal(result.children[0].graphics.command.y, 5);
	
	//this should be the line
	t.equal(result.children[1].graphics.command.x, 10);
	t.equal(result.children[1].graphics.command.y, 0);
	
	//and the entire figure should be at the set location
	t.equal(result.x, 1);
	t.equal(result.y, 1);

	t.equal(result.rotation, -20, "...and the rotation should be set");
	
	var result2 = af.get({x:2, y:2});
	
	t.equal(result2.children.length, 2, "we should see two child Shapes");
	//this should be the arrow head
	t.equal(result2.children[0].graphics.command.x, 5);
	t.equal(result.children[0].graphics.command.y, 5);
	
	//this should be the line
	t.equal(result2.children[1].graphics.command.x, 10);
	t.equal(result2.children[1].graphics.command.y, 0);
	
	//and the entire figure should be at the set location
	t.equal(result2.x, 2);
	t.equal(result2.y, 2);

	t.equal(result.rotation, -20, "...and the rotation should be set");
	
	af.arrow({length:20, width:20, angle:45});
	var result3 = af.get();
	
	t.equal(result3.children.length, 2, "we should see two child Shapes");
	//this should be the arrow head
	t.equal(result3.children[0].graphics.command.x, 10);
	t.equal(result3.children[0].graphics.command.y, 10);
	
	//this should be the line
	t.equal(result3.children[1].graphics.command.x, 20);
	t.equal(result3.children[1].graphics.command.y, 0);
	
	//and the entire figure should be at the set location
	t.equal(result3.x, 2);
	t.equal(result3.y, 2);

	t.equal(result3.rotation, -45, "...and the rotation should be set");
	
	TEARDOWN();
	t.end();
});

test('[arrow_factory.get] bounds testing, defaults', function (t) {
	t.plan(4);
	
	SETUP();
	
	var af = arrow_factory();
	var result = af.get();
	
	var bounds = result.getBounds();
	
	t.equal(bounds.x, 0);
	t.equal(bounds.y, 0);
	t.equal(bounds.width, 20);
	t.equal(bounds.height, 12);
	
	TEARDOWN();
});

test('[arrow_factory.get] bounds testing, non-defaults', function (t) {
	t.plan(4);
	
	SETUP();
	
	var af = arrow_factory();
	af.arrow({length:25, width:50});
	var result = af.get();
	
	var bounds = result.getBounds();
	
	t.equal(bounds.x, 0);
	t.equal(bounds.y, 0);
	t.equal(bounds.width, 25);
	t.equal(bounds.height, 50);
	
	TEARDOWN();
});

test('[arrow_factory.get] place test', function (t) {
	t.plan(3);
	
	SETUP();
	
	var af = arrow_factory();
	var result = af.get();
	
	t.ok(result._.place);
	t.ok(result._.place.below);
	t.ok(check.function(result._.place.below));
	
	TEARDOWN();
});

test("[arrow_factory] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//TEST
	try {
		arrow_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		console.log(message);
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[arrow_factory] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		arrow_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

/* test('[arrow_factory.get_arrow_between] incorrect, bad argument', function (t) {
	t.plan(2);
	
	var af = arrow_factory();
	
	try {
		af.get_arrow_between([2, "bad"], ["2", 3]);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/\[x, y\] \(where x and y are numbers\)/), 'shows correct form of the argument');
	}
});

test('[arrow_factory.get_arrow_between] incorrect, no arguments', function (t) {
	t.plan(2);
	
	var af = arrow_factory();
	
	try {
		af.get_arrow_between();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/\[x, y\] \(where x and y are numbers\)/), 'shows correct form of the argument');
	}
}); */
},{"check-types":6,"lib/factory/arrow_factory":44,"lib/util/primitives":73,"tape":108}],53:[function(require,module,exports){
var html_factory = require('lib/factory/html_factory');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[html_factory._get_text] correct, default should be empty string', function (t) {
	t.plan(1);
	
	SETUP();
	
	var hf = html_factory();
	var result = hf._get_text();
	
	t.equal(result.text, '');
	
	TEARDOWN();
});

test('[html_factory.html] incorrect, did not pass "type" option', function (t) {
	t.plan(2);
	
	SETUP();
	
	var hf = html_factory();
	try {
		hf.html({});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/argument \'type\' is required/), 'argument should include "type"');
	}
	
	TEARDOWN();
});

test('[html_factory.html] incorrect, "type" passed, but unknown', function (t) {
	t.plan(2);
	
	SETUP();
	
	var hf = html_factory();
	try {
		hf.html({type:"some wrong type"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/argument \'type\' was unsupported/), 'argument should include "type"');
	}
	
	TEARDOWN();
});

test('[html_factory.html] correct, "type" passed, id generated', function (t) {
	t.plan(3);
	
	SETUP();
	
	var hf = html_factory();
	hf.html({type:"radio"});
	t.equal(hf._html_options.type, "radio", "should have the radio option set");
	t.ok(hf._html_options.id.match(/^radio/), "id should begin with the type...");
	t.ok(hf._html_options.id.match(/(\d+)$/)[1], "...and end with a number");
	
	TEARDOWN();
});

test('[html_factory.html] correct, "type" passed, id passed', function (t) {
	t.plan(2);
	
	SETUP();
	
	var hf = html_factory();
	hf.html({type:"radio", id:1});
	t.equal(hf._html_options.type, "radio", "should have the radio option set");
	t.equal(hf._html_options.id, "1", "should have an id");
	
	TEARDOWN();
});

test('[html_factory.html] incorrect, option "label" set but type is not button', function (t) {
	t.plan(3);
	
	SETUP();
	
	var hf = html_factory();
	try {
		hf.html({type:"radio", label:"some label"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/label/));
		t.ok(message.match(/button/));
	}
	
	TEARDOWN();
});

test('[html_factory._get_html] correct', function (t) {
	t.plan(2);
	
	SETUP();
	
	var hf = html_factory();
	hf._html_options.type = "radio";
	hf._html_options.id = "1";
	
	
	var result = hf._get_html();
	t.equal(result.type, "radio", "should have the radio option set");
	t.equal(result.id, "1", "should have an id");
	
	TEARDOWN();
});

//NOTE: using 'value' instead of 'label' property on buttons, as per poor documentation on MDN
test('[html_factory._get_html] correct, label', function (t) {
	t.plan(1);
	
	SETUP();
	
	var hf = html_factory();
	hf._html_options.type = "button";
	hf._html_options.label = 'some label';
	
	var result = hf._get_html();
	t.equal(result.value, 'some label');
	
	TEARDOWN();
});

test('[html_factory._get_html] correct, label (not string)', function (t) {
	t.plan(1);
	
	SETUP();
	
	var hf = html_factory();
	hf._html_options.type = "button";
	hf._html_options.label = 0;
	
	var result = hf._get_html();
	t.equal(result.value, '0');
	
	TEARDOWN();
});

test('[html_factory._get_dom_element] correct', function (t) {
	t.plan(3);
	
	SETUP();
	
	var hf = html_factory();
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	var result = hf._get_dom_element(html);
	
	t.ok(check.instanceStrict(result, createjs.DOMElement), 'should get back a createjs.DOMElement');
	t.equal(result.htmlElement.type, 'radio', 'radio type input element');
	t.equal(result.htmlElement.id, '1', 'id should be set');
	
	TEARDOWN();
});

test('[html_factory._bundle] correct', function (t) {
	t.plan(6);
	
	SETUP();
	
	var hf = html_factory();
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	var de = new createjs.DOMElement(html);
	
	var text = new createjs.Text('some string');
	
	var result = hf._bundle(de, text);
	
	t.ok(check.instanceStrict(result, createjs.Container), 'should get back a createjs.Container');
	t.equal(result.children.length, 2);
	t.deepEqual(result.children[0], de);
	t.deepEqual(result.children[1], text);
	t.deepEqual(result._.htmlElement, html);
	t.equal(result._.text, 'some string');
	
	TEARDOWN();
});

test('[html_factory._bundle] correct', function (t) {
	t.plan(6);
	
	SETUP();
	
	var hf = html_factory();
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	var de = new createjs.DOMElement(html);
	
	var text = new createjs.Text('some string');
	
	var result = hf._bundle(de, text);
	
	t.ok(check.instanceStrict(result, createjs.Container), 'should get back a createjs.Container');
	t.equal(result.children.length, 2);
	t.deepEqual(result.children[0], de);
	t.deepEqual(result.children[1], text);
	t.deepEqual(result._.htmlElement, html);
	t.equal(result._.text, 'some string');
	
	TEARDOWN();
});

test('[html_factory._decorate] correct', function (t) {
	t.plan(2);
	
	SETUP();
	
	var container = new createjs.Container();
	
	container._ = {};
	
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	container._.htmlElement = html;
	
	var hf = html_factory();
	var result = hf._decorate(container);
	
	t.ok(result._.append_to, "the decorated method was applied to the container");
	t.ok(check.function(result._.append_to), "...and that it's a method");
	
	TEARDOWN();
});

test('[html_factory._decorate.append_to] correct', function (t) {
	t.plan(3);
	
	SETUP();
	
	var container = new createjs.Container();
	
	container._ = {};
	
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	container._.htmlElement = html;
	
	var hf = html_factory();
	var result = hf._decorate(container);
	
	var target = document.createElement('div');
	
	result._.append_to(target);
	
	t.ok(target.hasChildNodes(), "the div we created should now have children");
	t.equal(target.childNodes.length, 1, "...there should be only one child");
	t.deepEqual(target.childNodes[0], html, "...and the child should be the HTML we made");
	
	TEARDOWN();
});

test('[html_factory._decorate.append_to] incorrect, bad argument', function (t) {
	t.plan(2);
	
	SETUP();
	
	var container = new createjs.Container();
	
	container._ = {};
	
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	container._.htmlElement = html;
	
	var hf = html_factory();
	var result = hf._decorate(container);
	
	var target = document.createElement('div');
	
	try {
		result._.append_to("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/HTML Element/), '...we should want an HTML element');
	}
	
	TEARDOWN();
});

test('[html_factory._decorate] correct, add_to_stage', function (t) {
	t.plan(2);
	
	SETUP();
	
	var container = new createjs.Container();
	
	container._ = {};
	
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	container._.htmlElement = html;
	
	var hf = html_factory();
	var result = hf._decorate(container);
	
	t.ok(check.object(result._));
	t.ok(check.function(result._.add_to_stage));
	
	TEARDOWN();
});

test('[html_factory._decorate] correct, name', function (t) {
	t.plan(3);
	
	//setup
	
	SETUP();
	
	var container = new createjs.Container();
	
	container._ = {};
	
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	container._.htmlElement = html;
	
	var hf = html_factory();
	hf._name = "some test name";
	
	var result = hf._decorate(container);
	
	//test
	t.ok(check.object(result._));
	t.ok(check.string(result._.name));
	t.equal(result._.name, "some test name");
	
	TEARDOWN();
});

test('[html_factory._decorate] correct, name unset, but label set', function (t) {
	t.plan(3);
	
	//setup
	
	SETUP();
	
	var container = new createjs.Container();
	
	container._ = {};
	
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	container._.htmlElement = html;
	
	var hf = html_factory();
	hf._html_options.label = 'some test name';
	
	var result = hf._decorate(container);
	
	//test
	t.ok(check.object(result._));
	t.ok(check.string(result._.name));
	t.equal(result._.name, "some test name");
	
	TEARDOWN();
});

test('[html_factory._decorate] correct, name unset, but label set (non-string)', function (t) {
	t.plan(3);
	
	//setup
	
	SETUP();
	
	var container = new createjs.Container();
	
	container._ = {};
	
	var html = document.createElement('input');
	html.type = 'radio';
	html.id = "1";
	
	container._.htmlElement = html;
	
	var hf = html_factory();
	hf._html_options.label = 123456;
	
	var result = hf._decorate(container);
	
	//test
	t.ok(check.object(result._));
	t.ok(check.string(result._.name));
	t.equal(result._.name, "123456");
	
	TEARDOWN();
});

test('[html_factory._set_props] correct, no options', function (t) {
	t.plan(2);
	
	SETUP();
	
	var container = new createjs.Container();
	var hf = html_factory();
	
	var result = hf._set_props(container);
	
	t.equal(result.x, 0);
	t.equal(result.y, 0);
	
	TEARDOWN();
});

test('[html_factory._set_props] correct, user options', function (t) {
	t.plan(2);
	
	SETUP();
	
	var container = new createjs.Container();
	var hf = html_factory();
	
	var result = hf._set_props(container, {x:1, y:1});
	
	t.equal(result.y, 1);
	t.equal(result.x, 1);
	
	TEARDOWN();
});

test('[html_factory.get] correct', function (t) {
	t.plan(8);
	
	SETUP();
	
	var hf = html_factory();
	hf.html({type:'radio'});
	var result = hf.get()
	
	t.ok(result.children, "we should have a container");
	t.equal(result.children.length, 2, "...that has two children");
	t.ok(result.children[0].htmlElement, "...the first child is an HTML element");
	t.ok(check.string(result.children[1].text), "...the second is Text");
	t.deepEqual(result.children[0].htmlElement, result._.htmlElement, "...we should see the HTML exposed in our namespace _");
	t.equal(result.children[1].text, result._.text, "...and the text value exposed in _");
	t.equal(result._.htmlElement.type, 'radio', '...and the type of the HTML input should be "radio"');
	t.ok(check.function(result._.append_to), "...and we can see the apply_to method");
	
	TEARDOWN();
});

test('[html_factory.get] incorrect, bad options', function (t) {
	t.plan(2);
	
	SETUP();
	
	var hf = html_factory();
	hf.html({type:'radio'});
	
	try {
		hf.get("some bad argument")
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'object required');
	}
	
	TEARDOWN();
});

test('[html_factory.get] incorrect, type unset', function (t) {
	t.plan(2);
	
	SETUP();
	
	var hf = html_factory();
	
	try {
		hf.get();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Unknown type of HTML to create/), 'argument should include "type"');
	}
	
	TEARDOWN();
});

test('[html_factory.get] correct, user options', function (t) {
	t.plan(2);
	
	SETUP();
	
	var hf = html_factory();
	hf.html({type:'radio'});
	var result = hf.get({x:1, y:1});
	
	t.equal(result.y, 1);
	t.equal(result.x, 1);
	
	TEARDOWN();
});

test('[html_factory.get] correct, user options, multiple object', function (t) {
	t.plan(6);
	
	SETUP();
	
	var hf = html_factory();
	hf.html({type:'radio'});
	var result1 = hf.get({x:1, y:1});
	
	t.equal(result1.y, 1);
	t.equal(result1.x, 1);
	t.equal(result1._.htmlElement.type, 'radio');
	
	var result2 = hf.get();
	
	t.equal(result2.x, 1);
	t.equal(result2.y, 1);
	t.equal(result2._.htmlElement.type, 'radio');
	
	TEARDOWN();
});

test('[html_factory.get] correct, user options, text set', function (t) {
	t.plan(8);
	
	SETUP();
	
	var hf = html_factory();
	hf.html({type:'radio'});
	hf.text({text:"some string"})
	var result1 = hf.get({x:1, y:1});
	
	t.equal(result1.y, 1);
	t.equal(result1.x, 1);
	t.equal(result1._.htmlElement.type, 'radio');
	t.equal(result1._.text, "some string");
	
	var result2 = hf.get();
	
	t.equal(result2.x, 1);
	t.equal(result2.y, 1);
	t.equal(result2._.htmlElement.type, 'radio');
	t.equal(result2._.text, "some string");
	
	TEARDOWN();
});

test("[html_factory] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//TEST
	try {
		html_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		console.log(message);
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[html_factory] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		html_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});
},{"check-types":6,"lib/factory/html_factory":45,"lib/util/primitives":73,"tape":108}],54:[function(require,module,exports){
var shape_factory = require('lib/factory/shape_factory');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[shape_factory.color] correct, no arguments', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color();
	t.deepEqual({fill:undefined, stroke:null}, sf._color_options, 'internal color variable is default');
	
	TEARDOWN();
});

test('[shape_factory.color] correct, valid color string', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({fill:'#000'});
	t.deepEqual({fill:'#000', stroke:null}, sf._color_options, 'fill option is set on internal color variable');
	
	TEARDOWN();
});

test('[shape_factory.color] correct, valid color string, as alias color', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({color:'#000'});
	t.deepEqual({fill:'#000', stroke:null}, sf._color_options, 'fill option is set on internal color variable');
	
	TEARDOWN();
});

test('[shape_factory.color] correct, valid color string to stroke', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({stroke:'#000'});
	t.deepEqual({fill:undefined, stroke:'#000'}, sf._color_options, 'stroke is set');
	
	TEARDOWN();
});

test('[shape_factory.color] incorrect, invalid color string', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.color({color:'some fake color string'});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/non-empty String \(of a valid CSS color\)/), 'argument should be css color, null or undefined');
	}
	
	TEARDOWN();
});

test('[shape_factory.color] correct, color is null', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({color:null});
	t.deepEqual({fill:null, stroke:null}, sf._color_options, 'both fill and stroke should be null');
	
	TEARDOWN();
});

test('[shape_factory.color] incorrect, argument is not object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.color("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'argument should be an object');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, empty argument', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/argument 'type' is required/), 'argument should include "type" option at least');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, type argument invalid object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape({type:{}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/non-empty String/), 'argument should include "type" option at least');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, type argument empty string', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape({type:""});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/non-empty String/), 'argument should include "type" option at least');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, an invalid type string', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape({type:"some fake shape spec"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/argument 'type' was unknown shape type/), 'argument should include "type" option at least');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] correct, type=circle, but no radius defined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	
	sf.shape({type:"circle"});
	
	t.equal(sf._shape_type, "circle");
	t.equal(sf._shape_options.radius, 1);
	
	TEARDOWN();
});

test('[shape_factory.shape] correct, type=circle, radius defined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	
	sf.shape({type:"circle", radius:2});
	
	t.equal(sf._shape_type, "circle");
	t.equal(sf._shape_options.radius, 2);
	
	TEARDOWN();
});

test('[shape_factory.shape] correct, type=rect, height and width undefined', function (t) {
	t.plan(3);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"rect"});
	
	t.equal(sf._shape_type, "rect");
	t.equal(sf._shape_options.height, 18);
	t.equal(sf._shape_options.width, 36);
	
	TEARDOWN();
});

test('[shape_factory.shape] correct, type=rect, width and height defined', function (t) {
	t.plan(3);
	
	SETUP();
	
	var sf = shape_factory();
	
	sf.shape({type:"rect", width:1, height:2});
	
	t.equal(sf._shape_type, "rect");
	t.equal(sf._shape_options.height, 2);
	t.equal(sf._shape_options.width, 1);
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, argument is not object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'argument should be an object');
	}
	
	TEARDOWN();
});

test('[shape_factory._get_color] correct, fill is undefined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf._color_options.fill = undefined;
	
	var result = sf._get_color();
	
	var colorString = require("color-string");
	t.ok(colorString.get(result.fill), 'should get back a valid color for the fill');
	
	t.equal(result.stroke, null);
	
	TEARDOWN();
});

test('[shape_factory._get_color] correct, fill is user defined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf._color_options.fill = "some color string";
	
	var result = sf._get_color();
	
	t.equal(result.fill, "some color string", 'should get back the test color string for the fill');
	
	t.equal(result.stroke, null);
	
	TEARDOWN();
});

test('[shape_factory._get_color] correct, stroke and fill are user defined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf._color_options.fill = "some color string";
	sf._color_options.stroke = "some other color string";
	
	var result = sf._get_color();
	
	t.equal(result.fill, "some color string", 'should get back the test color string for the fill');
	
	t.equal(result.stroke, "some other color string", 'get back the test stroke string');
	
	TEARDOWN();
});

test('[shape_factory._get_shape] incorrect, shape() had not been run to setup', function (t) {
	t.plan(2);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	
	//test
	try {
		sf._get_shape({fill:"red", stroke:null});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/run shape/), 'user should do shape() first before attempting to call _get_shape()');
	}
	
	TEARDOWN();
});

test('[shape_factory._get_shape] correct, defaults (circle)', function (t) {
	t.plan(3);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	sf._shape_type = "circle";
	
	//test
	var shape = sf._get_shape({fill:"red", stroke:null});
	t.ok(check.instanceStrict(shape.graphics.command, createjs.Graphics.Circle), 'Shape should contain a circle graphic');
	t.equal(shape.graphics.command.radius, 1, '...with default radius (1)');
	t.deepEqual(shape.getBounds(), {x: -1, y: -1, width: 2, height: 2}, "...whose bounds should be special values for Circle");
	
	TEARDOWN();
});

test('[shape_factory._get_shape] correct, user options (circle)', function (t) {
	t.plan(5);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	sf._shape_options.radius = 42;
	sf._shape_options.x = 42;
	sf._shape_options.y = 42;
	sf._shape_type = "circle";
	
	//test
	var shape = sf._get_shape({fill:"red", stroke:null});
	t.ok(check.instanceStrict(shape.graphics.command, createjs.Graphics.Circle), 'Shape should contain a circle graphic');
	t.equal(shape.graphics.command.radius, 42, '...with a radius of 42');
	t.deepEqual(shape.getBounds(), {x: -42, y: -42, width: 84, height: 84}, "...whose bounds should be special values for Circle");
	t.equal(shape.x, 42, "x is correct");
	t.equal(shape.y, 42, "y is correct");
	
	TEARDOWN();
});

test('[shape_factory._get_shape] correct, defaults (rectangle)', function (t) {
	t.plan(4);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	sf._shape_type = "rect";
	
	//test
	var shape = sf._get_shape({fill:"red", stroke:null});
	t.ok(check.instanceStrict(shape.graphics.command, createjs.Graphics.Rect), 'Shape should contain a rectangle graphic');
	t.equal(shape.graphics.command.h, 18, '...with default height');
	t.equal(shape.graphics.command.w, 36, '...and width');
	t.deepEqual(shape.getBounds(), {x: 0, y: 0, width: 36, height: 18}, "bounds should be at the edge of the rectangle");
	
	TEARDOWN();
});

test('[shape_factory._get_shape] correct, user defined (rectangle)', function (t) {
	t.plan(6);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	sf._shape_options.height = 42;
	sf._shape_options.width = 42;
	sf._shape_options.x = 42;
	sf._shape_options.y = 42;
	sf._shape_type = "rect";
	
	//test
	var shape = sf._get_shape({fill:"red", stroke:null});
	t.ok(check.instanceStrict(shape.graphics.command, createjs.Graphics.Rect), 'Shape should contain a rectangle graphic');
	t.equal(shape.graphics.command.h, 42, '...with default height');
	t.equal(shape.graphics.command.w, 42, '...and width');
	t.deepEqual(shape.getBounds(), {x: 0, y: 0, width: 42, height: 42}, "bounds should be at the edge of the rectangle");
	t.equal(shape.x, 42, "x is correct");
	t.equal(shape.y, 42, "y is correct");
	
	TEARDOWN();
});

test('[shape_factory._bundle] correct', function (t) {
	t.plan(4);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var shape1 = new createjs.Shape();
	shape1.setBounds(1, 1, 1, 1);
	var shape2 = new createjs.Shape();
	
	//test
	var container = sf._bundle(shape1, shape2);
	t.equal(container.children.length, 2);
	t.equal(container.children[0], shape1);
	t.equal(container.children[1], shape2);
	//bounds should be the same as the shape in container
	t.deepEqual(container.getBounds(), {x: 1, y: 1, width: 1, height: 1});
	
	TEARDOWN();
});

test('[shape_factory._set_props] correct', function (t) {
	t.plan(2);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var shape = new createjs.Shape();
	shape.setBounds(0, 0, 0, 0);
	
	var text = new createjs.Text();
	var container = sf._bundle(shape, text);
	
	//test
	var result = sf._set_props(container);
	
	t.equal(container.x, 0);
	t.equal(container.y, 0);
	
	TEARDOWN();
});

test('[shape_factory._set_props] correct, user options', function (t) {
	t.plan(2);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var shape = new createjs.Shape();
	shape.setBounds(0, 0, 0, 0);
	
	var text = new createjs.Text();
	var container = sf._bundle(shape, text);
	
	//test
	var result = sf._set_props(container, {x:42, y:42});
	t.equal(result.x, 42);
	t.equal(result.y, 42);
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, defaults, rectangle', function (t) {
	t.plan(26);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"rect"});
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.ok(check.number(result.children[0].graphics.command.h), "as a rect it should have a valid height property");
	t.ok(check.number(result.children[0].graphics.command.w), "...and width");
	t.equal(result.children[0].graphics.command.h, 18, "should have default height for a rect");
	t.equal(result.children[0].graphics.command.w, 36, "...and width");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	//we should see all the event handlers / modifiers set
	var shape = result.children[0];
	t.ok(result._.on);
	t.ok(check.function(result._.on));
	t.ok(result._.off);
	t.ok(check.function(result._.off));
	t.ok(result._.addEventListener);
	t.ok(check.function(result._.addEventListener));
	t.ok(result._.hasEventListener);
	t.ok(check.function(result._.hasEventListener));
	t.ok(result._.removeAllEventListeners);
	t.ok(check.function(result._.removeAllEventListeners));
	t.ok(result._.removeEventListener);
	t.ok(check.function(result._.removeEventListener));
	
	t.deepEqual(result.getBounds(), {x:0, y:0, width:36, height:18}, "...and we should be able to see the default bounds");
	
	t.ok(result._.place, "the place property should be defined... ");
	t.ok(check.object(result._.place), "...and the place object should be attached");
	
	var colorString = require("color-string");
	t.ok(colorString.get(result._.shape_fill), "the fill should be a random color");
	t.equal(result._.shape_stroke, null, "and stroke should be the default (null)");
	
	TEARDOWN();
});

test('[shape_factory.get] incorrect, argument is not object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.get("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'argument should be an object');
	}
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, defaults, circle', function (t) {
	t.plan(24);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"circle"});
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.ok(check.number(result.children[0].graphics.command.radius), "as a circle it should have a valid radius property");
	t.equal(result.children[0].graphics.command.radius, 1, "should have default radius for a circle");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	
	//we should see all the event handlers / modifiers set
	//NOTE: we cannot tell the difference between the Shape.(function) and Container.(function) (of this type)
	//	they must be inherited from the same place, so we just have to check that they're set and that they're functions	
	var shape = result.children[0];
	t.ok(result._.on);
	t.ok(check.function(result._.on));
	t.ok(result._.off);
	t.ok(check.function(result._.off));
	t.ok(result._.addEventListener);
	t.ok(check.function(result._.addEventListener));
	t.ok(result._.hasEventListener);
	t.ok(check.function(result._.hasEventListener));
	t.ok(result._.removeAllEventListeners);
	t.ok(check.function(result._.removeAllEventListeners));
	t.ok(result._.removeEventListener);
	t.ok(check.function(result._.removeEventListener));
	
	t.deepEqual(result.getBounds(), {x:-1, y:-1, width:2, height:2}, "and we should be able to see the default bounds");
	
	t.ok(result._.place, "the place property should be defined... ");
	t.ok(check.object(result._.place), "...and the place object should be attached");
	
	var colorString = require("color-string");
	t.ok(colorString.get(result._.shape_fill), "the fill should be a random color");
	t.equal(result._.shape_stroke, null, "and stroke should be the default (null)");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, user options', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"circle"});
	var result = sf.get({x:1, y:1});
	
	t.equal(result.x, 1);
	t.equal(result.y, 1);
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, color() set', function (t) {
	t.plan(4);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"circle", radius:2});
	sf.color({color:"red"});
	var result = sf.get();
	
	//can't check color with method in createjs, so just have to verify we got the right Shape
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4});
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, text() set', function (t) {
	t.plan(7);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"circle", radius:2});
	sf.text({text:"red"});
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4})
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.equal(result.children[1].text, "red", "...to what we passed in");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, setter function permutation: text, color, shape', function (t) {
	t.plan(7);
	
	SETUP();
	
	var sf = shape_factory();
	sf.text({text:"red"});
	sf.color({color:"red"});
	sf.shape({type:"circle", radius:2});
	
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4})
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.equal(result.children[1].text, "red", "...to what we passed in");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, setter function permutation: color, text, shape', function (t) {
	t.plan(7);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({color:"red"});
	sf.text({text:"red"});
	sf.shape({type:"circle", radius:2});
	
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4})
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.equal(result.children[1].text, "red", "...to what we passed in");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, trigger exception in setter (color()), then get()', function (t) {
	t.plan(4);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.color({color:25});
	} catch (error) {}
	
	sf.shape({type:"circle", radius:2});
	
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4});
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, trigger exception in setter (text()), then get()', function (t) {
	t.plan(7);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.text({color:25});
	} catch (error) {}
	
	sf.shape({type:"circle", radius:2});
	
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4});
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, array box (null color, assigned number, black stroke, number is left of the shape)', function (t) {
	t.plan(12);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result = sf.get();
	
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.ok(check.number(result.children[0].graphics.command.h), "as a rect it should have a valid height property");
	t.ok(check.number(result.children[0].graphics.command.w), "...and width");
	t.equal(result.children[0].graphics.command.h, 18, "should have default height for a rect");
	t.equal(result.children[0].graphics.command.w, 36, "...and width");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	t.equal(result.children[1].text, "0", "we should see our number set");
	t.equal(result.children[1].x, -22, "and our coordinates");
	t.equal(result.children[1].y, 1, "set for the text");
	t.equal(result.children[1].font, "16px Arial", "and our font set");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, aray box (null color, assigned number, black stroke, number is left of the shape)', function (t) {
	t.plan(12);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result = sf.get();
	
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.ok(check.number(result.children[0].graphics.command.h), "as a rect it should have a valid height property");
	t.ok(check.number(result.children[0].graphics.command.w), "...and width");
	t.equal(result.children[0].graphics.command.h, 18, "should have default height for a rect");
	t.equal(result.children[0].graphics.command.w, 36, "...and width");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	t.equal(result.children[1].text, "0", "we should see our number set");
	t.equal(result.children[1].x, -22, "and our coordinates");
	t.equal(result.children[1].y, 1, "set for the text");
	t.equal(result.children[1].font, "16px Arial", "and our font set");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, aray box, multiple, while changing only the display text', function (t) {
	t.plan(6);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result_1 = sf.get();
	
	sf.text({text:1});
	
	var result_2 = sf.get();
	
	t.equal(result_1.children[1].text, "0");
	t.equal(result_2.children[1].text, "1");
	
	t.equal(result_1.children[1].font, result_2.children[1].font);
	t.equal(result_1.children[1].x, result_2.children[1].x);
	t.equal(result_1.children[1].y, result_2.children[1].y);
	t.equal(result_1.children[1].textAlign, result_2.children[1].textAlign);
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, multiple, checking container option persistence', function (t) {
	t.plan(8);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result_1 = sf.get();
	var result_2 = sf.get({y:18});
	var result_3 = sf.get({x:36});
	var result_4 = sf.get({y:36});
	
	t.equal(result_1.x, 0);
	t.equal(result_1.y, 0);
	
	t.equal(result_2.x, 0);
	t.equal(result_2.y, 18);
	
	t.equal(result_3.x, 36);
	t.equal(result_3.y, 18);
	
	t.equal(result_4.x, 36);
	t.equal(result_4.y, 36);
	
	TEARDOWN();
});

test('[shape_factory.get][place] correct', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result_1 = sf.get();
	
	t.ok(!check.undefined(result_1._.place), 'place namespace is correctly applied to the container');
	
	TEARDOWN();
});

test('[shape_factory.get][place] placer functions work', function (t) {
	t.plan(8);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result_1 = sf.get();
	var result_2 = sf.get();
	t.equal(result_1.x, 0);
	t.equal(result_1.y, 0);
	t.equal(result_2.x, 0);
	t.equal(result_2.y, 0);
	
	//this should move it below the other container
	result_1._.place.below(result_2);
	
	t.equal(result_1.x, 0);
	t.equal(result_1.y, 18);
	t.equal(result_2.x, 0);
	t.equal(result_2.y, 0);
	
	TEARDOWN();
});

test('[shape_factory.get] correct, color is set in the _ namespace', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result = sf.get();
	
	t.equal(result._.shape_fill, null);
	t.equal(result._.shape_stroke, "black");
	
	TEARDOWN();
});

test('[shape_factory._decorate] correct', function (t) {
	t.plan(21);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var container = new createjs.Container();
	var shape = new createjs.Shape();
	shape.setBounds(1, 1, 1, 1);
	var text = new createjs.Text();
	container.addChild(shape);
	container.addChild(text);
	var color = {fill:"some fill", stroke: "some stroke"}
	
	var result = sf._decorate(container, color);
	
	t.ok(result._);
	t.ok(result._.on);
	t.ok(check.function(result._.on));
	t.ok(result._.off);
	t.ok(check.function(result._.off));
	t.ok(result._.addEventListener);
	t.ok(check.function(result._.addEventListener));
	t.ok(result._.hasEventListener);
	t.ok(check.function(result._.hasEventListener));
	t.ok(result._.removeAllEventListeners);
	t.ok(check.function(result._.removeAllEventListeners));
	t.ok(result._.removeEventListener);
	t.ok(check.function(result._.removeEventListener));
	
	t.equal(container.getBounds().x, 1);
	t.equal(container.getBounds().y, 1);
	t.equal(container.getBounds().width, 1);
	t.equal(container.getBounds().height, 1);
	
	t.ok(result._.place);
	t.ok(check.object(result._.place));
	
	t.equal(result._.shape_fill, "some fill");
	t.equal(result._.shape_stroke, "some stroke");
	
	TEARDOWN();
});

test('[shape_factory._decorate] correct, add_to_stage', function (t) {
	t.plan(2);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var container = new createjs.Container();
	var shape = new createjs.Shape();
	shape.setBounds(1, 1, 1, 1);
	var text = new createjs.Text();
	container.addChild(shape);
	container.addChild(text);
	var color = {fill:"some fill", stroke: "some stroke"}
	
	var result = sf._decorate(container, color);
	
	t.ok(check.object(result._));
	t.ok(check.function(result._.add_to_stage));
	
	TEARDOWN();
});

test("[shape_factory] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//TEST
	try {
		shape_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		console.log(message);
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[shape_factory] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		shape_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});
},{"check-types":6,"color-string":8,"lib/factory/shape_factory":46,"lib/util/primitives":73,"tape":108}],55:[function(require,module,exports){
var text_factory = require('lib/factory/text_factory');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[text_factory.text] correct, no arguments', function (t) {
	t.plan(1);
	
	SETUP();
	
	//TEST
	var tf = text_factory();
	tf.text();
	t.deepEqual(tf._text_options, {color:"black", font:"18px Arial", text:undefined}, "text options should be set to defaults");
	
	TEARDOWN();
});

test('[text_factory.text] correct, override default', function (t) {
	t.plan(1);
	
	SETUP();
	
	var tf = text_factory();
	tf.text({color:"red"});
	t.deepEqual(tf._text_options, {color:"red", font:"18px Arial", text:undefined}, "should see color set");
	
	TEARDOWN();
});

test('[text_factory.text] correct, set x argument', function (t) {
	t.plan(1);
	
	SETUP();
	
	var tf = text_factory();
	tf.text({x:1});
	t.deepEqual(tf._text_options, {color:"black", font:"18px Arial", x:1, text:undefined}, "should see x option set");
	
	TEARDOWN();
});

test('[text_factory.text] correct, set text argument to non-createjs.Text', function (t) {
	t.plan(1);
	
	SETUP();
	
	var tf = text_factory();
	tf.text({text:1});
	t.deepEqual(tf._text_options, {color:"black", font:"18px Arial", text:"1"}, "should see string '1'");
	
	TEARDOWN();
});

test('[text_factory.text] correct, set text argument to createjs.Text', function (t) {
	t.plan(1);
	
	SETUP();
	
	var tf = text_factory();
	tf.text({text:new createjs.Text()});
	t.ok(check.instanceStrict(tf._text_options.text, createjs.Text), "should see createjs.Text option as text");
	
	TEARDOWN();
});

test('[text_factory.text] incorrect, argument is not object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var tf = text_factory();
	try {
		tf.text("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'argument should be an object');
	}
	
	TEARDOWN();
});

test('[text_factory.text] correct, argument is falsey (0)', function (t) {
	t.plan(1);
	
	SETUP();
	
	var tf = text_factory();
	tf.text({text:0});
	t.equal(tf._text_options.text, "0", "should see falsey item stringified");
	
	TEARDOWN();
});

test('[text_factory.text] correct, argument is falsey (null)', function (t) {
	t.plan(1);
	
	SETUP();
	
	var tf = text_factory();
	tf.text({text:null});
	t.equal(tf._text_options.text, "null", "should see falsey item stringified");
	
	TEARDOWN();
});

test('[text_factory.text] correct, argument is falsey ("")', function (t) {
	t.plan(1);
	
	SETUP();
	
	var tf = text_factory();
	tf.text({text:''});
	t.equal(tf._text_options.text, "", "should see falsey item stringified");
	
	TEARDOWN();
});

test('[text_factory.get] incorrect, argument is not object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var tf = text_factory();
	try {
		tf.get("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'argument should be an object');
	}
	
	TEARDOWN();
});

test('[text_factory.get] correct, overriding text()', function (t) {
	t.plan(4);
	
	SETUP();
	
	var tf = text_factory();
	tf.text({text:"some string", color:"red", x:10, y:10});
	var result = tf.get({x:5});
	t.equal(result.text, "some string");
	t.equal(result.color, "red");
	t.equal(result.x, 5);
	t.equal(result.y, 10);
	
	TEARDOWN();
});

test('[text_factory.get] correct, overriding text()', function (t) {
	SETUP();
	
	var tf = text_factory();
	tf.text({text:1, color:"red", x:10, y:10});
	var result1 = tf.get();
	
	t.equal(result1.text, "1");
	t.equal(result1.color, "red");
	t.equal(result1.x, 10);
	t.equal(result1.y, 10);
	
	var result2 = tf.get({y:15, text:2});
	
	t.equal(result2.text, "2");
	t.equal(result2.color, "red");
	t.equal(result2.x, 10);
	t.equal(result2.y, 15);
	
	TEARDOWN();
	
	t.end();
});

test('[text_factory._get_text] correct, defaults', function (t) {
	t.plan(4);
	
	SETUP();
	
	//setup
	var tf = text_factory();
	tf._text_options.text = undefined;
	
	//test
	var text = tf._get_text();
	t.equal(text.color, "black");
	t.ok(check.string(text.font), 'should have a font string, instead of undefined');
	t.ok(check.string(text.text), 'should have a string assigned');
	t.ok(check.number(Number(text.text)), '...and the value of the Text should be a number');
	
	TEARDOWN();
});

test('[text_factory._get_text] correct, user assigned value', function (t) {
	t.plan(4);
	
	//setup
	SETUP();
	
	var tf = text_factory();
	tf._text_options.text = "some user string";
	
	//test
	var text = tf._get_text();
	t.equal(text.color, "black");
	t.ok(check.string(text.font), 'should have a font string, instead of undefined');
	t.ok(check.string(text.text), 'should have a string assigned');
	t.equal(text.text, "some user string", 'and should be what we set');
	
	TEARDOWN();
});

test('[text_factory._get_text] correct, Text object', function (t) {
	t.plan(3);
	
	//setup
	SETUP();
	
	var tf = text_factory();
	tf._text_options.text = new createjs.Text("some test object");
	
	//test
	var text = tf._get_text()
	t.equal(tf._text_options.text, text, "we should have the same object returned as what we set");
	t.ok(check.string(text.text), 'should have a string assigned');
	t.equal(text.text, "some test object", 'and should be what we set');
	
	TEARDOWN();
});

test('[text_factory._decorate] correct, add_to_stage', function (t) {
	t.plan(2);
	
	//setup
	SETUP();
	
	var tf = text_factory();
	var text = new createjs.Text("some test object");
	
	//test
	var result = tf._decorate(text);
	t.ok(check.object(result._));
	t.ok(check.function(result._.add_to_stage));
	
	TEARDOWN();
});

test("[text_factory] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//TEST
	try {
		text_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		console.log(message);
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[text_factory] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		text_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});
},{"check-types":6,"lib/factory/text_factory":47,"lib/util/primitives":73,"tape":108}],56:[function(require,module,exports){
var lesson = require('lib/lesson/unordered_array_lesson');
var test = require('tape');
var check = require('check-types');

test('[lesson] incorrect, no arguments', function (t) {
	t.plan(4);
	
	try {
		lesson();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

test('[lesson] incorrect, bad argument', function (t) {
	t.plan(4);
	
	try {
		lesson("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

test('[lesson] incorrect, UI argument wrong type', function (t) {
	t.plan(4);
	
	try {
		lesson({UI: "some bad argument"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

test('[lesson] correct, insert button, setup event handler (sync)', function (t) {
	t.plan(2);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	var insert_button_event_type;
	var insert_button_listener;
	ui.insert_button.addEventListener = function(type, listener) {
		insert_button_event_type = type;
		insert_button_listener = listener;
	}
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var pre_start_backup = lesson.prototype.pre_start;
	
	var called_pre_start = 0;
	lesson.prototype.pre_start = function() {
		called_pre_start += 1;
	}
	
	var l = lesson({UI: ui});
	
	//TEST
	t.equal(insert_button_event_type, 'click', 'setup a click handler');
	insert_button_listener();
	t.equal(called_pre_start, 1, 'event handler calls next()');
	
	//CLEANUP
	lesson.prototype.pre_start = pre_start_backup;
});

test('[lesson] correct, insert button, event handler (async)', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	ui.insert_button = document.createElement('input');
	ui.insert_button.type = 'button';
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var pre_start_backup = lesson.prototype.pre_start;
	lesson.prototype.pre_start = function() {
		//TEST
		t.ok(true, "saw click event from 'insert' button");
		
		//CLEANUP
		lesson.prototype.pre_start = pre_start_backup;
	}
	
	var l = lesson({UI: ui});
	ui.insert_button.dispatchEvent(new Event("click"));
});

test('[lesson] correct, next button, setup event handler', function (t) {
	t.plan(2);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	var next_button_event_type;
	var next_button_listener;
	ui.next_button.addEventListener = function(type, listener) {
		next_button_event_type = type;
		next_button_listener = listener;
	}
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var next_backup = lesson.prototype.next;
	var called_next = 0;
	lesson.prototype.next = function() {
		called_next += 1;
	}
	
	var l = lesson({UI: ui});
	
	//TEST
	t.equal(next_button_event_type, 'click', 'setup a click handler');
	next_button_listener();
	t.equal(called_next, 1, 'event handler calls next()');
	
	//CLEANUP
	lesson.prototype.next = next_backup;
});

test('[lesson] correct, next button, event handler (async)', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	ui.next_button = document.createElement('input');
	ui.next_button.type = 'button';
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var next_backup = lesson.prototype.next;
	lesson.prototype.next = function() {
		//TEST
		t.ok(true, "saw click event from 'next' button");
		
		//CLEANUP
		lesson.prototype.next = next_backup;
	}
	
	var l = lesson({UI: ui});
	ui.next_button.dispatchEvent(new Event("click"));
});

test('[lesson.pre_start] correct, not in correct state', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	var get_called = false;
	ui.input.get = function() {
		get_called = true;
	}
	
	var l = lesson({UI: ui});
	
	l._state = -1;	//setup invalid state
	
	l.pre_start();
	
	//TEST
	t.notOk(get_called, 'input has not been pulled from the UI');
});

test('[lesson.pre_start] correct, correct state & bad input', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	ui.input.get = function() {
		return Number.NaN;
	}
	
	var output;
	ui.output.set = function(text) {
		output = text;
	}
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	//TEST
	t.ok(output.match(/not a number/), 'shows what was wrong');
	t.ok(output.match(/Please enter a number/), 'tells you what to enter');
	t.ok(output.match(/press the insert button/), '...and what to do');
});

test('[lesson.pre_start] correct, working array full case detected', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	ui.array.working.size = 1;
	ui.array.working.push(0);
	
	ui.input.get = function() {
		return 0;
	}
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	t.ok(l._array_full, 'saw that the array was full');
});

test('[lesson.pre_start] correct, working array NOT full case detected', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 0;
	}
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	t.notOk(l._array_full, 'saw that the array was NOT full');
});

test('[lesson.pre_start] correct, starting the lesson logic', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 0;
	}
	
	var next_backup = lesson.prototype.next;
	lesson.prototype.next = function() {
		t.ok(true, "called next()");
	}
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	t.equal(l._state, l._RUN, 'running the lesson');
	t.equal(l._step_state, l._STEP_1, 'step 1 of the lessson');
	
	//cleanup
	lesson.prototype.next = next_backup;
});

test('[lesson.pre_start] correct, case: array not full, initial call', function (t) {
	t.plan(11);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock move() function to check for call
	ui.array.move = function() {
		t.ok(true, 'called move()');
	}
	
	//create a mock set() function to check for call
	ui.output.set = function() {
		t.ok(true, 'called set()');
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 0;
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	var result = l.pre_start();
	
	//TEST
	t.equal(ui.array.input.length, 0, 'removed item from input array');
	t.equal(ui.array.working.length, 1, 'working array now has new item');
	t.equal(ui.array.working[0], 1, '...which was the value taken from get()');
	t.equal(l._state, l._RUN, 'still in the running state');
	t.equal(l._step_state, l._STEP_2, 'but now in the second step of the lesson')
	t.ok(check.object(result));
	t.notOk(result.done, 'not finished yet');
	t.ok(result.value.match(/Added the value/));
	t.ok(result.value.match(/to the array/));
});

test('[lesson.next] correct, case: array not full, final call', function (t) {
	t.plan(11);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock move() function to check for call
	ui.array.move = function() {
		t.ok(true, 'called move()');
	}
	
	//create a mock set() function to check for call
	ui.output.set = function() {
		t.ok(true, 'called set()');
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 0;
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	
	//FIRST PRESS
	var result = l.pre_start();
	
	//TEST
	t.notOk(result.done, 'not finished yet');
	t.equal(l._state, l._RUN, 'still in the running state');
	
	//SECOND PRESS
	result = l.next();
	
	//TEST
	t.ok(result.done, 'finished');
	t.equal(l._step_state, undefined, 'reset step state')
	t.equal(l._state, l._READY, 'in the ready state');
	t.ok(result.value.match(/Moved the \'tail\' pointer/));
	t.ok(result.value.match(/to prepare for the next insertion/));
	t.equal(ui.arrow.working.index, 1, 'incremented the index for the arrow');
});

test('[lesson.pre_start] correct, case: array full, call 1', function (t) {
	t.plan(8);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	ui.arrow.working.increment();	//move the tail pointer up
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = false;
	ui.output.set = function() {
		output_set_called = true;
	};
	
	var array_get_called = false;
	ui.array.get = function() {
		array_get_called = true;
	}
	
	var arrow_get_called = false;
	ui.arrow.get = function() {
		arrow_get_called = true;
	}
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	var result = l.pre_start();
	
	//TEST
	t.equal(l._state, l._RUN, 'in the running state');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Array is full/));
	t.ok(result.value.match(/Allocating new array/));
	t.equal(l._step_state, l._STEP_2, 'now in the second step of the lesson');
	t.ok(output_set_called, 'set the output to the message about what was done on this step')
	t.ok(array_get_called, 'got a new array');
	t.ok(arrow_get_called, 'got a new arrow');
});

test('[lesson.next] correct, case: array full, call 2', function (t) {
	t.plan(6);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	ui.arrow.working.increment();	//move the tail pointer up
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = false;
	ui.output.set = function() {
		output_set_called = true;
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	
	//SETUP, PRESS 1
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	l._array_full = true;
	l._array_tmp = ui.array.get({size:ui.array.working.size*2, nodes:0});
	l._arrow_tmp = ui.arrow.get({name:'tail', array:l._array_tmp, index:0});
	
	//PRESS 2
	var result = l.next();
	
	//TEST
	t.ok(check.object(l._move_pointer), 'setup the move pointer');
	t.ok(output_set_called, 'set a new message');
	t.equal(l._state, l._RUN, 'in the running state');
	t.notOk(result.done, 'not finished');
	t.equal(l._step_state, l._STEP_MOVING, 'third step on next()');
	t.ok(result.value.match(/move pointer/));
});

test('[lesson.next] correct, case: array full, call 3 - moving', function (t) {
	t.plan(5);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	ui.arrow.working.increment();	//move the tail pointer up
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = 0;
	ui.output.set = function() {
		output_set_called += 1;
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	
	//SETUP, PRESS 1
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	l._array_full = true;
	l._array_tmp = ui.array.get({size:ui.array.working.size*2, nodes:0});
	l._arrow_tmp = ui.arrow.get({name:'tail', array:l._array_tmp, index:0});
	
	//SETUP, PRESS 2
	l._move_pointer = ui.arrow.get({name:'move', array:ui.array.working, index:0});
	l._step_state = l._STEP_MOVING;
	
	//PRESS 3
	/* console.log(l._array_tmp);
	console.log(l._arrow_tmp);
	console.log(ui.array.working);
	console.log(ui.arrow.working);
	console.log(l._move_pointer); */
	
	//console.log("next()");
	var result = l.next();
	
	/* console.log(l._array_tmp);
	console.log(l._arrow_tmp);
	console.log(ui.array.working);
	console.log(ui.arrow.working);
	console.log(l._move_pointer); */
	
	//TEST
	
	t.equal(output_set_called, 1, 'set a new message');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Moved value/));
	t.equal(l._move_pointer.index, 1, 'advanced the move pointer on the old array one space');
	t.equal(l._arrow_tmp.index, 1, 'advanced the tail pointer on the new array one space, since we added a new value');
});

test('[lesson.next] correct, case: array full, call 4 - exiting from move', function (t) {
	t.plan(4);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	ui.arrow.working.increment();	//move the tail pointer up
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = 0;
	ui.output.set = function() {
		output_set_called += 1;
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	
	//SETUP, PRESS 1
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	l._array_full = true;
	l._array_tmp = ui.array.get({size:ui.array.working.size*2, nodes:0});
	l._arrow_tmp = ui.arrow.get({name:'tail', array:l._array_tmp, index:0});
	
	//SETUP, PRESS 2
	l._move_pointer = ui.arrow.get({name:'move', array:ui.array.working, index:0});
	l._step_state = l._STEP_MOVING;
	
	//SETUP, PRESS 3
	l._move_pointer.increment();
	l._arrow_tmp.increment();
	l._array_tmp[0] = 0;
	
	//PRESS
	var result = l.next();
	
	//TEST
	t.equal(output_set_called, 1, 'set a new message');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/we\'ve finished moving the values/));
	t.equal(l._step_state, l._STEP_3, 'should be in the next step after moving after this');
});

test('[lesson.next] correct, case: array full, call 5 - removing old array and setting up new array as "working"', function (t) {
	t.plan(11);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	ui.arrow.working.increment();	//move the tail pointer up
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = 0;
	ui.output.set = function() {
		output_set_called += 1;
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	
	//SETUP, PRESS 1
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	l._array_full = true;
	var new_array = ui.array.get({size:ui.array.working.size*2, nodes:0});
	l._array_tmp = new_array;
	var new_tail_arrow = ui.arrow.get({name:'tail', array:l._array_tmp, index:0});
	l._arrow_tmp = new_tail_arrow;
	
	//SETUP, PRESS 2
	l._move_pointer = ui.arrow.get({name:'move', array:ui.array.working, index:0});
	l._step_state = l._STEP_MOVING;
	
	//SETUP, PRESS 3
	l._move_pointer.increment();
	l._arrow_tmp.increment();
	l._array_tmp[0] = 0;
	
	//SETUP, PRESS 4
	l._step_state = l._STEP_3;
	
	//create mock del() functions to track number of calls
	var array_del_called = 0;
	ui.array.del = function() {
		array_del_called += 1;
	};
	
	var arrow_del_called = 0;
	ui.arrow.del = function() {
		arrow_del_called += 1;
	};
	
	//PRESS
	var result = l.next();
	
	//TEST
	t.equal(output_set_called, 1, 'set a new message');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Removing the old array/));
	t.equal(l._step_state, l._STEP_1, 'should be back in step 1 to traverse to "array not empty case"');
	t.equal(arrow_del_called, 2, 'de-allocated both the move pointer and the tail pointer for the old array');
	t.equal(array_del_called, 1, 'de-allocated the old array');
	t.ok(check.undefined(l._array_tmp));
	t.ok(check.undefined(l._arrow_tmp));
	t.ok(check.undefined(l._move_pointer));
	t.deepEqual(ui.array.working, new_array, 'the new array should be saved on the UI as the new current work array');
	t.deepEqual(ui.arrow.working, new_tail_arrow, '...and its tail arrow should be saved on the UI similarly');
});

test('[lesson] correct, integration testing, insert into array to fill it (size 2), then insert another value to create new array (size 4) and insert into it', function (t) {
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//start the working array at size 2, with no items stored
	ui.array.working.size = 2;
	
	//setup the lesson
	var l = lesson({UI: ui});
	
	//TEST - pre-insert
	t.equal(l._state, l._READY);
	t.equal(ui.array.working.length, 0, 'working array should be empty');
	t.equal(ui.arrow.working.index, 0, 'tail on working array should be at 0th index');
	t.ok(check.undefined(l._step_state), 'should not be stepping through a lesson yet');
	
	//SETUP
	//mock input.get() function to return values
	var input = -1;
	ui.input.get = function() {
		input += 1;
		return input;
	};
	
	//mock output.set() to track message
	var output_set_called = 0;
	ui.output.set = function() {
		output_set_called += 1;
	};
	
	//PRESS - pre_start
	var result = l.pre_start();
	
	//TEST - post first press
	t.equal(l._state, l._RUN);
	t.equal(ui.array.working.length, 1, 'working array should have first item copied in');
	t.equal(ui.arrow.working.index, 0, 'tail pointer should be at 0th position, until we increment on next step');
	t.equal(l._step_state, l._STEP_2);
	t.notOk(result.done, 'should not be done yet');
	t.ok(result.value.match(/Added the value/));
	t.equal(output_set_called, 1);
	
	//PRESS - next
	
	result = l.next();
	
	//TEST
	t.equal(l._state, l._READY);
	t.equal(ui.array.working.length, 1, 'working array should have first item copied in');
	t.equal(ui.arrow.working.index, 1, 'working tail pointer at index 1');
	t.ok(check.undefined(l._step_state));
	t.ok(result.done);
	t.ok(result.value.match(/prepare for the next insertion/));
	t.equal(output_set_called, 2);
	
	//PRESS - insert another value
	l.pre_start();
	l.next();
	
	//TEST
	t.equal(l._state, l._READY);
	t.equal(ui.array.working.length, 2, 'working array should see both items');
	t.equal(ui.arrow.working.index, 2, 'working tail pointer at index 2');
	t.ok(check.undefined(l._step_state));
	t.ok(result.done);
	t.ok(result.value.match(/prepare for the next insertion/));
	t.equal(output_set_called, 4);
	
	//PRESS - insert another value, _array_full === true
	result = l.pre_start();
	
	//TEST
	t.ok(l._array_full, 'should see array full case detected')
	t.equal(l._state, l._RUN);
	t.equal(ui.array.working.length, 2, 'working array should see both items');
	t.equal(ui.arrow.working.index, 2, 'working tail pointer at index 2');
	t.equal(l._step_state, l._STEP_2);
	t.notOk(result.done);
	t.ok(result.value.match(/Array is full/), 'array is full message');
	t.equal(output_set_called, 5);
	//NOTE: the array allocated does NOT detect as an object in the mock_UI
	t.ok(check.array(l._array_tmp), 'should have a new array allocated');
	t.equal(l._array_tmp.length, 0, 'with nothing in it');
	t.equal(l._array_tmp.size, 4, 'but whose size is twice that of the old array');
	t.ok(check.object(l._arrow_tmp), 'and a new arrow for the new array');
	t.equal(l._arrow_tmp.index, 0, 'positioned at the start of the new array');
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_MOVING);
	t.notOk(result.done);
	t.ok(result.value.match(/move pointer/), 'move pointer message');
	t.equal(output_set_called, 6);
	t.ok(check.object(l._move_pointer), 'should see the move pointer');
	t.equal(l._move_pointer.index, 0, 'starts at the beginning of the old array');
	t.deepEqual(l._move_pointer.array, ui.array.working, 'the move pointer should be pointing at the old array');
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_MOVING);
	t.notOk(result.done);
	t.ok(result.value.match(/Moved value/), 'moved a value');
	t.equal(output_set_called, 7);
	
	t.equal(l._array_tmp.length, 1, 'first moved value');
	t.equal(l._arrow_tmp.index, 1, 'moved its tail pointer');
	
	t.equal(l._move_pointer.index, 1, 'move pointer ready to copy second value');
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_MOVING);
	
	t.notOk(result.done);
	t.ok(result.value.match(/Moved value/), 'moved a value');
	t.equal(output_set_called, 8);
	
	t.equal(l._array_tmp.length, 2, 'both values moved');
	t.equal(l._arrow_tmp.index, 2, 'moved its tail pointer');
	
	t.equal(l._move_pointer.index, 2, 'move pointer now at the end of the old array');
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_3);
	
	t.notOk(result.done);
	t.ok(result.value.match(/we\'ve finished moving the values/), 'finished moving');
	t.equal(output_set_called, 9);
	
	t.equal(l._array_tmp.length, 2, 'both values moved');
	t.equal(l._arrow_tmp.index, 2);
	
	t.equal(l._move_pointer.index, 2, 'move pointer now at the end of the old array');
	
	//SETUP
	var old_array = ui.array.working;
	var old_arrow = ui.arrow.working;
	var new_array = l._array_tmp;
	var new_arrow = l._arrow_tmp;
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_1);
	
	t.notOk(result.done);
	t.ok(result.value.match(/Removing the old array and the move pointer/), 'cleaning up');
	t.equal(output_set_called, 10);
	
	t.notOk(l._array_full);
	t.ok(check.undefined(l._array_tmp));
	t.ok(check.undefined(l._arrow_tmp));
	t.ok(check.undefined(l._move_pointer));
	
	t.deepEqual(ui.array.working, new_array, 'the new array is now saved on the ui for work going forward');
	t.deepEqual(ui.arrow.working, new_arrow, 'and so is its arrow');
	
	//PRESS - move final value from input to the newly allocated array
	l.next();
	l.next();
	
	//TEST
	t.equal(l._state, l._READY, 'should be ready to insert another value');
	t.ok(check.undefined(l._step_state), 'should not be stepping through a lesson');
	t.equal(ui.array.working.length, 3, 'should have 3 values in the new array');
	t.equal(ui.arrow.working.index, 3, 'tail pointer should be one past the last value');
	
	t.end();
});
},{"check-types":6,"lib/lesson/unordered_array_lesson":48,"lib/test/mock_UI":57,"tape":108}],57:[function(require,module,exports){
function UI() {
	var ret = {
		input : {
			get : function() {},			//returns a Number or NaN
		},
		output : {
			set : function(text) {},		//sets the value of the text output to `text`
		},
		//an object we can attach an event handler to
		insert_button : {
			addEventListener : function(type, listener) {},
		},
		//an object we can attach an event handler to
		next_button : {
			addEventListener : function(type, listener) {},
		},
		array : {
			get : undefined,		//returns a new array
											//with options including:
											//	size, how large the array would be (allocating space, not placing nodes)
											//	nodes, how many random nodes to insert into the array
			
			del : function(array) {},		//de-allocates an array
			
			input : new array(1),			//a reference to the array pre-allocated by the UI to hold the user input
			working : new array(5),			//a reference to the array allocated by the UI that the user works on during a lesson
			
			move : function(options) {},	//shows an animation of moving an element with value to a target array at index in that array
											//	logical moving done in lesson code
											//options:
											//	from_array, reference to the UI array we're taking the value from
											//	from_index, refrence to the index in the from_array
											//	to_array, reference to the UI array we're placing the value in
											//	to_index, reference to the target index in to_array
		},
		arrow : {
			get : undefined,				//returns a new arrow
											//with options including:
											//	name, what to label the arrow (e.g. "tail", "copy", etc)
											//	array, which array the arrow is associated with
											//	index, which index in the array the arrow should point at
											
			del : function(arrow) {},		//de-allocates an arrow
			//reference to the arrow allocated by the UI (e.g. "tail" on the working array)
			//	(defined below)
			working : undefined,			
		}
	}
	
	ret.arrow.working = new arrow({name: 'tail', array: ret.array.working, index:0});
	ret.arrow.get = arrow;
	ret.array.get = array;
	
	return ret;
};

function array(options) {
	var ret = [];
	ret.size = options.size;
	
	return ret;
}

function arrow(options) {
	if (!(this instanceof arrow)) return new arrow(options);
	
	this.name = options.name;
	this.array = options.array;
	this.index = options.index;
	
	this.increment = function() {
		this.index += 1;
	}
}

function get() {
	return new UI();
}

module.exports = get;
},{}],58:[function(require,module,exports){
var add_to_stage = require("lib/util/add_to_stage");
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[add_to_stage] incorrect, bad argument', function (t) {
	t.plan(3);
	
	//SETUP
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	var primitives = require("lib/util/primitives");
	primitives.set('stage', stage);
	
	//TEST
	try {
		add_to_stage({});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Cannot add object of type/), 'bad object type');
		t.ok(message.match(/requires createjs DisplayObject/), 'need DisplayObject');
	}
	
	//CLEANUP
	primitives.clear();
});

test('[add_to_stage] correct, get back a function', function (t) {
	t.plan(1);
	
	//SETUP
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	var primitives = require("lib/util/primitives");
	primitives.set('stage', stage);
	
	//TEST
	var text = new createjs.Text('some string');
	
	var add_text = add_to_stage(text);
	
	t.ok(check.function(add_text));
	
	//CLEANUP
	stage.removeAllChildren();
	primitives.clear();
});

test('[add_to_stage] correct, the function adds to the stage', function (t) {
	t.plan(3);
	
	//SETUP
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	var primitives = require("lib/util/primitives");
	primitives.set('stage', stage);
	
	//TEST
	var text = new createjs.Text('some string');
	
	var add_text = add_to_stage(text);
	
	t.equal(stage.children.length, 0,'stage starts empty...');
	
	add_text();
	
	t.equal(stage.children.length, 1, '...but then we see the new child added');
	t.deepEqual(stage.children[0], text, "...and it's the node we passed in");
	
	//CLEANUP
	stage.removeAllChildren();
	primitives.clear();
});

test("[add_to_stage] correct, but doesn't add the object twice", function (t) {
	t.plan(3);
	
	//SETUP
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	var primitives = require("lib/util/primitives");
	primitives.set('stage', stage);
	
	//TEST
	var text = new createjs.Text('some string');
	
	var add_text = add_to_stage(text);
	
	t.equal(stage.children.length, 0, 'stage starts empty...');
	
	add_text();
	
	t.equal(stage.children.length, 1, '...but then we see the new child added');
	
	add_text();
	
	t.equal(stage.children.length, 1, 'then not added again, if we call add_to_stage again');
	
	//CLEANUP
	stage.removeAllChildren();
	primitives.clear();
});

/* test("[add_to_stage] incorrect, stage not registerd with primitives before call", function (t) {
	t.plan(3);
	
	//SETUP
	var text = new createjs.Text('some string');
	
	//TEST
	try {
		add_to_stage(text);
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/stage/), 'was checking for stage');
		t.ok(message.match(/undefined in primitives object/), 'defined what was wrong');
	}
}); */

test("[add_to_stage] incorrect, 'stage' unset", function (t) {
	t.plan(3);
	
	//SETUP
	var text = new createjs.Text('some string');
	
	//TEST
	try {
		add_to_stage(text);
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/stage/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[add_to_stage] incorrect, 'stage' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var text = new createjs.Text('some string');
	
	var primitives = require("lib/util/primitives");
	primitives.set('stage', '');
	
	//TEST
	try {
		add_to_stage(text);
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/stage/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});
},{"check-types":6,"lib/util/add_to_stage":68,"lib/util/primitives":73,"tape":108}],59:[function(require,module,exports){
var append_to = require('lib/util/append_to');
var test = require('tape');
var check = require('check-types');

test('[append_to] correct, argument form: obj.htmlElement', function (t) {
	t.plan(4);
	
	//setup
	var parent_html = document.createElement('div');
	
	var mock_child_obj = {};
	mock_child_obj.htmlElement = document.createElement('div');
	
	mock_child_obj.append_to = append_to(mock_child_obj);
	
	//test
	t.ok(check.function(mock_child_obj.append_to), 'we should get back a function');
	
	t.equal(parent_html.childNodes.length, 0, 'our test parent should not have any children...');
	mock_child_obj.append_to(parent_html);
	t.equal(parent_html.childNodes.length, 1, '...until after we append something...');
	
	t.deepEqual(parent_html.childNodes[0], mock_child_obj.htmlElement, '...and that object appended should be the mock');
});

test('[append_to] incorrect, argument form: obj.htmlElement, htmlElement is not Element', function (t) {
	t.plan(3);
	
	//setup
	var parent_html = document.createElement('div');
	
	var mock_child_obj = {};
	mock_child_obj.htmlElement = 'some incorrect object type';
	
	//test
	try {
		append_to(mock_child_obj);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Incorrect property type/), 'bad type');
		t.ok(message.match(/HTML Element/), 'tells you what was needed');
	}
});

test('[append_to.direct_append_to] incorrect, bad argument', function (t) {
	t.plan(3);
	
	//setup
	var parent_html = document.createElement('div');
	
	var mock_child_obj = {};
	mock_child_obj.htmlElement = document.createElement('div');
	
	mock_child_obj.append_to = append_to(mock_child_obj);
	
	//test
	try {
		mock_child_obj.append_to(['some bad argument']);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Incorrect argument type/), 'bad type');
		t.ok(message.match(/HTML Element/), 'tells you what was needed');
	}
});

test('[append_to] correct, argument form: obj._.htmlElement', function (t) {
	t.plan(4);
	
	//setup
	var parent_html = document.createElement('div');
	
	var mock_child_obj = {};
	mock_child_obj._ = {};
	mock_child_obj._.htmlElement = document.createElement('div');
	
	mock_child_obj.append_to = append_to(mock_child_obj);
	
	//test
	t.ok(check.function(mock_child_obj.append_to), 'we should get back a function');
	
	t.equal(parent_html.childNodes.length, 0, 'our test parent should not have any children...');
	mock_child_obj.append_to(parent_html);
	t.equal(parent_html.childNodes.length, 1, '...until after we append something...');
	
	t.deepEqual(parent_html.childNodes[0], mock_child_obj._.htmlElement, '...and that object appended should be the mock');
});

test('[append_to] incorrect, argument form: obj._.htmlElement, htmlElement is not Element', function (t) {
	t.plan(3);
	
	//setup
	var parent_html = document.createElement('div');
	
	var mock_child_obj = {};
	mock_child_obj._ = {};
	mock_child_obj._.htmlElement = 'some incorrect object type';
	
	//test
	try {
		append_to(mock_child_obj);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Incorrect property type/), 'bad type');
		t.ok(message.match(/HTML Element/), 'tells you what was needed');
	}
});

test('[append_to] correct, argument form: obj.children WITH ._. namepsace', function (t) {
	t.plan(2);
	
	//setup
	var parent_html = document.createElement('div');
	
	var mock_child_obj = {};
	mock_child_obj._ = {};
	mock_child_obj.children = [];
	var m = {};
	m._ = {append_to : function() {
		t.ok(true, 'called append_to on child');
	}};
	mock_child_obj.children.push(m);
	
	mock_child_obj.append_to = append_to(mock_child_obj);
	
	//test
	t.ok(check.function(mock_child_obj.append_to), 'we should get back a function');
	//then calling append_to() here should call the append_to() function on the child object m, as above
	mock_child_obj.append_to(parent_html);
});

test('[append_to] incorrect, argument form: obj.children, children not array', function (t) {
	t.plan(3);
	
	//setup
	var parent_html = document.createElement('div');
	
	var mock_child_obj = {};
	mock_child_obj.children = {};
	
	try {
		append_to(mock_child_obj);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/children/), 'bad type');
		t.ok(message.match(/should be of type array/), 'tells you what was needed');
	}
});

test('[append_to] incorrect, bad argument form', function (t) {
	t.plan(3);
	
	//setup
	var parent_html = document.createElement('div');
	var mock_child_obj = {};
	
	try {
		append_to(mock_child_obj);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Object was of incorrect form/), 'bad type');
		t.ok(message.match(/see documentation for acceptable forms/), 'tells you what was needed');
	}
});

test('[append_to] incorrect, argument not object', function (t) {
	t.plan(3);
	
	//setup
	var parent_html = document.createElement('div');
	var mock_child_obj = [];
	
	try {
		append_to(mock_child_obj);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Incorrect argument type/), 'bad type');
		t.ok(message.match(/requires Object/), 'tells you what was needed');
	}
});

test('[append_to] incorrect, ._. namespace exists, but form incorrect', function (t) {
	t.plan(3);
	
	//setup
	var parent_html = document.createElement('div');
	var mock_child_obj = {};
	mock_child_obj._ = {};
	
	try {
		append_to(mock_child_obj);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Object was of incorrect form/), 'bad type');
		t.ok(message.match(/see documentation for acceptable forms/), 'tells you what was needed');
	}
});

},{"check-types":6,"lib/util/append_to":69,"tape":108}],60:[function(require,module,exports){
var argument_check = require("lib/util/argument_check");
var test = require('tape');
var check = require('check-types');

test('[argument_check] error invalid type passed', function (t) {
	t.plan(2);
	try {
		argument_check("");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Arguments to argument_check/), 'we should see the special error message for the arguments check');
	}
});

test('[argument_check] passed undefined, return empty object', function (t) {
	t.plan(1);
	t.ok(check.emptyObject(argument_check(undefined)), 'should get back empty object on undefined');
});

test('[argument_check] Correct, but empty', function (t) {
	t.plan(1);
	t.ok(check.emptyObject(argument_check({})), 'should get back empty object on empty object');
});

test('[argument_check] Correct, but unknown argument', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({some_fake_argument_name:42}), { some_fake_argument_name: 42 });
});

test('[argument_check] Correct, known argument with valid type', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({width:42}), { width: 42 });
});

test('[argument_check][width] Error, known argument with invalid type', function (t) {
	t.plan(4);
	
	try {
		argument_check({width:"42"})
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/width/), 'verify we saw the right argument');
		t.ok(message.match(/was String/), '...and detected the right type');
		t.ok(message.match(/number \( greater than zero \)/), '...and reported which type it should be');
	}
});

test('[argument_check] Correct, known argument with valid wrapper type', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({width:Number(42)}), { width: 42 });
});

test('[argument_check] Correct, known argument: null', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({fill:null}), {fill:null});
});

test('[argument_check] Correct, known argument: non-empty string', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({fill:"red"}), {fill:"red"});
});

test('[argument_check][fill] Error, known argument, emtpy string', function (t) {
	t.plan(4);
	try {
		argument_check({fill:""})
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/fill/), 'verify we saw the right argument');
		t.ok(message.match(/was empty String/), '...and detected the right type');
		t.ok(message.match(/non-empty String \(of a valid CSS color\)/), '...and reported which type it should be');
	}
});

test('[argument_check] Correct, argument textAlign', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({textAlign:"start"}), {textAlign:"start"});
});

test('[argument_check][textAlign] incorrect, argument is string but not an acceptable one', function (t) {
	t.plan(3);
	try {
		argument_check({textAlign:"some fake string"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/textAlign/), 'verify we saw the right argument');
		t.ok(message.match(/of one of these: start, end, left, right, center/), '...and reported which value it should be');
	}
});

test('[argument_check][textAlign], error null', function (t) {
	t.plan(3);
	try {
		argument_check({textAlign:null});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/textAlign/), 'verify we saw the right argument');
		t.ok(message.match(/of one of these: start, end, left, right, center/), '...and reported which value it should be');
	}
});

test('[argument_check] Correct, argument color', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({color:"red"}), {color:"red"});
});

test('[argument_check] incorrect, argument color, but not a color', function (t) {
	t.plan(3);
	try {
		argument_check({color:"some fake string"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/color/), 'verify we saw the right argument');
		t.ok(message.match(/of a valid CSS color/), '...and reported which value it should be');
	}
});

test('[argument_check][font] correct', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({font:"18px Arial"}), {font:"18px Arial"});
});

test('[argument_check][font] bad font', function (t) {
	t.plan(3);
	try {
		argument_check({font:"some fake string"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/font/), 'verify we saw the right argument');
		t.ok(message.match(/of a valid CSS font/), '...and reported which value it should be');
	}
});

test('[argument_check][font] empty string font', function (t) {
	t.plan(3);
	try {
		argument_check({font:""});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/font/), 'verify we saw the right argument');
		t.ok(message.match(/of a valid CSS font/), '...and reported which value it should be');
	}
});

test('[argument_check][font] null font', function (t) {
	t.plan(3);
	try {
		argument_check({font:null});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/font/), 'verify we saw the right argument');
		t.ok(message.match(/of a valid CSS font/), '...and reported which value it should be');
	}
});

test('[argument_check][width] correct', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({width:1}), {width:1});
});

test('[argument_check][width] error, null', function (t) {
	t.plan(3);
	try {
		argument_check({width:null});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/width/), 'verify we saw the right argument');
		t.ok(message.match(/number \( greater than zero \)/), '...and reported which value it should be');
	}
});

test('[argument_check][width] error, 0', function (t) {
	t.plan(3);
	try {
		argument_check({width:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/width/), 'verify we saw the right argument');
		t.ok(message.match(/number \( greater than zero \)/), '...and reported which value it should be');
	}
});

test('[argument_check][x] error, null', function (t) {
	t.plan(3);
	try {
		argument_check({x:null});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/x/), 'verify we saw the right argument');
		t.ok(message.match(/number/), '...and reported which value it should be');
	}
});

test('[argument_check][radius] error, 0', function (t) {
	t.plan(3);
	try {
		argument_check({radius:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/radius/), 'verify we saw the right argument');
		t.ok(message.match(/number \( greater than zero \)/), '...and reported which value it should be');
	}
});

test('[argument_check][x] error any argument whose value is undefined', function (t) {
	t.plan(3);
	try {
		argument_check({x:undefined});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/x/), 'verify we saw the right argument');
		t.ok(message.match(/number/), '...and reported which value it should be');
	}
});

test('[argument_check][fill] error any argument whose value is undefined', function (t) {
	t.plan(4);
	try {
		argument_check({fill:undefined});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/fill/), 'verify we saw the right argument');
		t.ok(message.match(/non-empty String/), '...and reported which value it should be');
		t.ok(message.match(/or null/), '...and reported which value it should be');
	}
});

test('[argument_check][font] error any argument whose value is undefined', function (t) {
	t.plan(4);
	try {
		argument_check({font:undefined});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/font/), 'verify we saw the right argument');
		t.ok(message.match(/non-empty String/), '...and reported which value it should be');
		t.ok(message.match(/of a valid CSS font/), '...and reported which value it should be');
	}
});

test('[argument_check][textAlign] error any argument whose value is undefined', function (t) {
	t.plan(4);
	try {
		argument_check({textAlign:undefined});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/textAlign/), 'verify we saw the right argument');
		t.ok(message.match(/non-empty String/), '...and reported which value it should be');
		t.ok(message.match(/start, end, left, right, center/), '...and reported which value it should be');
	}
});

test('[argument_check][radius] error any argument whose value is undefined', function (t) {
	t.plan(4);
	try {
		argument_check({radius:undefined});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/radius/), 'verify we saw the right argument');
		t.ok(message.match(/number/), '...and reported which value it should be');
		t.ok(message.match(/greater than zero/), '...and reported which value it should be');
	}
});

test('[argument_check]unknown variable, error any argument whose value is undefined', function (t) {
	t.plan(3);
	try {
		argument_check({text:undefined});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/text/), 'verify we saw the right argument');
		t.ok(message.match(/was undefined/), '...and reported why there was an error');
	}
});

test('[argument_check][type], incorrect', function (t) {
	t.plan(3);
	try {
		argument_check({type:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/type/), 'verify we saw the right argument');
		t.ok(message.match(/non-empty String/), '...and reported why there was an error');
	}
});

test('[argument_check][type] correct', function (t) {
	t.plan(1);
	t.deepEqual(argument_check({type:"some type string"}), {type:"some type string"});
});
},{"check-types":6,"lib/util/argument_check":70,"tape":108}],61:[function(require,module,exports){
var move = require('lib/util/move');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[move._argument_check] incorrect, no argument', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Requires argument/), 'should tell you what is wrong');
		t.ok(message.match(/object/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, wrong type', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, "some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Requires argument/), 'should tell you what is wrong');
		t.ok(message.match(/object/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, right type, but no x or y', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, {});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument requires numeric property/), 'should tell you what is wrong');
		t.ok(message.match(/x/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, right type, x is present, but wrong type', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, {x:"2"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument requires numeric property/), 'should tell you what is wrong');
		t.ok(message.match(/x/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, right type, x is present and correct, but y is not', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, {x:2});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument requires numeric property/), 'should tell you what is wrong');
		t.ok(message.match(/y/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, right type, x is present and correct, but y is wrong type', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, {x:2, y:"2"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument requires numeric property/), 'should tell you what is wrong');
		t.ok(message.match(/y/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] correct', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	t.ok(move.prototype._argument_check.call(mock_this, {x:2, y:2}), "method returned true, so all checks passed");
	
	TEARDOWN();
});

test("[move] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//TEST
	try {
		move();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		console.log(message);
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[move] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		move();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test('[move] correct, duration invalid, uses defaults', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0}, {duration:"some bad value"});
	t.equal(result._duration, 1000, 'using default duration');
	
	TEARDOWN();
});

test('[move] correct, duration unset, uses defaults', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0}, {});
	t.equal(result._duration, 1000, 'using default duration');
	
	TEARDOWN();
});

test('[move] correct, no options', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0});
	t.equal(result._duration, 1000, 'using default duration');
	
	TEARDOWN();
});

test('[move] correct, duration set', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0}, {duration:1});
	t.equal(result._duration, 1, 'uses user defined duration');
	
	TEARDOWN();
});

test('[move] correct, duration set, but bad number', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0}, {duration:-1});
	t.equal(result._duration, 1000, 'default duration used');
	
	TEARDOWN();
});

test('[move.is_moving && move.to] correct, false before move, true while moving, false after and tween completed by changing the source', function (t) {
	t.plan(7);
	
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_argument_check : function() {},
		
		_createjs : primitives.get('createjs'),
		_source : {x:0, y:0},
		_duration : 1000,
	};
	
	//TEST
	t.notOk(move.is_moving(), "should be false before move");
	
	//create a tween to move _source to the coordinates at (1, 1), this should take 1 second, with the default duration
	var destination = {x:1, y:1};
	move.prototype.to.call(mock_this, destination);
	
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(mock_this._source.x > 0 && mock_this._source.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(mock_this._source.y > 0 && mock_this._source.y < 1, 'value should be on the way to 1, but not equal');
	}, 500);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "then false again after the move");
		t.equal(mock_this._source.x, destination.x, "source and destination should be the same after the move")
		t.equal(mock_this._source.y, destination.y, "source and destination should be the same after the move")
		TEARDOWN();
	}, 1500);
});

test('[move.is_moving && move.to] correct, user defined duration', function (t) {
	t.plan(7);
	
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_argument_check : function() {},
		
		_createjs : primitives.get('createjs'),
		_source : {x:0, y:0},
		_duration : 1000,
	};
	
	//TEST
	t.notOk(move.is_moving(), "should be false before move");
	
	//override duration, with user defined value
	var destination = {x:1, y:1};
	move.prototype.to.call(mock_this, destination, {duration:500});
	
	//test with values that are less than the default, as should not pass if the default is used in the tween
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(mock_this._source.x > 0 && mock_this._source.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(mock_this._source.y > 0 && mock_this._source.y < 1, 'value should be on the way to 1, but not equal');
	}, 250);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "then false again after the move");
		t.equal(mock_this._source.x, destination.x, "source and destination should be the same after the move");
		t.equal(mock_this._source.y, destination.y, "source and destination should be the same after the move");
		TEARDOWN();
	}, 900);
});

test('[move.is_moving && move.to] correct, cannot start second tween while first is running', function (t) {
	t.plan(2);
	
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_argument_check : function() {},
		
		_createjs : primitives.get('createjs'),
		_source : {x:0, y:0},
		_duration : 1000,
	};
	
	//TEST
	
	//override duration, with user defined value
	var destination = {x:1, y:1};
	move.prototype.to.call(mock_this, destination, {duration:3000});
	
	//test with values that are less than the default, as should not pass if the default is used in the tween
	setTimeout(function() {
		t.notOk(move.prototype.to.call(mock_this, {x:15, y:15}, {duration:1}), "should return false during a tween, as cannot create a second tween during the first");
	}, 1500);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "wait for tween to complete so as not to pollute other tests");
		TEARDOWN();
	}, 3100);
});

test('[move] integration testing, correct, decorate and tween', function (t) {
	t.plan(8);
	
	SETUP();
	
	var test_obj = {x:0, y:0};
	test_obj._ = {};
	test_obj._.move = move(test_obj);
	
	var destination = {x:1, y:1};
	
	//TEST
	t.notOk(move.is_moving(), "should be false before the tween");
	t.ok(test_obj._.move.to(destination), "should return true to start a tween");
	
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(test_obj.x > 0 && test_obj.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(test_obj.y > 0 && test_obj.y < 1, 'value should be on the way to 1, but not equal');
	}, 500);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "should be false after the tween is complete");
		t.equal(test_obj.x, destination.x, "source and destination should be the same after the move");
		t.equal(test_obj.y, destination.y, "source and destination should be the same after the move");
		TEARDOWN();
	}, 1100);
});

test('[move] integration testing, correct, decorate two objects and verify cannot tween other objects while a tween is executing', function (t) {
	SETUP();
	
	var test_obj1 = {x:0, y:0};
	test_obj1._ = {};
	test_obj1._.move = move(test_obj1);
	
	var test_obj2 = {x:0, y:0};
	test_obj2._ = {};
	test_obj2._.move = move(test_obj2);
	
	var destination = {x:1, y:1};
	
	//TEST
	t.notOk(move.is_moving(), "should be false before the tween");
	t.ok(test_obj1._.move.to(destination), "should return true to start a tween");
	t.notOk(test_obj2._.move.to(destination), "cannot start up second tween, while the first is running");
	
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(test_obj1.x > 0 && test_obj1.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(test_obj1.y > 0 && test_obj1.y < 1, 'value should be on the way to 1, but not equal');
		t.equal(test_obj2.x, 0, "second object remains the same, as not tweened");
		t.equal(test_obj2.y, 0, "second object remains the same, as not tweened");
	}, 500);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "should be false after the tween is complete");
		t.equal(test_obj1.x, destination.x, "source and destination should be the same after the move");
		t.equal(test_obj1.y, destination.y, "source and destination should be the same after the move");
		t.equal(test_obj2.x, 0, "second object remains the same, as not tweened");
		t.equal(test_obj2.y, 0, "second object remains the same, as not tweened");
		TEARDOWN();
		t.end();
	}, 1100);
});
},{"check-types":6,"lib/util/move":71,"lib/util/primitives":73,"tape":108}],62:[function(require,module,exports){
var primitives = require('lib/util/primitives');
var test = require('tape');
var check = require('check-types');

test('[primitives] correct, Map is properly created on require()', function (t) {
	t.plan(1);
	
	t.ok(check.instanceStrict(primitives, Map), 'got back a Map on require()');
});

test('[primitives] correct, adding value is retrievable', function (t) {
	t.plan(1);
	
	//SETUP
	primitives.set('some key', {});
	
	//TEST
	t.deepEqual(primitives.get('some key'), {}, 'can retrieve items');
	
	//CLEANUP
	primitives.clear();
});

test('[primitives] correct, returns undefined on key not in Map', function (t) {
	t.plan(1);
	
	//TEST
	t.ok(check.undefined(primitives.get('some key')), 'undefined on no such key');
	
	//CLEANUP
	primitives.clear();
});
},{"check-types":6,"lib/util/primitives":73,"tape":108}],63:[function(require,module,exports){
var random_color = require('lib/util/random_color');
var test = require('tape');
var check = require('check-types');

test('[random_color] incorrect, bad argument type', function (t) {
	t.plan(2);
	try {
		random_color(0);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/string or undefined/), 'argument should be string or undefined');
	}
});

test('[random_color] correct, no argument', function (t) {
	t.plan(1);
	var result = random_color();
	t.ok(result.match(/(^#[0-9A-F]{3}$)/i), 'should be hex color of the form: #(hex)(hex)(hex)');
});

test('[random_color] incorrect, not color', function (t) {
	t.plan(2);
	try {
		random_color("some bad input");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/valid CSS color/), 'argument should be valid CSS color');
	}
});

test('[random_color] correct, high contrast color', function (t) {
	var result = random_color("#000");
	var contrast = require('wcag-contrast');
	
	t.plan(1);
	t.ok(contrast.score(contrast.hex(result, "#000")) === 'AA' || contrast.score(contrast.hex(result, "#000")) === 'AAA',
		'randomly chosen color should have good contrast with #000');
});

test('[random_color] correct, null', function (t) {
	var result = random_color(null);
	var contrast = require('wcag-contrast');
	
	t.plan(1);
	t.ok(result.match(/(^#[0-9A-F]{3}$)/i), 'should be hex color of the form: #(hex)(hex)(hex)');
});
},{"check-types":6,"lib/util/random_color":74,"tape":108,"wcag-contrast":166}],64:[function(require,module,exports){
var random_hex = require('lib/util/random_hex');
var test = require('tape');
var check = require('check-types');

test('[random_hex] correct, no arguments', function (t) {
	var result = random_hex();
	
	t.plan(1);
	t.ok(Number.parseInt(result, 16) >= 0 || Number.parseInt(result, 16) <= 16, "should be in default range [0, 16] (hex)");
});

test('[random_hex] correct, with arguments', function (t) {
	var result = random_hex(3);
	
	t.plan(1);
	t.ok(Number.parseInt(result, 16) >= 0 || Number.parseInt(result, 16) <= 4095, "should be in range [0, 4095] (hex)");
});

test('[random_hex] incorrect, argument too small', function (t) {
	t.plan(2);
	try {
		random_hex(0);
	} catch(error) {
		t.ok(check.instanceStrict(error, RangeError), 'we should get back a RangeError');
		var message = error.toString();
		t.ok(message.match(/greater than or equal to 1/), 'argument >= 1');
	}
});

test('[random_hex] incorrect, bad argument', function (t) {
	t.plan(2);
	try {
		random_hex("");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/number or undefined/), 'argument should be number or undefined');
	}
});
},{"check-types":6,"lib/util/random_hex":75,"tape":108}],65:[function(require,module,exports){
var random_integer = require('lib/util/random_integer');
var test = require('tape');
var check = require('check-types');

test('[random_integer] correct, no arguments', function (t) {
	var result = random_integer();

	t.plan(1);
	t.ok(result >= 0 || result <= 1000, "should be in default range [0, 1000]");
});

test('[random_integer] correct, valid arguments', function (t) {
	var result = random_integer(0, 1);

	t.plan(1);
	t.ok(result >= 0 || result <= 1, 'should be in range [0, 1]');
});

test('[random_integer] incorrect, single argument', function (t) {
	t.plan(2);
	try {
		random_integer(0);
	} catch(error) {
		t.ok(check.instanceStrict(error, Error), 'we should get back a basic Error');
		var message = error.toString();
		t.ok(message.match(/Incorrect number of arguments/), 'should see the error about incorrect number of arguments');
	}
});

test('[random_integer] incorrect, lower bound is larger than upper bound', function (t) {
	t.plan(2);
	try {
		random_integer(1, 0);
	} catch(error) {
		t.ok(check.instanceStrict(error, Error), 'we should get back a basic Error');
		var message = error.toString();
		t.ok(message.match(/Value Error/), 'should be an error of the value of the arguments');
	}
});

test('[random_integer] incorrect, bad input', function (t) {
	t.plan(2);
	try {
		random_integer(0, "1");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/number or undefined/), 'should be an error of the type of the argument');
	}
});
},{"check-types":6,"lib/util/random_integer":76,"tape":108}],66:[function(require,module,exports){
var type_of = require("lib/util/type_of");
var test = require('tape');

test('[type_of] NaN', function (t) {
	t.plan(1);
	t.equal(type_of(Number.NaN), 'NaN');
});

test('[type_of] \'\'', function (t) {
	t.plan(1);
	t.equal(type_of(""), 'empty String');
});
},{"lib/util/type_of":77,"tape":108}],67:[function(require,module,exports){
var unique_id = require('lib/util/unique_id');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[unique_id] correct, no argument', function (t) {
	t.plan(1);
	
	//SETUP
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	//TEST
	var result = unique_id();
	t.ok(/\_\d/,'get back an underscore followed by a digit');
	
	//CLEANUP
	primitives.clear();
});

test('[unique_id] correct, some argument', function (t) {
	t.plan(1);
	
	//SETUP
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	//TEST
	var result = unique_id('some prefix');
	t.ok(/some prefix\_\d/,'get back the prefix prepended to the id');
	
	//CLEANUP
	primitives.clear();
});

test("[unique_id] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//TEST
	try {
		unique_id();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		console.log(message);
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[unique_id] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		unique_id();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});
},{"check-types":6,"lib/util/primitives":73,"lib/util/unique_id":78,"tape":108}],68:[function(require,module,exports){
var primitives = require("lib/util/primitives");
var check = require('check-types');
var type_of = require('lib/util/type_of');

//used to add functionality to createjs objects, such that they can add themselves to the stage
//	if an object is already on the stage, then the function does nothing
function add_to_stage(obj) {
	//is argument a createjs object?
	if(!(check.instanceStrict(obj, createjs.DisplayObject))) {
		throw new TypeError('Cannot add object of type: ' + type_of(obj) + " to stage, requires createjs DisplayObject");
	}
	
	//is the stage already registered?
	var stage = primitives.get('stage');
	if (check.undefined(stage) || check.not.object(stage)) {
		throw new ReferenceError("'stage' undefined or not object in primitives object.");
	}
	
	var ret;
	
	//create a function used to decorate the createjs object, so it can be called to have the object add itself to the stage
	ret = function() {
		//is the object already on the stage?
		if(!(stage.contains(obj))) {
			//if not then add it
			stage.addChild(obj);
			stage.update();
		}
		//if it's already on the stage, do nothing
	};
	
	return ret;
};

module.exports = add_to_stage;
},{"check-types":6,"lib/util/primitives":73,"lib/util/type_of":77}],69:[function(require,module,exports){
//duck typing
//takes an object with properties of:
//	obj._.htmlElement (of type Element)
//	obj.htmlElement (of type Element)
//	obj.children (where append_to() calls append_to() on the children, if they have such a function)
//returns a function that either:
//	appends an html object to a parent html object in the dom (via appendChild())
//	calls append_to() on its children, if it has any
//the function accepts an html element
//	the html is then appended to an html element on the DOM
//		(or passed to child append_to() on a recursive call)
//	or an error is thrown if the object passed is not a valid html element
//source:https://github.com/substack/browserify-handbook#reusable-components

var check = require('check-types');

function append_to(obj) {
	if(!check.object(obj)) {
		throw new TypeError("Incorrect argument type, requires Object.");
	}
	
	//used to point to the correct HTML element, given the different forms the object can take (as below)
	var child_node;
	
	//the function used to apply an html Element (or container of one) directly to an Element in the DOM
	function direct_append_to(target) {
		if( !(check.instanceStrict(target, Element)) ) {
			throw new TypeError("Incorrect argument type, requires HTML Element.");
		}
		
		target.appendChild(child_node);
	}
	
	//form: obj.htmlElement
	if (!check.undefined(obj.htmlElement)) {
		if(check.instanceStrict(obj.htmlElement, Element)) {
			child_node = obj.htmlElement;
			return direct_append_to;	//return the function used to append the Element to the DOM
		} else {
			throw new TypeError("Incorrect property type, obj.htmlElement should be of type: HTML Element.");
		}
	}
	
	//form: obj._.htmlElement
	if (check.object(obj._)) {
		if (!check.undefined(obj._.htmlElement)) {
			if (check.instanceStrict(obj._.htmlElement, Element)) {
				child_node = obj._.htmlElement;
				return direct_append_to;	//return the function used to append the Element to the DOM
			} else {
				throw new TypeError("Incorrect property type, obj._.htmlElement should be of type: HTML Element.");
			}
		}
	}
	
	//function to use on containers, calls child append_to() functions on children
	//	will error at run time if not all children have an append_to function
	function indirect_append_to(target) {
		if( !(check.instanceStrict(target, Element)) ) {
			throw new TypeError("Incorrect argument type, requires HTML Element.");
		}
		
		//iterate through the children, append_to() on each, so we attach all HTML / DOMElement children to target
		//	(assuming that append_to() has been applied to the ._. namepsace)
		for (var i = 0; i < obj.children.length; i++) {
			if ( check.function(obj.children[i]._.append_to) ) {
				obj.children[i]._.append_to(target);
			} /* else {
				var type_of = require('lib/util/type_of');
				throw new TypeError('append_to on child ' + String(i) + ' was of type: ' + type_of(obj.children[i]._.append_to) + ', expected function.');
			} */
		}
	}
	
	//form: obj.children
	if (!check.undefined(obj.children)) {
		if(check.array(obj.children)) {
			return indirect_append_to;
		} else {
			throw new TypeError("Property 'children' should be of type array.");
		}
	}
	
	throw new TypeError("Object was of incorrect form, see documentation for acceptable forms.");
};

module.exports = append_to;
},{"check-types":6}],70:[function(require,module,exports){
//check if an argument object has valid parameters, throws with informative error if does not
//usage: 
//in function, wrap in a try...catch block, if it throws then there's an error with the type of arguments passed
//if not then all arguments pass their tests, get back an object with validated argument or empty object on no options passed

//https://www.npmjs.com/package/check-types
var check = require('check-types');	//used for checking types of arguments
var default_argument_types = {
	width : {
		is_correct_type: function(n) {
				if (!check.number(n)) return false;
				if (n <= 0) return false;
				return true;
			},
		should_be: "number ( greater than zero )",
		},
	height : {
		is_correct_type: function(n) {
				if (!check.number(n)) return false;
				if (n <= 0) return false;
				return true;
			},
		should_be: "number ( greater than zero )",
		},
	radius : {
		is_correct_type: function(n) {
				if (!check.number(n)) return false;
				if (n <= 0) return false;
				return true;
			},
		should_be: "number ( greater than zero )",
		},
	x : {
		is_correct_type: check.number,
		should_be: "number",
		},
	y : {
		is_correct_type: check.number,
		should_be: "number",
		},
	fill : {
		is_correct_type: function(str) {
				if (check.null(str)) return true;
				if (!check.nonEmptyString(str)) return false;
				var colorString = require("color-string");
				if(!colorString.get(str)) return false;
				return true;
			},
		should_be: "non-empty String (of a valid CSS color) or null",
		},
	stroke : {
		is_correct_type: function(str) {
				if (check.null(str)) return true;
				if (!check.nonEmptyString(str)) return false;
				var colorString = require("color-string");
				if(!colorString.get(str)) return false;
				return true;
			},
		should_be: "non-empty String (of a valid CSS color) or null",
		},
	font : {
		is_correct_type: function(str) {
			if (!check.nonEmptyString(str)) return false;
			
			var parseCssFont = require('parse-css-font');
			try {
				parseCssFont(str);
			} catch(e) {
				return false;
			}
			
			return true;
		},
		should_be: "non-empty String (of a valid CSS font)",
		},
	//text, we can String() anything, so just let the caller turn it into a String as required
	color : {
		is_correct_type: function(str) {
				if (check.null(str)) return true;
				if (!check.nonEmptyString(str)) return false;
				var colorString = require("color-string");
				if(!colorString.get(str)) return false;
				return true;
			},
		should_be: "non-empty String (of a valid CSS color) or null",
		},
	textAlign : {
		is_correct_type: function(str) {
				if (!check.nonEmptyString(str)) return false;
				
				//Array.includes() is not available?
				if (Array.from(["start", "end", "left", "right", "center"]).indexOf(str) === -1) return false;
				
				return true;
			},
		should_be: 'non-empty String (of one of these: ' + String("start, end, left, right, center") + ')',
		},
	//used in factories
	type: {
		is_correct_type: check.nonEmptyString,
		should_be: 'non-empty String',
		},
};

//improved version of `typeof`, used for getting actual type for printing error messages
var type_of = require('lib/util/type_of');

module.exports = function(arguments) {
	//if empty or undefined, just return empty
	if(check.emptyObject(arguments) || check.undefined(arguments)) {
		return {};
	}
	
	//otherwise argument should be an object
	if(!check.object(arguments)) {
		throw new TypeError("Arguments to argument_check was " + type_of(arguments) + ", should be: object");
	}
	
	var ret = {};
	
	//check through each property of the argument object passed in
	for (argument in arguments) {
		//if we have a default rule for what a named argument's type should be ...
		if (argument in default_argument_types) {
			var argument_name = "'" + String(argument) + "'";
			var argument_value = arguments[argument];
			var argument_type = type_of(argument_value);	//get a string of the detected type
			var argument_type_should_be_type = default_argument_types[argument].should_be;
			var error_msg = "Variable: " + argument_name + " was " + argument_type + ", should be: " + argument_type_should_be_type;
			
			//...and if it doesn't pass the type check...
			if (!default_argument_types[argument].is_correct_type(argument_value)) {
				//...then throw with information on: 
				//	what type was detected
				//	and what type it needs to be
				throw new TypeError(error_msg);
			}
		} else {
			//...we don't have a rule for it, but no argument should have a value of "undefined"
			if (check.undefined(arguments[argument])) {
				var error_msg = "Variable: " + argument + " was undefined.";
				throw new TypeError(error_msg);
			}
		}
		
		//...if there is no default rule and no error, then just the argument and its value to the return object, validated
		ret[argument] = arguments[argument];
	}
	return ret;
};
},{"check-types":6,"color-string":8,"lib/util/type_of":77,"parse-css-font":82}],71:[function(require,module,exports){
//tween an object from one location to another
//	if another move is already taking place, then do nothing (mutex)

//move() is decorated on to an object with the idiom:
//	source_object._.move.to(destination)
//(see below for method definitions)

var check = require('check-types');
var primitives = require("lib/util/primitives");

//internal mutex, tracks if an animation is currently occuring
var _is_moving = false;

//source should be an object to be tweened, with position values (x, y)
//destination arguments (methods, below) should be an object with properties (coordinates) ({x:value, y:value})
//	optional: duration, a numeric value for how long the tween should take (set in the constructor, but can be overriden on methods, below)
function move(source, options) {
	if (!(this instanceof move)) return new move(source, options);
	
	//is createjs already registered?
	this._createjs = primitives.get('createjs');
	if (check.undefined(this._createjs) || check.not.object(this._createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	this._argument_check(source);
	this._source = source;
	
	//1 second default tween duration
	this._duration = 1000;
	if (check.object(options) && check.number(options.duration) && options.duration > 0) {
		//else use an optional duration for the tween
		this._duration = options.duration;
	}
}

move.prototype = {
	//METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS-METHODS
	
	//TODO: add functionality to only tween a single property at a time
	//	(only requires x or y, but not both and only the set one is used)
	
	//private
	//check if arg is an object and has properties (x, y), if not then throws with informative error
	//(all methods should have this type of argument)
	_argument_check : function(arg) {
		if (check.not.object(arg)) {
			throw new TypeError('Requires argument, object');
		}
		
		if (check.undefined(arg.x) || check.not.number(arg.x)) {
			throw new TypeError("Argument requires numeric property x.");
		}
		
		if (check.undefined(arg.y) || check.not.number(arg.y)) {
			throw new TypeError("Argument requires numeric property y.");
		}
		
		return true;
	},
	
	//public
	//tween an object (source, as passed to constructor, above) to a destination (an object with (x, y) properties)
	//	taking an optional duration argument
	to : function(destination, options) {
		this._argument_check(destination);
		
		var duration = this._duration;
		if (check.object(options) && check.number(options.duration) && options.duration > 0) {
			//else use an optional duration for the tween
			duration = options.duration;
		}
		
		if (_is_moving) {
			//if we're currently tweening, then do nothing
			return false;
		} else {
			_is_moving = true;
			createjs.Tween.get(this._source).to({x:destination.x, y:destination.y}, duration).call(function() {
				//once tween is finished, then unlock the mutex to allow other tweens to execute
				_is_moving = false;
			});
			return true;
		}
	},
	
	//PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES-PROPERTIES
	_createjs : undefined,	//reference to the createjs object used to Tween
	_source : undefined,	//the object to be move()d
	_duration : undefined,	//the amount of time a tween should take (can be overriden in each method)
};

//static method, returns if a tween is currently occuring
move.is_moving = function() {
	return _is_moving;
}

module.exports = move;
},{"check-types":6,"lib/util/primitives":73}],72:[function(require,module,exports){
module.exports = place;

//allows setting of convenience methods on object
//such that we can position a Shape(like) object:
//shape.place.(a position near)(other_shape)

var check = require('check-types');

function place(context, options) {
	if (!(this instanceof place)) return new place(context, options);
	
	this._argument_check(context);
	
	this._context = context;
}

place.prototype = {
	//NOTE: in all setter methods, we use the idiom:
	//	shape.x = target.x - shape.bounds.(x, y)
	//	this is to take into account the special requirements of positioning circles correctly
	//	circles are placed with their center at their (x, y) coordinate, while rectangles are placed with their top left hand corner at their (x, y)
	//	thus when we set bounds we include the amount of offset in x and y between the center of the circle and the top left hand corner of the circle
	//	thus if we subtract the values from their bounds, we get positive amounts of offset
	//	that is required to place the circles directly under other figures, without overlap
	
	//shape.place.under(other_shape);
	//adjust position of shape, such that it is directly below other_shape
	below : function(target) {
		this._argument_check(target);
		
		this._context.x = target.x - this._context.getBounds().x;
		this._context.y = target.y + target.getBounds().height - this._context.getBounds().y;
	},
	
	//shape.place.above(other_shape);
	//adjust position of shape, such that it is directly above other_shape
	above : function(target) {
		this._argument_check(target);
		
		this._context.x = target.x - this._context.getBounds().x;
		this._context.y = target.y + this._context.getBounds().y;
	},
	
	//TODO: for left and right positioning, align circular shapes with the centers of their targets
	//	maybe some sort of transform such that the x and y position of circles is counted as their top left corners?
	
	//shape.place.to_the_left_of(other_shape);
	//adjust position of shape, such that it is directly to the left of other_shape
	to_the_left_of : function(target) {
		this._argument_check(target);
		
		this._context.x = target.x + this._context.getBounds().x;
		this._context.y = target.y
	},
	
	//shape.place.to_the_right_of(other_shape);
	//adjust position of shape, such that it is directly to the right of other_shape
	to_the_right_of : function(target) {
		this._argument_check(target);
		
		this._context.x = target.x + target.getBounds().width - this._context.getBounds().x;
		this._context.y = target.y;
	},
	
	_argument_check : function(obj) {
		if (check.undefined(obj.x) || check.undefined(obj.y)) {
			throw new TypeError("argument should be like a createjs.Shape (needs x and y properties).");
		}
		
		if(check.null(obj.getBounds())) {
			throw new ReferenceError("argument should have bounds set, such that getBounds() returns object.");
		}
	},
	
	//private
	//holds the reference to the Shape to manipulate with functions ^
	_context : undefined,
}
},{"check-types":6}],73:[function(require,module,exports){
//provides a unified require()able interface for those objects are assumed globals in the Animate code
//	implimented by a singleton javascript Map

//by convention keys are the same name as the global variables form which they are sourced
//	e.g. the global "createjs" has a key "createjs" referencing the createjs object

var _primitives;

if (!_primitives) {
	_primitives = new Map();
}

module.exports = _primitives;
},{}],74:[function(require,module,exports){
//get a random CSS color (a string: # followed 3 hex digits)
//or optionally, given a hex color string find a random color whose WCAG color contrast score is at least AA
module.exports = function(color) {
	var check = require('check-types');
	if (!check.maybe.string(color)) {
		throw new TypeError('Argument should be string or undefined');
	}
	
	var random_hex = require('lib/util/random_hex');
	var colorString = require("color-string");	//check for valid color strings, colorString.get() returns null on invalid string
	if (check.undefined(color) || check.null(color)) {
		//just get a random hex color
		//as everything contrasts with no color or we just wanted a random color
		return "#" + random_hex(3);
	} else {
		if (!colorString.get(color)) {
			throw new TypeError('Argument should be valid CSS color (#000 - #fff)');
		}
		
		//get a random color that has good contrast with the argument color
		var contrast = require('wcag-contrast');
		while (true) {
			var random_color = random_hex(3);
			var contrast_score = contrast.score(contrast.hex(random_color, color));
			if (contrast_score === 'AA' || contrast_score === 'AAA') {
				return '#' + random_color;
			}
		}
	}
};
},{"check-types":6,"color-string":8,"lib/util/random_hex":75,"wcag-contrast":166}],75:[function(require,module,exports){
//generate random hex number, of optional amount count (default 1)

var random;

module.exports = function(count) {
	var check = require('check-types');
	if (!check.maybe.number(count)) {
		throw new TypeError('Argument should be number or undefined');
	}
	
	if (count <= 0) {
		throw new RangeError('Argument should be greater than or equal to 1');
	}
	
	if (!random) random = require("random-js")();
	
	return random.hex(count || 1);
};
},{"check-types":6,"random-js":88}],76:[function(require,module,exports){
//generate a random integer in the given bounds (default from 0 to 1000 inclusive, as per LaFore)
var random;

module.exports = function(start, end) {
	if (!(arguments.length === 2 || arguments.length === 0)) {
		throw new Error('Incorrect number of arguments: either two (lower and upper bound) or zero (using defaults: [0, 1000]).');
	}
	
	var check = require('check-types');
	if (!check.maybe.number(start)) {
		throw new TypeError('Argument should be number or undefined');
	}
	if (!check.maybe.number(end)) {
		throw new TypeError('Argument should be number or undefined');
	}
	
	if (start >= end) {
		throw new Error('Value Error: lower bound should be less than upper bound.');
	}
	
	if (!random) random = require("random-js")();
	
	return random.integer(start || 0, end || 1000);
};
},{"check-types":6,"random-js":88}],77:[function(require,module,exports){
//replacing broken javascript typeof
//return a String representation of the type of value

var check = require('check-types');

module.exports = function type_of(value) {
	if (Number.isNaN(value)) {return "NaN";}
	if (check.emptyString(value)) {return "empty String";}
	//https://www.npmjs.com/package/type-of-is
	return (require('type-of-is')).string(value);
}
},{"check-types":6,"type-of-is":161}],78:[function(require,module,exports){
var check = require('check-types');
var primitives = require("lib/util/primitives");

function unique_id(prefix) {
	var p = '';
	
	if (!check.undefined(prefix)) {
		p = String(prefix);
	}
	
	//is createjs already registered?
	var createjs = primitives.get('createjs');
	if (check.undefined(createjs) || check.not.object(createjs)) {
		throw new ReferenceError("'createjs' undefined or not object in primitives object.");
	}
	
	//UID is createjs's method of generating unique id's
	//http://www.createjs.com/docs/easeljs/classes/UID.html
	return p + '_' + createjs.UID.get();
}

module.exports = unique_id;
},{"check-types":6,"lib/util/primitives":73}],79:[function(require,module,exports){
var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var booleanValueOf = Boolean.prototype.valueOf;

module.exports = function inspect_ (obj, opts, depth, seen) {
    if (!opts) opts = {};
    
    var maxDepth = opts.depth === undefined ? 5 : opts.depth;
    if (depth === undefined) depth = 0;
    if (depth >= maxDepth && maxDepth > 0 && obj && typeof obj === 'object') {
        return '[Object]';
    }
    
    if (seen === undefined) seen = [];
    else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }
    
    function inspect (value, from) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        return inspect_(value, opts, depth + 1, seen);
    }
    
    if (typeof obj === 'string') {
        return inspectString(obj);
    }
    else if (typeof obj === 'function') {
        var name = nameOf(obj);
        return '[Function' + (name ? ': ' + name : '') + ']';
    }
    else if (obj === null) {
        return 'null';
    }
    else if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;
    }
    else if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '="' + quote(attrs[i].value) + '"';
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) s += '...';
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    else if (isArray(obj)) {
        if (obj.length === 0) return '[]';
        var xs = Array(obj.length);
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    else if (isError(obj)) {
        var parts = [];
        for (var key in obj) {
            if (!has(obj, key)) continue;
            
            if (/[^\w$]/.test(key)) {
                parts.push(inspect(key) + ': ' + inspect(obj[key]));
            }
            else {
                parts.push(key + ': ' + inspect(obj[key]));
            }
        }
        if (parts.length === 0) return '[' + obj + ']';
        return '{ [' + obj + '] ' + parts.join(', ') + ' }';
    }
    else if (typeof obj === 'object' && typeof obj.inspect === 'function') {
        return obj.inspect();
    }
    else if (isMap(obj)) {
        var parts = [];
        mapForEach.call(obj, function (value, key) {
            parts.push(inspect(key, obj) + ' => ' + inspect(value, obj));
        });
        return 'Map (' + mapSize.call(obj) + ') {' + parts.join(', ') + '}';
    }
    else if (isSet(obj)) {
        var parts = [];
        setForEach.call(obj, function (value ) {
            parts.push(inspect(value, obj));
        });
        return 'Set (' + setSize.call(obj) + ') {' + parts.join(', ') + '}';
    }
    else if (typeof obj !== 'object') {
        return String(obj);
    }
    else if (isNumber(obj)) {
        return 'Object(' + Number(obj) + ')';
    }
    else if (isBoolean(obj)) {
        return 'Object(' + booleanValueOf.call(obj) + ')';
    }
    else if (isString(obj)) {
        return 'Object(' + inspect(String(obj)) + ')';
    }
    else if (!isDate(obj) && !isRegExp(obj)) {
        var xs = [], keys = [];
        for (var key in obj) {
            if (has(obj, key)) keys.push(key);
        }
        keys.sort();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (/[^\w$]/.test(key)) {
                xs.push(inspect(key) + ': ' + inspect(obj[key], obj));
            }
            else xs.push(key + ': ' + inspect(obj[key], obj));
        }
        if (xs.length === 0) return '{}';
        return '{ ' + xs.join(', ') + ' }';
    }
    else return String(obj);
};

function quote (s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray (obj) { return toStr(obj) === '[object Array]' }
function isDate (obj) { return toStr(obj) === '[object Date]' }
function isRegExp (obj) { return toStr(obj) === '[object RegExp]' }
function isError (obj) { return toStr(obj) === '[object Error]' }
function isSymbol (obj) { return toStr(obj) === '[object Symbol]' }
function isString (obj) { return toStr(obj) === '[object String]' }
function isNumber (obj) { return toStr(obj) === '[object Number]' }
function isBoolean (obj) { return toStr(obj) === '[object Boolean]' }

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has (obj, key) {
    return hasOwn.call(obj, key);
}

function toStr (obj) {
    return Object.prototype.toString.call(obj);
}

function nameOf (f) {
    if (f.name) return f.name;
    var m = f.toString().match(/^function\s*([\w$]+)/);
    if (m) return m[1];
}

function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
}

function isMap (x) {
    if (!mapSize) {
        return false;
    }
    try {
        mapSize.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet (x) {
    if (!setSize) {
        return false;
    }
    try {
        setSize.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isElement (x) {
    if (!x || typeof x !== 'object') return false;
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string'
        && typeof x.getAttribute === 'function'
    ;
}

function inspectString (str) {
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return "'" + s + "'";
    
    function lowbyte (c) {
        var n = c.charCodeAt(0);
        var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
        if (x) return '\\' + x;
        return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
    }
}

},{}],80:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":81}],81:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],82:[function(require,module,exports){
var t = require('tcomb');
var unquote = require('unquote');
var globalKeywords = require('css-global-keywords');
var systemFontKeywords = require('css-system-font-keywords');
var fontWeightKeywords = require('css-font-weight-keywords');
var fontStyleKeywords = require('css-font-style-keywords');
var fontStretchKeywords = require('css-font-stretch-keywords');
var cssListHelpers = require('css-list-helpers');

var helpers = require('./lib/helpers');

var SystemFont = t.struct({
	system: t.String
});

var Font = t.struct({
	style: t.String,
	variant: t.String,
	weight: t.String,
	stretch: t.String,
	size: t.String,
	lineHeight: t.union([t.String, t.Number]),
	family: t.list(t.String)
});

var Result = t.union([Font, SystemFont]);

module.exports = t.func(t.String, t.Object).of(
	function(value) {

		if (value === '') {
			throw error('Cannot parse an empty string.');
		}

		if (systemFontKeywords.indexOf(value) !== -1) {
			return SystemFont({ system: value });
		}

		var font = {
			style: 'normal',
			variant: 'normal',
			weight: 'normal',
			stretch: 'normal',
			lineHeight: 'normal'
		};

		var isLocked = false;
		var tokens = cssListHelpers.splitBySpaces(value);
		var token = tokens.shift();
		for (; !t.Nil.is(token); token = tokens.shift()) {

			if (token === 'normal' || globalKeywords.indexOf(token) !== -1) {
				['style', 'variant', 'weight', 'stretch'].forEach(function(prop) {
					font[prop] = token;
				});
				isLocked = true;
				continue;
			}

			if (fontWeightKeywords.indexOf(token) !== -1) {
				if (isLocked) {
					continue;
				}
				font.weight = token;
				continue;
			}

			if (fontStyleKeywords.indexOf(token) !== -1) {
				if (isLocked) {
					continue;
				}
				font.style = token;
				continue;
			}

			if (fontStretchKeywords.indexOf(token) !== -1) {
				if (isLocked) {
					continue;
				}
				font.stretch = token;
				continue;
			}

			if (helpers.isSize(token)) {
				var parts = cssListHelpers.split(token, ['/']);
				font.size = parts[0];
				if (!t.Nil.is(parts[1])) {
					font.lineHeight = parseLineHeight(parts[1]);
				}
				if (!tokens.length) {
					throw error('Missing required font-family.');
				}
				font.family = cssListHelpers.splitByCommas(tokens.join(' ')).map(unquote);
				return Font(font);
			}

			if (font.variant !== 'normal') {
				throw error('Unknown or unsupported font token: ' + font.variant);
			}

			if (isLocked) {
				continue;
			}
			font.variant = token;
		}

		throw error('Missing required font-size.');
	}
);

function error(message) {
	return new Error('[parse-css-font] ' + message);
}

function parseLineHeight(value) {
	var parsed = parseFloat(value);
	if (parsed.toString() === value) {
		return parsed;
	}
	return value;
}

},{"./lib/helpers":83,"css-font-stretch-keywords":11,"css-font-style-keywords":12,"css-font-weight-keywords":13,"css-global-keywords":14,"css-list-helpers":15,"css-system-font-keywords":16,"tcomb":112,"unquote":162}],83:[function(require,module,exports){
var cssFontSizeKeywords = require('css-font-size-keywords');

module.exports = {

	isSize: function(value) {
		return /^[\d\.]/.test(value)
			|| value.indexOf('/') !== -1
			|| cssFontSizeKeywords.indexOf(value) !== -1
		;
	}

};

},{"css-font-size-keywords":10}],84:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":86}],85:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))
},{"_process":86}],86:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
    try {
        cachedSetTimeout = setTimeout;
    } catch (e) {
        cachedSetTimeout = function () {
            throw new Error('setTimeout is not defined');
        }
    }
    try {
        cachedClearTimeout = clearTimeout;
    } catch (e) {
        cachedClearTimeout = function () {
            throw new Error('clearTimeout is not defined');
        }
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
    } else {
        return cachedSetTimeout.call(null, fun, 0);
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        clearTimeout(marker);
    } else {
        cachedClearTimeout.call(null, marker);
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],87:[function(require,module,exports){
/*
Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk
License: MIT - http://mrgnrdrck.mit-license.org

https://github.com/mroderick/PubSubJS
*/
(function (root, factory){
	'use strict';

    if (typeof define === 'function' && define.amd){
        // AMD. Register as an anonymous module.
        define(['exports'], factory);

    } else if (typeof exports === 'object'){
        // CommonJS
        factory(exports);

    }

    // Browser globals
    var PubSub = {};
    root.PubSub = PubSub;
    factory(PubSub);
    
}(( typeof window === 'object' && window ) || this, function (PubSub){
	'use strict';

	var messages = {},
		lastUid = -1;

	function hasKeys(obj){
		var key;

		for (key in obj){
			if ( obj.hasOwnProperty(key) ){
				return true;
			}
		}
		return false;
	}

	/**
	 *	Returns a function that throws the passed exception, for use as argument for setTimeout
	 *	@param { Object } ex An Error object
	 */
	function throwException( ex ){
		return function reThrowException(){
			throw ex;
		};
	}

	function callSubscriberWithDelayedExceptions( subscriber, message, data ){
		try {
			subscriber( message, data );
		} catch( ex ){
			setTimeout( throwException( ex ), 0);
		}
	}

	function callSubscriberWithImmediateExceptions( subscriber, message, data ){
		subscriber( message, data );
	}

	function deliverMessage( originalMessage, matchedMessage, data, immediateExceptions ){
		var subscribers = messages[matchedMessage],
			callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,
			s;

		if ( !messages.hasOwnProperty( matchedMessage ) ) {
			return;
		}

		for (s in subscribers){
			if ( subscribers.hasOwnProperty(s)){
				callSubscriber( subscribers[s], originalMessage, data );
			}
		}
	}

	function createDeliveryFunction( message, data, immediateExceptions ){
		return function deliverNamespaced(){
			var topic = String( message ),
				position = topic.lastIndexOf( '.' );

			// deliver the message as it is now
			deliverMessage(message, message, data, immediateExceptions);

			// trim the hierarchy and deliver message to each level
			while( position !== -1 ){
				topic = topic.substr( 0, position );
				position = topic.lastIndexOf('.');
				deliverMessage( message, topic, data, immediateExceptions );
			}
		};
	}

	function messageHasSubscribers( message ){
		var topic = String( message ),
			found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic])),
			position = topic.lastIndexOf( '.' );

		while ( !found && position !== -1 ){
			topic = topic.substr( 0, position );
			position = topic.lastIndexOf( '.' );
			found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic]));
		}

		return found;
	}

	function publish( message, data, sync, immediateExceptions ){
		var deliver = createDeliveryFunction( message, data, immediateExceptions ),
			hasSubscribers = messageHasSubscribers( message );

		if ( !hasSubscribers ){
			return false;
		}

		if ( sync === true ){
			deliver();
		} else {
			setTimeout( deliver, 0 );
		}
		return true;
	}

	/**
	 *	PubSub.publish( message[, data] ) -> Boolean
	 *	- message (String): The message to publish
	 *	- data: The data to pass to subscribers
	 *	Publishes the the message, passing the data to it's subscribers
	**/
	PubSub.publish = function( message, data ){
		return publish( message, data, false, PubSub.immediateExceptions );
	};

	/**
	 *	PubSub.publishSync( message[, data] ) -> Boolean
	 *	- message (String): The message to publish
	 *	- data: The data to pass to subscribers
	 *	Publishes the the message synchronously, passing the data to it's subscribers
	**/
	PubSub.publishSync = function( message, data ){
		return publish( message, data, true, PubSub.immediateExceptions );
	};

	/**
	 *	PubSub.subscribe( message, func ) -> String
	 *	- message (String): The message to subscribe to
	 *	- func (Function): The function to call when a new message is published
	 *	Subscribes the passed function to the passed message. Every returned token is unique and should be stored if
	 *	you need to unsubscribe
	**/
	PubSub.subscribe = function( message, func ){
		if ( typeof func !== 'function'){
			return false;
		}

		// message is not registered yet
		if ( !messages.hasOwnProperty( message ) ){
			messages[message] = {};
		}

		// forcing token as String, to allow for future expansions without breaking usage
		// and allow for easy use as key names for the 'messages' object
		var token = 'uid_' + String(++lastUid);
		messages[message][token] = func;

		// return token for unsubscribing
		return token;
	};

	/* Public: Clears all subscriptions
	 */
	PubSub.clearAllSubscriptions = function clearAllSubscriptions(){
		messages = {};
	};

	/*Public: Clear subscriptions by the topic
	*/
	PubSub.clearSubscriptions = function clearSubscriptions(topic){
		var m; 
		for (m in messages){
			if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0){
				delete messages[m];
			}
		}
	};

	/* Public: removes subscriptions.
	 * When passed a token, removes a specific subscription.
	 * When passed a function, removes all subscriptions for that function
	 * When passed a topic, removes all subscriptions for that topic (hierarchy)
	 *
	 * value - A token, function or topic to unsubscribe.
	 *
	 * Examples
	 *
	 *		// Example 1 - unsubscribing with a token
	 *		var token = PubSub.subscribe('mytopic', myFunc);
	 *		PubSub.unsubscribe(token);
	 *
	 *		// Example 2 - unsubscribing with a function
	 *		PubSub.unsubscribe(myFunc);
	 *
	 *		// Example 3 - unsubscribing a topic
	 *		PubSub.unsubscribe('mytopic');
	 */
	PubSub.unsubscribe = function(value){
		var isTopic    = typeof value === 'string' && messages.hasOwnProperty(value),
			isToken    = !isTopic && typeof value === 'string',
			isFunction = typeof value === 'function',
			result = false,
			m, message, t;

		if (isTopic){
			delete messages[value];
			return;
		}

		for ( m in messages ){
			if ( messages.hasOwnProperty( m ) ){
				message = messages[m];

				if ( isToken && message[value] ){
					delete message[value];
					result = value;
					// tokens are unique, so we can just stop here
					break;
				}

				if (isFunction) {
					for ( t in message ){
						if (message.hasOwnProperty(t) && message[t] === value){
							delete message[t];
							result = true;
						}
					}
				}
			}
		}

		return result;
	};
}));

},{}],88:[function(require,module,exports){
/*jshint eqnull:true*/
(function (root) {
  "use strict";

  var GLOBAL_KEY = "Random";

  var imul = (typeof Math.imul !== "function" || Math.imul(0xffffffff, 5) !== -5 ?
    function (a, b) {
      var ah = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      // the shift by 0 fixes the sign on the high part
      // the final |0 converts the unsigned value into a signed value
      return (al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0;
    } :
    Math.imul);

  var stringRepeat = (typeof String.prototype.repeat === "function" && "x".repeat(3) === "xxx" ?
    function (x, y) {
      return x.repeat(y);
    } : function (pattern, count) {
      var result = "";
      while (count > 0) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result;
    });

  function Random(engine) {
    if (!(this instanceof Random)) {
      return new Random(engine);
    }

    if (engine == null) {
      engine = Random.engines.nativeMath;
    } else if (typeof engine !== "function") {
      throw new TypeError("Expected engine to be a function, got " + typeof engine);
    }
    this.engine = engine;
  }
  var proto = Random.prototype;

  Random.engines = {
    nativeMath: function () {
      return (Math.random() * 0x100000000) | 0;
    },
    mt19937: (function (Int32Array) {
      // http://en.wikipedia.org/wiki/Mersenne_twister
      function refreshData(data) {
        var k = 0;
        var tmp = 0;
        for (;
          (k | 0) < 227; k = (k + 1) | 0) {
          tmp = (data[k] & 0x80000000) | (data[(k + 1) | 0] & 0x7fffffff);
          data[k] = data[(k + 397) | 0] ^ (tmp >>> 1) ^ ((tmp & 0x1) ? 0x9908b0df : 0);
        }

        for (;
          (k | 0) < 623; k = (k + 1) | 0) {
          tmp = (data[k] & 0x80000000) | (data[(k + 1) | 0] & 0x7fffffff);
          data[k] = data[(k - 227) | 0] ^ (tmp >>> 1) ^ ((tmp & 0x1) ? 0x9908b0df : 0);
        }

        tmp = (data[623] & 0x80000000) | (data[0] & 0x7fffffff);
        data[623] = data[396] ^ (tmp >>> 1) ^ ((tmp & 0x1) ? 0x9908b0df : 0);
      }

      function temper(value) {
        value ^= value >>> 11;
        value ^= (value << 7) & 0x9d2c5680;
        value ^= (value << 15) & 0xefc60000;
        return value ^ (value >>> 18);
      }

      function seedWithArray(data, source) {
        var i = 1;
        var j = 0;
        var sourceLength = source.length;
        var k = Math.max(sourceLength, 624) | 0;
        var previous = data[0] | 0;
        for (;
          (k | 0) > 0; --k) {
          data[i] = previous = ((data[i] ^ imul((previous ^ (previous >>> 30)), 0x0019660d)) + (source[j] | 0) + (j | 0)) | 0;
          i = (i + 1) | 0;
          ++j;
          if ((i | 0) > 623) {
            data[0] = data[623];
            i = 1;
          }
          if (j >= sourceLength) {
            j = 0;
          }
        }
        for (k = 623;
          (k | 0) > 0; --k) {
          data[i] = previous = ((data[i] ^ imul((previous ^ (previous >>> 30)), 0x5d588b65)) - i) | 0;
          i = (i + 1) | 0;
          if ((i | 0) > 623) {
            data[0] = data[623];
            i = 1;
          }
        }
        data[0] = 0x80000000;
      }

      function mt19937() {
        var data = new Int32Array(624);
        var index = 0;
        var uses = 0;

        function next() {
          if ((index | 0) >= 624) {
            refreshData(data);
            index = 0;
          }

          var value = data[index];
          index = (index + 1) | 0;
          uses += 1;
          return temper(value) | 0;
        }
        next.getUseCount = function() {
          return uses;
        };
        next.discard = function (count) {
          uses += count;
          if ((index | 0) >= 624) {
            refreshData(data);
            index = 0;
          }
          while ((count - index) > 624) {
            count -= 624 - index;
            refreshData(data);
            index = 0;
          }
          index = (index + count) | 0;
          return next;
        };
        next.seed = function (initial) {
          var previous = 0;
          data[0] = previous = initial | 0;

          for (var i = 1; i < 624; i = (i + 1) | 0) {
            data[i] = previous = (imul((previous ^ (previous >>> 30)), 0x6c078965) + i) | 0;
          }
          index = 624;
          uses = 0;
          return next;
        };
        next.seedWithArray = function (source) {
          next.seed(0x012bd6aa);
          seedWithArray(data, source);
          return next;
        };
        next.autoSeed = function () {
          return next.seedWithArray(Random.generateEntropyArray());
        };
        return next;
      }

      return mt19937;
    }(typeof Int32Array === "function" ? Int32Array : Array)),
    browserCrypto: (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function" && typeof Int32Array === "function") ? (function () {
      var data = null;
      var index = 128;

      return function () {
        if (index >= 128) {
          if (data === null) {
            data = new Int32Array(128);
          }
          crypto.getRandomValues(data);
          index = 0;
        }

        return data[index++] | 0;
      };
    }()) : null
  };

  Random.generateEntropyArray = function () {
    var array = [];
    var engine = Random.engines.nativeMath;
    for (var i = 0; i < 16; ++i) {
      array[i] = engine() | 0;
    }
    array.push(new Date().getTime() | 0);
    return array;
  };

  function returnValue(value) {
    return function () {
      return value;
    };
  }

  // [-0x80000000, 0x7fffffff]
  Random.int32 = function (engine) {
    return engine() | 0;
  };
  proto.int32 = function () {
    return Random.int32(this.engine);
  };

  // [0, 0xffffffff]
  Random.uint32 = function (engine) {
    return engine() >>> 0;
  };
  proto.uint32 = function () {
    return Random.uint32(this.engine);
  };

  // [0, 0x1fffffffffffff]
  Random.uint53 = function (engine) {
    var high = engine() & 0x1fffff;
    var low = engine() >>> 0;
    return (high * 0x100000000) + low;
  };
  proto.uint53 = function () {
    return Random.uint53(this.engine);
  };

  // [0, 0x20000000000000]
  Random.uint53Full = function (engine) {
    while (true) {
      var high = engine() | 0;
      if (high & 0x200000) {
        if ((high & 0x3fffff) === 0x200000 && (engine() | 0) === 0) {
          return 0x20000000000000;
        }
      } else {
        var low = engine() >>> 0;
        return ((high & 0x1fffff) * 0x100000000) + low;
      }
    }
  };
  proto.uint53Full = function () {
    return Random.uint53Full(this.engine);
  };

  // [-0x20000000000000, 0x1fffffffffffff]
  Random.int53 = function (engine) {
    var high = engine() | 0;
    var low = engine() >>> 0;
    return ((high & 0x1fffff) * 0x100000000) + low + (high & 0x200000 ? -0x20000000000000 : 0);
  };
  proto.int53 = function () {
    return Random.int53(this.engine);
  };

  // [-0x20000000000000, 0x20000000000000]
  Random.int53Full = function (engine) {
    while (true) {
      var high = engine() | 0;
      if (high & 0x400000) {
        if ((high & 0x7fffff) === 0x400000 && (engine() | 0) === 0) {
          return 0x20000000000000;
        }
      } else {
        var low = engine() >>> 0;
        return ((high & 0x1fffff) * 0x100000000) + low + (high & 0x200000 ? -0x20000000000000 : 0);
      }
    }
  };
  proto.int53Full = function () {
    return Random.int53Full(this.engine);
  };

  function add(generate, addend) {
    if (addend === 0) {
      return generate;
    } else {
      return function (engine) {
        return generate(engine) + addend;
      };
    }
  }

  Random.integer = (function () {
    function isPowerOfTwoMinusOne(value) {
      return ((value + 1) & value) === 0;
    }

    function bitmask(masking) {
      return function (engine) {
        return engine() & masking;
      };
    }

    function downscaleToLoopCheckedRange(range) {
      var extendedRange = range + 1;
      var maximum = extendedRange * Math.floor(0x100000000 / extendedRange);
      return function (engine) {
        var value = 0;
        do {
          value = engine() >>> 0;
        } while (value >= maximum);
        return value % extendedRange;
      };
    }

    function downscaleToRange(range) {
      if (isPowerOfTwoMinusOne(range)) {
        return bitmask(range);
      } else {
        return downscaleToLoopCheckedRange(range);
      }
    }

    function isEvenlyDivisibleByMaxInt32(value) {
      return (value | 0) === 0;
    }

    function upscaleWithHighMasking(masking) {
      return function (engine) {
        var high = engine() & masking;
        var low = engine() >>> 0;
        return (high * 0x100000000) + low;
      };
    }

    function upscaleToLoopCheckedRange(extendedRange) {
      var maximum = extendedRange * Math.floor(0x20000000000000 / extendedRange);
      return function (engine) {
        var ret = 0;
        do {
          var high = engine() & 0x1fffff;
          var low = engine() >>> 0;
          ret = (high * 0x100000000) + low;
        } while (ret >= maximum);
        return ret % extendedRange;
      };
    }

    function upscaleWithinU53(range) {
      var extendedRange = range + 1;
      if (isEvenlyDivisibleByMaxInt32(extendedRange)) {
        var highRange = ((extendedRange / 0x100000000) | 0) - 1;
        if (isPowerOfTwoMinusOne(highRange)) {
          return upscaleWithHighMasking(highRange);
        }
      }
      return upscaleToLoopCheckedRange(extendedRange);
    }

    function upscaleWithinI53AndLoopCheck(min, max) {
      return function (engine) {
        var ret = 0;
        do {
          var high = engine() | 0;
          var low = engine() >>> 0;
          ret = ((high & 0x1fffff) * 0x100000000) + low + (high & 0x200000 ? -0x20000000000000 : 0);
        } while (ret < min || ret > max);
        return ret;
      };
    }

    return function (min, max) {
      min = Math.floor(min);
      max = Math.floor(max);
      if (min < -0x20000000000000 || !isFinite(min)) {
        throw new RangeError("Expected min to be at least " + (-0x20000000000000));
      } else if (max > 0x20000000000000 || !isFinite(max)) {
        throw new RangeError("Expected max to be at most " + 0x20000000000000);
      }

      var range = max - min;
      if (range <= 0 || !isFinite(range)) {
        return returnValue(min);
      } else if (range === 0xffffffff) {
        if (min === 0) {
          return Random.uint32;
        } else {
          return add(Random.int32, min + 0x80000000);
        }
      } else if (range < 0xffffffff) {
        return add(downscaleToRange(range), min);
      } else if (range === 0x1fffffffffffff) {
        return add(Random.uint53, min);
      } else if (range < 0x1fffffffffffff) {
        return add(upscaleWithinU53(range), min);
      } else if (max - 1 - min === 0x1fffffffffffff) {
        return add(Random.uint53Full, min);
      } else if (min === -0x20000000000000 && max === 0x20000000000000) {
        return Random.int53Full;
      } else if (min === -0x20000000000000 && max === 0x1fffffffffffff) {
        return Random.int53;
      } else if (min === -0x1fffffffffffff && max === 0x20000000000000) {
        return add(Random.int53, 1);
      } else if (max === 0x20000000000000) {
        return add(upscaleWithinI53AndLoopCheck(min - 1, max - 1), 1);
      } else {
        return upscaleWithinI53AndLoopCheck(min, max);
      }
    };
  }());
  proto.integer = function (min, max) {
    return Random.integer(min, max)(this.engine);
  };

  // [0, 1] (floating point)
  Random.realZeroToOneInclusive = function (engine) {
    return Random.uint53Full(engine) / 0x20000000000000;
  };
  proto.realZeroToOneInclusive = function () {
    return Random.realZeroToOneInclusive(this.engine);
  };

  // [0, 1) (floating point)
  Random.realZeroToOneExclusive = function (engine) {
    return Random.uint53(engine) / 0x20000000000000;
  };
  proto.realZeroToOneExclusive = function () {
    return Random.realZeroToOneExclusive(this.engine);
  };

  Random.real = (function () {
    function multiply(generate, multiplier) {
      if (multiplier === 1) {
        return generate;
      } else if (multiplier === 0) {
        return function () {
          return 0;
        };
      } else {
        return function (engine) {
          return generate(engine) * multiplier;
        };
      }
    }

    return function (left, right, inclusive) {
      if (!isFinite(left)) {
        throw new RangeError("Expected left to be a finite number");
      } else if (!isFinite(right)) {
        throw new RangeError("Expected right to be a finite number");
      }
      return add(
        multiply(
          inclusive ? Random.realZeroToOneInclusive : Random.realZeroToOneExclusive,
          right - left),
        left);
    };
  }());
  proto.real = function (min, max, inclusive) {
    return Random.real(min, max, inclusive)(this.engine);
  };

  Random.bool = (function () {
    function isLeastBitTrue(engine) {
      return (engine() & 1) === 1;
    }

    function lessThan(generate, value) {
      return function (engine) {
        return generate(engine) < value;
      };
    }

    function probability(percentage) {
      if (percentage <= 0) {
        return returnValue(false);
      } else if (percentage >= 1) {
        return returnValue(true);
      } else {
        var scaled = percentage * 0x100000000;
        if (scaled % 1 === 0) {
          return lessThan(Random.int32, (scaled - 0x80000000) | 0);
        } else {
          return lessThan(Random.uint53, Math.round(percentage * 0x20000000000000));
        }
      }
    }

    return function (numerator, denominator) {
      if (denominator == null) {
        if (numerator == null) {
          return isLeastBitTrue;
        }
        return probability(numerator);
      } else {
        if (numerator <= 0) {
          return returnValue(false);
        } else if (numerator >= denominator) {
          return returnValue(true);
        }
        return lessThan(Random.integer(0, denominator - 1), numerator);
      }
    };
  }());
  proto.bool = function (numerator, denominator) {
    return Random.bool(numerator, denominator)(this.engine);
  };

  function toInteger(value) {
    var number = +value;
    if (number < 0) {
      return Math.ceil(number);
    } else {
      return Math.floor(number);
    }
  }

  function convertSliceArgument(value, length) {
    if (value < 0) {
      return Math.max(value + length, 0);
    } else {
      return Math.min(value, length);
    }
  }
  Random.pick = function (engine, array, begin, end) {
    var length = array.length;
    var start = begin == null ? 0 : convertSliceArgument(toInteger(begin), length);
    var finish = end === void 0 ? length : convertSliceArgument(toInteger(end), length);
    if (start >= finish) {
      return void 0;
    }
    var distribution = Random.integer(start, finish - 1);
    return array[distribution(engine)];
  };
  proto.pick = function (array, begin, end) {
    return Random.pick(this.engine, array, begin, end);
  };

  function returnUndefined() {
    return void 0;
  }
  var slice = Array.prototype.slice;
  Random.picker = function (array, begin, end) {
    var clone = slice.call(array, begin, end);
    if (!clone.length) {
      return returnUndefined;
    }
    var distribution = Random.integer(0, clone.length - 1);
    return function (engine) {
      return clone[distribution(engine)];
    };
  };

  Random.shuffle = function (engine, array, downTo) {
    var length = array.length;
    if (length) {
      if (downTo == null) {
        downTo = 0;
      }
      for (var i = (length - 1) >>> 0; i > downTo; --i) {
        var distribution = Random.integer(0, i);
        var j = distribution(engine);
        if (i !== j) {
          var tmp = array[i];
          array[i] = array[j];
          array[j] = tmp;
        }
      }
    }
    return array;
  };
  proto.shuffle = function (array) {
    return Random.shuffle(this.engine, array);
  };

  Random.sample = function (engine, population, sampleSize) {
    if (sampleSize < 0 || sampleSize > population.length || !isFinite(sampleSize)) {
      throw new RangeError("Expected sampleSize to be within 0 and the length of the population");
    }

    if (sampleSize === 0) {
      return [];
    }

    var clone = slice.call(population);
    var length = clone.length;
    if (length === sampleSize) {
      return Random.shuffle(engine, clone, 0);
    }
    var tailLength = length - sampleSize;
    return Random.shuffle(engine, clone, tailLength - 1).slice(tailLength);
  };
  proto.sample = function (population, sampleSize) {
    return Random.sample(this.engine, population, sampleSize);
  };

  Random.die = function (sideCount) {
    return Random.integer(1, sideCount);
  };
  proto.die = function (sideCount) {
    return Random.die(sideCount)(this.engine);
  };

  Random.dice = function (sideCount, dieCount) {
    var distribution = Random.die(sideCount);
    return function (engine) {
      var result = [];
      result.length = dieCount;
      for (var i = 0; i < dieCount; ++i) {
        result[i] = distribution(engine);
      }
      return result;
    };
  };
  proto.dice = function (sideCount, dieCount) {
    return Random.dice(sideCount, dieCount)(this.engine);
  };

  // http://en.wikipedia.org/wiki/Universally_unique_identifier
  Random.uuid4 = (function () {
    function zeroPad(string, zeroCount) {
      return stringRepeat("0", zeroCount - string.length) + string;
    }

    return function (engine) {
      var a = engine() >>> 0;
      var b = engine() | 0;
      var c = engine() | 0;
      var d = engine() >>> 0;

      return (
        zeroPad(a.toString(16), 8) +
        "-" +
        zeroPad((b & 0xffff).toString(16), 4) +
        "-" +
        zeroPad((((b >> 4) & 0x0fff) | 0x4000).toString(16), 4) +
        "-" +
        zeroPad(((c & 0x3fff) | 0x8000).toString(16), 4) +
        "-" +
        zeroPad(((c >> 4) & 0xffff).toString(16), 4) +
        zeroPad(d.toString(16), 8));
    };
  }());
  proto.uuid4 = function () {
    return Random.uuid4(this.engine);
  };

  Random.string = (function () {
    // has 2**x chars, for faster uniform distribution
    var DEFAULT_STRING_POOL = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";

    return function (pool) {
      if (pool == null) {
        pool = DEFAULT_STRING_POOL;
      }

      var length = pool.length;
      if (!length) {
        throw new Error("Expected pool not to be an empty string");
      }

      var distribution = Random.integer(0, length - 1);
      return function (engine, length) {
        var result = "";
        for (var i = 0; i < length; ++i) {
          var j = distribution(engine);
          result += pool.charAt(j);
        }
        return result;
      };
    };
  }());
  proto.string = function (length, pool) {
    return Random.string(pool)(this.engine, length);
  };

  Random.hex = (function () {
    var LOWER_HEX_POOL = "0123456789abcdef";
    var lowerHex = Random.string(LOWER_HEX_POOL);
    var upperHex = Random.string(LOWER_HEX_POOL.toUpperCase());

    return function (upper) {
      if (upper) {
        return upperHex;
      } else {
        return lowerHex;
      }
    };
  }());
  proto.hex = function (length, upper) {
    return Random.hex(upper)(this.engine, length);
  };

  Random.date = function (start, end) {
    if (!(start instanceof Date)) {
      throw new TypeError("Expected start to be a Date, got " + typeof start);
    } else if (!(end instanceof Date)) {
      throw new TypeError("Expected end to be a Date, got " + typeof end);
    }
    var distribution = Random.integer(start.getTime(), end.getTime());
    return function (engine) {
      return new Date(distribution(engine));
    };
  };
  proto.date = function (start, end) {
    return Random.date(start, end)(this.engine);
  };

  if (typeof define === "function" && define.amd) {
    define(function () {
      return Random;
    });
  } else if (typeof module !== "undefined" && typeof require === "function") {
    module.exports = Random;
  } else {
    (function () {
      var oldGlobal = root[GLOBAL_KEY];
      Random.noConflict = function () {
        root[GLOBAL_KEY] = oldGlobal;
        return this;
      };
    }());
    root[GLOBAL_KEY] = Random;
  }
}(this));
},{}],89:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":90}],90:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":92,"./_stream_writable":94,"core-util-is":9,"inherits":36,"process-nextick-args":85}],91:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":93,"core-util-is":9,"inherits":36}],92:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var hasPrependListener = typeof EE.prototype.prependListener === 'function';

function prependListener(emitter, event, fn) {
  if (hasPrependListener) return emitter.prependListener(event, fn);

  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS. This is here
  // only because this code needs to continue to work with older versions
  // of Node.js that do not include the prependListener() method. The goal
  // is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var _buf = list[0];
        var cpy = Math.min(n - c, _buf.length);

        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);

        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))
},{"./_stream_duplex":90,"_process":86,"buffer":5,"buffer-shims":4,"core-util-is":9,"events":29,"inherits":36,"isarray":40,"process-nextick-args":85,"string_decoder/":107,"util":165}],93:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":90,"core-util-is":9,"inherits":36}],94:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))
},{"./_stream_duplex":90,"_process":86,"buffer":5,"buffer-shims":4,"core-util-is":9,"events":29,"inherits":36,"process-nextick-args":85,"util-deprecate":163}],95:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":91}],96:[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))
},{"./lib/_stream_duplex.js":90,"./lib/_stream_passthrough.js":91,"./lib/_stream_readable.js":92,"./lib/_stream_transform.js":93,"./lib/_stream_writable.js":94,"_process":86}],97:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":93}],98:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":94}],99:[function(require,module,exports){
// # Relative luminance
//
// http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
// https://en.wikipedia.org/wiki/Luminance_(relative)
// https://en.wikipedia.org/wiki/Luminosity_function
// https://en.wikipedia.org/wiki/Rec._709#Luma_coefficients

// red, green, and blue coefficients
var rc = 0.2126,
    gc = 0.7152,
    bc = 0.0722,
    // low-gamma adjust coefficient
    lowc = 1 / 12.92;

function adjustGamma(_) {
    return Math.pow((_ + 0.055) / 1.055, 2.4);
}

module.exports = function(rgb) {
    var rsrgb = rgb[0] / 255,
        gsrgb = rgb[1] / 255,
        bsrgb = rgb[2] / 255;

    var r = (rsrgb <= 0.03928) ? (rsrgb * lowc) : adjustGamma(rsrgb),
        g = (gsrgb <= 0.03928) ? (gsrgb * lowc) : adjustGamma(gsrgb),
        b = (bsrgb <= 0.03928) ? (bsrgb * lowc) : adjustGamma(bsrgb);

    return r * rc + g * gc + b * bc;
};

},{}],100:[function(require,module,exports){
(function (process){
var through = require('through');
var nextTick = typeof setImmediate !== 'undefined'
    ? setImmediate
    : process.nextTick
;

module.exports = function (write, end) {
    var tr = through(write, end);
    tr.pause();
    var resume = tr.resume;
    var pause = tr.pause;
    var paused = false;
    
    tr.pause = function () {
        paused = true;
        return pause.apply(this, arguments);
    };
    
    tr.resume = function () {
        paused = false;
        return resume.apply(this, arguments);
    };
    
    nextTick(function () {
        if (!paused) tr.resume();
    });
    
    return tr;
};

}).call(this,require('_process'))
},{"_process":86,"through":160}],101:[function(require,module,exports){
'use strict';

var isArrayish = require('is-arrayish');

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

},{"is-arrayish":37}],102:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":29,"inherits":36,"readable-stream/duplex.js":89,"readable-stream/passthrough.js":95,"readable-stream/readable.js":96,"readable-stream/transform.js":97,"readable-stream/writable.js":98}],103:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var ES = require('es-abstract/es5');
var replace = bind.call(Function.call, String.prototype.replace);

var leftWhitespace = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
var rightWhitespace = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;

module.exports = function trim() {
	var S = ES.ToString(ES.CheckObjectCoercible(this));
	return replace(replace(S, leftWhitespace, ''), rightWhitespace, '');
};

},{"es-abstract/es5":22,"function-bind":32}],104:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var boundTrim = bind.call(Function.call, getPolyfill());

define(boundTrim, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundTrim;

},{"./implementation":103,"./polyfill":105,"./shim":106,"define-properties":20,"function-bind":32}],105:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

var zeroWidthSpace = '\u200b';

module.exports = function getPolyfill() {
	if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace) {
		return String.prototype.trim;
	}
	return implementation;
};

},{"./implementation":103}],106:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimStringTrim() {
	var polyfill = getPolyfill();
	define(String.prototype, { trim: polyfill }, { trim: function () { return String.prototype.trim !== polyfill; } });
	return polyfill;
};

},{"./polyfill":105,"define-properties":20}],107:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":5}],108:[function(require,module,exports){
(function (process){
var defined = require('defined');
var createDefaultStream = require('./lib/default_stream');
var Test = require('./lib/test');
var createResult = require('./lib/results');
var through = require('through');

var canEmitExit = typeof process !== 'undefined' && process
    && typeof process.on === 'function' && process.browser !== true
;
var canExit = typeof process !== 'undefined' && process
    && typeof process.exit === 'function'
;

var nextTick = typeof setImmediate !== 'undefined'
    ? setImmediate
    : process.nextTick
;

exports = module.exports = (function () {
    var harness;
    var lazyLoad = function () {
        return getHarness().apply(this, arguments);
    };
    
    lazyLoad.only = function () {
        return getHarness().only.apply(this, arguments);
    };
    
    lazyLoad.createStream = function (opts) {
        if (!opts) opts = {};
        if (!harness) {
            var output = through();
            getHarness({ stream: output, objectMode: opts.objectMode });
            return output;
        }
        return harness.createStream(opts);
    };
    
    lazyLoad.onFinish = function () {
        return getHarness().onFinish.apply(this, arguments);
    };

    lazyLoad.getHarness = getHarness

    return lazyLoad

    function getHarness (opts) {
        if (!opts) opts = {};
        opts.autoclose = !canEmitExit;
        if (!harness) harness = createExitHarness(opts);
        return harness;
    }
})();

function createExitHarness (conf) {
    if (!conf) conf = {};
    var harness = createHarness({
        autoclose: defined(conf.autoclose, false)
    });
    
    var stream = harness.createStream({ objectMode: conf.objectMode });
    var es = stream.pipe(conf.stream || createDefaultStream());
    if (canEmitExit) {
        es.on('error', function (err) { harness._exitCode = 1 });
    }
    
    var ended = false;
    stream.on('end', function () { ended = true });
    
    if (conf.exit === false) return harness;
    if (!canEmitExit || !canExit) return harness;

    var inErrorState = false;

    process.on('exit', function (code) {
        // let the process exit cleanly.
        if (code !== 0) {
            return
        }

        if (!ended) {
            var only = harness._results._only;
            for (var i = 0; i < harness._tests.length; i++) {
                var t = harness._tests[i];
                if (only && t.name !== only) continue;
                t._exit();
            }
        }
        harness.close();
        process.exit(code || harness._exitCode);
    });
    
    return harness;
}

exports.createHarness = createHarness;
exports.Test = Test;
exports.test = exports; // tap compat
exports.test.skip = Test.skip;

var exitInterval;

function createHarness (conf_) {
    if (!conf_) conf_ = {};
    var results = createResult();
    if (conf_.autoclose !== false) {
        results.once('done', function () { results.close() });
    }
    
    var test = function (name, conf, cb) {
        var t = new Test(name, conf, cb);
        test._tests.push(t);
        
        (function inspectCode (st) {
            st.on('test', function sub (st_) {
                inspectCode(st_);
            });
            st.on('result', function (r) {
                if (!r.ok && typeof r !== 'string') test._exitCode = 1
            });
        })(t);
        
        results.push(t);
        return t;
    };
    test._results = results;
    
    test._tests = [];
    
    test.createStream = function (opts) {
        return results.createStream(opts);
    };

    test.onFinish = function (cb) {
        results.on('done', cb);
    };
    
    var only = false;
    test.only = function (name) {
        if (only) throw new Error('there can only be one only test');
        results.only(name);
        only = true;
        return test.apply(null, arguments);
    };
    test._exitCode = 0;
    
    test.close = function () { results.close() };
    
    return test;
}

}).call(this,require('_process'))
},{"./lib/default_stream":109,"./lib/results":110,"./lib/test":111,"_process":86,"defined":21,"through":160}],109:[function(require,module,exports){
(function (process){
var through = require('through');
var fs = require('fs');

module.exports = function () {
    var line = '';
    var stream = through(write, flush);
    return stream;
    
    function write (buf) {
        for (var i = 0; i < buf.length; i++) {
            var c = typeof buf === 'string'
                ? buf.charAt(i)
                : String.fromCharCode(buf[i])
            ;
            if (c === '\n') flush();
            else line += c;
        }
    }
    
    function flush () {
        if (fs.writeSync && /^win/.test(process.platform)) {
            try { fs.writeSync(1, line + '\n'); }
            catch (e) { stream.emit('error', e) }
        }
        else {
            try { console.log(line) }
            catch (e) { stream.emit('error', e) }
        }
        line = '';
    }
};

}).call(this,require('_process'))
},{"_process":86,"fs":3,"through":160}],110:[function(require,module,exports){
(function (process){
var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var through = require('through');
var resumer = require('resumer');
var inspect = require('object-inspect');
var bind = require('function-bind');
var has = require('has');
var regexpTest = bind.call(Function.call, RegExp.prototype.test);
var yamlIndicators = /\:|\-|\?/;
var nextTick = typeof setImmediate !== 'undefined'
    ? setImmediate
    : process.nextTick
;

module.exports = Results;
inherits(Results, EventEmitter);

function Results () {
    if (!(this instanceof Results)) return new Results;
    this.count = 0;
    this.fail = 0;
    this.pass = 0;
    this._stream = through();
    this.tests = [];
}

Results.prototype.createStream = function (opts) {
    if (!opts) opts = {};
    var self = this;
    var output, testId = 0;
    if (opts.objectMode) {
        output = through();
        self.on('_push', function ontest (t, extra) {
            if (!extra) extra = {};
            var id = testId++;
            t.once('prerun', function () {
                var row = {
                    type: 'test',
                    name: t.name,
                    id: id
                };
                if (has(extra, 'parent')) {
                    row.parent = extra.parent;
                }
                output.queue(row);
            });
            t.on('test', function (st) {
                ontest(st, { parent: id });
            });
            t.on('result', function (res) {
                res.test = id;
                res.type = 'assert';
                output.queue(res);
            });
            t.on('end', function () {
                output.queue({ type: 'end', test: id });
            });
        });
        self.on('done', function () { output.queue(null) });
    }
    else {
        output = resumer();
        output.queue('TAP version 13\n');
        self._stream.pipe(output);
    }
    
    nextTick(function next() {
        var t;
        while (t = getNextTest(self)) {
            t.run();
            if (!t.ended) return t.once('end', function(){ nextTick(next); });
        }
        self.emit('done');
    });
    
    return output;
};

Results.prototype.push = function (t) {
    var self = this;
    self.tests.push(t);
    self._watch(t);
    self.emit('_push', t);
};

Results.prototype.only = function (name) {
    this._only = name;
};

Results.prototype._watch = function (t) {
    var self = this;
    var write = function (s) { self._stream.queue(s) };
    t.once('prerun', function () {
        write('# ' + t.name + '\n');
    });
    
    t.on('result', function (res) {
        if (typeof res === 'string') {
            write('# ' + res + '\n');
            return;
        }
        write(encodeResult(res, self.count + 1));
        self.count ++;

        if (res.ok) self.pass ++
        else self.fail ++
    });
    
    t.on('test', function (st) { self._watch(st) });
};

Results.prototype.close = function () {
    var self = this;
    if (self.closed) self._stream.emit('error', new Error('ALREADY CLOSED'));
    self.closed = true;
    var write = function (s) { self._stream.queue(s) };
    
    write('\n1..' + self.count + '\n');
    write('# tests ' + self.count + '\n');
    write('# pass  ' + self.pass + '\n');
    if (self.fail) write('# fail  ' + self.fail + '\n')
    else write('\n# ok\n')

    self._stream.queue(null);
};

function encodeResult (res, count) {
    var output = '';
    output += (res.ok ? 'ok ' : 'not ok ') + count;
    output += res.name ? ' ' + res.name.toString().replace(/\s+/g, ' ') : '';
    
    if (res.skip) output += ' # SKIP';
    else if (res.todo) output += ' # TODO';
    
    output += '\n';
    if (res.ok) return output;
    
    var outer = '  ';
    var inner = outer + '  ';
    output += outer + '---\n';
    output += inner + 'operator: ' + res.operator + '\n';
    
    if (has(res, 'expected') || has(res, 'actual')) {
        var ex = inspect(res.expected, {depth: res.objectPrintDepth});
        var ac = inspect(res.actual, {depth: res.objectPrintDepth});
        
        if (Math.max(ex.length, ac.length) > 65 || invalidYaml(ex) || invalidYaml(ac)) {
            output += inner + 'expected: |-\n' + inner + '  ' + ex + '\n';
            output += inner + 'actual: |-\n' + inner + '  ' + ac + '\n';
        }
        else {
            output += inner + 'expected: ' + ex + '\n';
            output += inner + 'actual:   ' + ac + '\n';
        }
    }
    if (res.at) {
        output += inner + 'at: ' + res.at + '\n';
    }
    if (res.operator === 'error' && res.actual && res.actual.stack) {
        var lines = String(res.actual.stack).split('\n');
        output += inner + 'stack: |-\n';
        for (var i = 0; i < lines.length; i++) {
            output += inner + '  ' + lines[i] + '\n';
        }
    }
    
    output += outer + '...\n';
    return output;
}

function getNextTest (results) {
    if (!results._only) {
        return results.tests.shift();
    }
    
    do {
        var t = results.tests.shift();
        if (!t) continue;
        if (results._only === t.name) {
            return t;
        }
    } while (results.tests.length !== 0)
}

function invalidYaml (str) {
    return regexpTest(yamlIndicators, str);
}

}).call(this,require('_process'))
},{"_process":86,"events":29,"function-bind":32,"has":33,"inherits":36,"object-inspect":79,"resumer":100,"through":160}],111:[function(require,module,exports){
(function (process,__dirname){
var deepEqual = require('deep-equal');
var defined = require('defined');
var path = require('path');
var inherits = require('inherits');
var EventEmitter = require('events').EventEmitter;
var has = require('has');
var trim = require('string.prototype.trim');

module.exports = Test;

var nextTick = typeof setImmediate !== 'undefined'
    ? setImmediate
    : process.nextTick
;
var safeSetTimeout = setTimeout;

inherits(Test, EventEmitter);

var getTestArgs = function (name_, opts_, cb_) {
    var name = '(anonymous)';
    var opts = {};
    var cb;

    for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var t = typeof arg;
        if (t === 'string') {
            name = arg;
        }
        else if (t === 'object') {
            opts = arg || opts;
        }
        else if (t === 'function') {
            cb = arg;
        }
    }
    return { name: name, opts: opts, cb: cb };
};

function Test (name_, opts_, cb_) {
    if (! (this instanceof Test)) {
        return new Test(name_, opts_, cb_);
    }

    var args = getTestArgs(name_, opts_, cb_);

    this.readable = true;
    this.name = args.name || '(anonymous)';
    this.assertCount = 0;
    this.pendingCount = 0;
    this._skip = args.opts.skip || false;
    this._timeout = args.opts.timeout;
    this._objectPrintDepth = args.opts.objectPrintDepth || 5;
    this._plan = undefined;
    this._cb = args.cb;
    this._progeny = [];
    this._ok = true;

    for (var prop in this) {
        this[prop] = (function bind(self, val) {
            if (typeof val === 'function') {
                return function bound() {
                    return val.apply(self, arguments);
                };
            }
            else return val;
        })(this, this[prop]);
    }
}

Test.prototype.run = function () {
    if (this._skip) {
        this.comment('SKIP ' + this.name);
    }
    if (!this._cb || this._skip) {
        return this._end();
    }
    if (this._timeout != null) {
        this.timeoutAfter(this._timeout);
    }
    this.emit('prerun');
    this._cb(this);
    this.emit('run');
};

Test.prototype.test = function (name, opts, cb) {
    var self = this;
    var t = new Test(name, opts, cb);
    this._progeny.push(t);
    this.pendingCount++;
    this.emit('test', t);
    t.on('prerun', function () {
        self.assertCount++;
    })
    
    if (!self._pendingAsserts()) {
        nextTick(function () {
            self._end();
        });
    }
    
    nextTick(function() {
        if (!self._plan && self.pendingCount == self._progeny.length) {
            self._end();
        }
    });
};

Test.prototype.comment = function (msg) {
    var that = this;
    trim(msg).split('\n').forEach(function (aMsg) {
        that.emit('result', trim(aMsg).replace(/^#\s*/, ''));
    });
};

Test.prototype.plan = function (n) {
    this._plan = n;
    this.emit('plan', n);
};

Test.prototype.timeoutAfter = function(ms) {
    if (!ms) throw new Error('timeoutAfter requires a timespan');
    var self = this;
    var timeout = safeSetTimeout(function() {
        self.fail('test timed out after ' + ms + 'ms');
        self.end();
    }, ms);
    this.once('end', function() {
        clearTimeout(timeout);
    });
}

Test.prototype.end = function (err) { 
    var self = this;
    if (arguments.length >= 1 && !!err) {
        this.ifError(err);
    }
    
    if (this.calledEnd) {
        this.fail('.end() called twice');
    }
    this.calledEnd = true;
    this._end();
};

Test.prototype._end = function (err) {
    var self = this;
    if (this._progeny.length) {
        var t = this._progeny.shift();
        t.on('end', function () { self._end() });
        t.run();
        return;
    }
    
    if (!this.ended) this.emit('end');
    var pendingAsserts = this._pendingAsserts();
    if (!this._planError && this._plan !== undefined && pendingAsserts) {
        this._planError = true;
        this.fail('plan != count', {
            expected : this._plan,
            actual : this.assertCount
        });
    }
    this.ended = true;
};

Test.prototype._exit = function () {
    if (this._plan !== undefined &&
        !this._planError && this.assertCount !== this._plan) {
        this._planError = true;
        this.fail('plan != count', {
            expected : this._plan,
            actual : this.assertCount,
            exiting : true
        });
    }
    else if (!this.ended) {
        this.fail('test exited without ending', {
            exiting: true
        });
    }
};

Test.prototype._pendingAsserts = function () {
    if (this._plan === undefined) {
        return 1;
    }
    else {
        return this._plan - (this._progeny.length + this.assertCount);
    }
};

Test.prototype._assert = function assert (ok, opts) {
    var self = this;
    var extra = opts.extra || {};
    
    var res = {
        id : self.assertCount ++,
        ok : Boolean(ok),
        skip : defined(extra.skip, opts.skip),
        name : defined(extra.message, opts.message, '(unnamed assert)'),
        operator : defined(extra.operator, opts.operator),
        objectPrintDepth : self._objectPrintDepth
    };
    if (has(opts, 'actual') || has(extra, 'actual')) {
        res.actual = defined(extra.actual, opts.actual);
    }
    if (has(opts, 'expected') || has(extra, 'expected')) {
        res.expected = defined(extra.expected, opts.expected);
    }
    this._ok = Boolean(this._ok && ok);
    
    if (!ok) {
        res.error = defined(extra.error, opts.error, new Error(res.name));
    }
    
    if (!ok) {
        var e = new Error('exception');
        var err = (e.stack || '').split('\n');
        var dir = path.dirname(__dirname) + '/';
        
        for (var i = 0; i < err.length; i++) {
            var m = /^[^\s]*\s*\bat\s+(.+)/.exec(err[i]);
            if (!m) {
                continue;
            }
            
            var s = m[1].split(/\s+/);
            var filem = /(\/[^:\s]+:(\d+)(?::(\d+))?)/.exec(s[1]);
            if (!filem) {
                filem = /(\/[^:\s]+:(\d+)(?::(\d+))?)/.exec(s[2]);
                
                if (!filem) {
                    filem = /(\/[^:\s]+:(\d+)(?::(\d+))?)/.exec(s[3]);

                    if (!filem) {
                        continue;
                    }
                }
            }
            
            if (filem[1].slice(0, dir.length) === dir) {
                continue;
            }
            
            res.functionName = s[0];
            res.file = filem[1];
            res.line = Number(filem[2]);
            if (filem[3]) res.column = filem[3];
            
            res.at = m[1];
            break;
        }
    }

    self.emit('result', res);
    
    var pendingAsserts = self._pendingAsserts();
    if (!pendingAsserts) {
        if (extra.exiting) {
            self._end();
        } else {
            nextTick(function () {
                self._end();
            });
        }
    }
    
    if (!self._planError && pendingAsserts < 0) {
        self._planError = true;
        self.fail('plan != count', {
            expected : self._plan,
            actual : self._plan - pendingAsserts
        });
    }
};

Test.prototype.fail = function (msg, extra) {
    this._assert(false, {
        message : msg,
        operator : 'fail',
        extra : extra
    });
};

Test.prototype.pass = function (msg, extra) {
    this._assert(true, {
        message : msg,
        operator : 'pass',
        extra : extra
    });
};

Test.prototype.skip = function (msg, extra) {
    this._assert(true, {
        message : msg,
        operator : 'skip',
        skip : true,
        extra : extra
    });
};

Test.prototype.ok
= Test.prototype['true']
= Test.prototype.assert
= function (value, msg, extra) {
    this._assert(value, {
        message : defined(msg, 'should be truthy'),
        operator : 'ok',
        expected : true,
        actual : value,
        extra : extra
    });
};

Test.prototype.notOk
= Test.prototype['false']
= Test.prototype.notok
= function (value, msg, extra) {
    this._assert(!value, {
        message : defined(msg, 'should be falsy'),
        operator : 'notOk',
        expected : false,
        actual : value,
        extra : extra
    });
};

Test.prototype.error
= Test.prototype.ifError
= Test.prototype.ifErr
= Test.prototype.iferror
= function (err, msg, extra) {
    this._assert(!err, {
        message : defined(msg, String(err)),
        operator : 'error',
        actual : err,
        extra : extra
    });
};

Test.prototype.equal
= Test.prototype.equals
= Test.prototype.isEqual
= Test.prototype.is
= Test.prototype.strictEqual
= Test.prototype.strictEquals
= function (a, b, msg, extra) {
    this._assert(a === b, {
        message : defined(msg, 'should be equal'),
        operator : 'equal',
        actual : a,
        expected : b,
        extra : extra
    });
};

Test.prototype.notEqual
= Test.prototype.notEquals
= Test.prototype.notStrictEqual
= Test.prototype.notStrictEquals
= Test.prototype.isNotEqual
= Test.prototype.isNot
= Test.prototype.not
= Test.prototype.doesNotEqual
= Test.prototype.isInequal
= function (a, b, msg, extra) {
    this._assert(a !== b, {
        message : defined(msg, 'should not be equal'),
        operator : 'notEqual',
        actual : a,
        notExpected : b,
        extra : extra
    });
};

Test.prototype.deepEqual
= Test.prototype.deepEquals
= Test.prototype.isEquivalent
= Test.prototype.same
= function (a, b, msg, extra) {
    this._assert(deepEqual(a, b, { strict: true }), {
        message : defined(msg, 'should be equivalent'),
        operator : 'deepEqual',
        actual : a,
        expected : b,
        extra : extra
    });
};

Test.prototype.deepLooseEqual
= Test.prototype.looseEqual
= Test.prototype.looseEquals
= function (a, b, msg, extra) {
    this._assert(deepEqual(a, b), {
        message : defined(msg, 'should be equivalent'),
        operator : 'deepLooseEqual',
        actual : a,
        expected : b,
        extra : extra
    });
};

Test.prototype.notDeepEqual
= Test.prototype.notEquivalent
= Test.prototype.notDeeply
= Test.prototype.notSame
= Test.prototype.isNotDeepEqual
= Test.prototype.isNotDeeply
= Test.prototype.isNotEquivalent
= Test.prototype.isInequivalent
= function (a, b, msg, extra) {
    this._assert(!deepEqual(a, b, { strict: true }), {
        message : defined(msg, 'should not be equivalent'),
        operator : 'notDeepEqual',
        actual : a,
        notExpected : b,
        extra : extra
    });
};

Test.prototype.notDeepLooseEqual
= Test.prototype.notLooseEqual
= Test.prototype.notLooseEquals
= function (a, b, msg, extra) {
    this._assert(!deepEqual(a, b), {
        message : defined(msg, 'should be equivalent'),
        operator : 'notDeepLooseEqual',
        actual : a,
        expected : b,
        extra : extra
    });
};

Test.prototype['throws'] = function (fn, expected, msg, extra) {
    if (typeof expected === 'string') {
        msg = expected;
        expected = undefined;
    }

    var caught = undefined;

    try {
        fn();
    } catch (err) {
        caught = { error : err };
        var message = err.message;
        delete err.message;
        err.message = message;
    }

    var passed = caught;

    if (expected instanceof RegExp) {
        passed = expected.test(caught && caught.error);
        expected = String(expected);
    }

    if (typeof expected === 'function' && caught) {
        passed = caught.error instanceof expected;
        caught.error = caught.error.constructor;
    }

    this._assert(typeof fn === 'function' && passed, {
        message : defined(msg, 'should throw'),
        operator : 'throws',
        actual : caught && caught.error,
        expected : expected,
        error: !passed && caught && caught.error,
        extra : extra
    });
};

Test.prototype.doesNotThrow = function (fn, expected, msg, extra) {
    if (typeof expected === 'string') {
        msg = expected;
        expected = undefined;
    }
    var caught = undefined;
    try {
        fn();
    }
    catch (err) {
        caught = { error : err };
    }
    this._assert(!caught, {
        message : defined(msg, 'should not throw'),
        operator : 'throws',
        actual : caught && caught.error,
        expected : expected,
        error : caught && caught.error,
        extra : extra
    });
};

Test.skip = function (name_, _opts, _cb) {
    var args = getTestArgs.apply(null, arguments);
    args.opts.skip = true;
    return Test(args.name, args.opts, args.cb);
};

// vim: set softtabstop=4 shiftwidth=4:


}).call(this,require('_process'),"/zfs-store\\work\\Programming Workspace\\Educational interactive widgets\\alpha dev - lessons\\7 - UI mocks and adding text input\\node_modules\\tape\\lib")
},{"_process":86,"deep-equal":17,"defined":21,"events":29,"has":33,"inherits":36,"path":84,"string.prototype.trim":104}],112:[function(require,module,exports){
/*! @preserve
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014-2016 Giulio Canti
 *
 */

// core
var t = require('./lib/assert');

// types
t.Any = require('./lib/Any');
t.Array = require('./lib/Array');
t.Boolean = require('./lib/Boolean');
t.Date = require('./lib/Date');
t.Error = require('./lib/Error');
t.Function = require('./lib/Function');
t.Nil = require('./lib/Nil');
t.Number = require('./lib/Number');
t.Object = require('./lib/Object');
t.RegExp = require('./lib/RegExp');
t.String = require('./lib/String');

// short alias are deprecated
t.Arr = t.Array;
t.Bool = t.Boolean;
t.Dat = t.Date;
t.Err = t.Error;
t.Func = t.Function;
t.Num = t.Number;
t.Obj = t.Object;
t.Re = t.RegExp;
t.Str = t.String;

// combinators
t.dict = require('./lib/dict');
t.declare = require('./lib/declare');
t.enums = require('./lib/enums');
t.irreducible = require('./lib/irreducible');
t.list = require('./lib/list');
t.maybe = require('./lib/maybe');
t.refinement = require('./lib/refinement');
t.struct = require('./lib/struct');
t.tuple = require('./lib/tuple');
t.union = require('./lib/union');
t.func = require('./lib/func');
t.intersection = require('./lib/intersection');
t.subtype = t.refinement;

// functions
t.assert = t;
t.update = require('./lib/update');
t.mixin = require('./lib/mixin');
t.isType = require('./lib/isType');
t.is = require('./lib/is');
t.getTypeName = require('./lib/getTypeName');
t.match = require('./lib/match');

module.exports = t;

},{"./lib/Any":113,"./lib/Array":114,"./lib/Boolean":115,"./lib/Date":116,"./lib/Error":117,"./lib/Function":118,"./lib/Nil":119,"./lib/Number":120,"./lib/Object":121,"./lib/RegExp":122,"./lib/String":123,"./lib/assert":124,"./lib/declare":126,"./lib/dict":127,"./lib/enums":128,"./lib/func":131,"./lib/getTypeName":133,"./lib/intersection":134,"./lib/irreducible":135,"./lib/is":136,"./lib/isType":147,"./lib/list":150,"./lib/match":151,"./lib/maybe":152,"./lib/mixin":153,"./lib/refinement":154,"./lib/struct":156,"./lib/tuple":157,"./lib/union":158,"./lib/update":159}],113:[function(require,module,exports){
var irreducible = require('./irreducible');

module.exports = irreducible('Any', function () { return true; });

},{"./irreducible":135}],114:[function(require,module,exports){
var irreducible = require('./irreducible');
var isArray = require('./isArray');

module.exports = irreducible('Array', isArray);

},{"./irreducible":135,"./isArray":137}],115:[function(require,module,exports){
var irreducible = require('./irreducible');
var isBoolean = require('./isBoolean');

module.exports = irreducible('Boolean', isBoolean);

},{"./irreducible":135,"./isBoolean":138}],116:[function(require,module,exports){
var irreducible = require('./irreducible');

module.exports = irreducible('Date', function (x) { return x instanceof Date; });

},{"./irreducible":135}],117:[function(require,module,exports){
var irreducible = require('./irreducible');

module.exports = irreducible('Error', function (x) { return x instanceof Error; });

},{"./irreducible":135}],118:[function(require,module,exports){
var irreducible = require('./irreducible');
var isFunction = require('./isFunction');

module.exports = irreducible('Function', isFunction);

},{"./irreducible":135,"./isFunction":139}],119:[function(require,module,exports){
var irreducible = require('./irreducible');
var isNil = require('./isNil');

module.exports = irreducible('Nil', isNil);

},{"./irreducible":135,"./isNil":142}],120:[function(require,module,exports){
var irreducible = require('./irreducible');
var isNumber = require('./isNumber');

module.exports = irreducible('Number', isNumber);

},{"./irreducible":135,"./isNumber":143}],121:[function(require,module,exports){
var irreducible = require('./irreducible');
var isObject = require('./isObject');

module.exports = irreducible('Object', isObject);

},{"./irreducible":135,"./isObject":144}],122:[function(require,module,exports){
var irreducible = require('./irreducible');

module.exports = irreducible('RegExp', function (x) { return x instanceof RegExp; });

},{"./irreducible":135}],123:[function(require,module,exports){
var irreducible = require('./irreducible');
var isString = require('./isString');

module.exports = irreducible('String', isString);

},{"./irreducible":135,"./isString":145}],124:[function(require,module,exports){
var isFunction = require('./isFunction');
var isNil = require('./isNil');
var fail = require('./fail');
var stringify = require('./stringify');

function assert(guard, message) {
  if (guard !== true) {
    if (isFunction(message)) { // handle lazy messages
      message = message();
    }
    else if (isNil(message)) { // use a default message
      message = 'Assert failed (turn on "Pause on exceptions" in your Source panel)';
    }
    assert.fail(message);
  }
}

assert.fail = fail;
assert.stringify = stringify;

module.exports = assert;
},{"./fail":129,"./isFunction":139,"./isNil":142,"./stringify":155}],125:[function(require,module,exports){
(function (process){
var isType = require('./isType');
var isStruct = require('./isStruct');
var getFunctionName = require('./getFunctionName');
var assert = require('./assert');
var stringify = require('./stringify');

// creates an instance of a type, handling the optional new operator
module.exports = function create(type, value, path) {
  if (isType(type)) {
    // for structs the new operator is allowed
    return isStruct(type) ? new type(value, path) : type(value, path);
  }

  if (process.env.NODE_ENV !== 'production') {
    // here type should be a class constructor and value some instance, just check membership and return the value
    path = path || [getFunctionName(type)];
    assert(value instanceof type, function () { return 'Invalid value ' + stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
};
}).call(this,require('_process'))
},{"./assert":124,"./getFunctionName":132,"./isStruct":146,"./isType":147,"./stringify":155,"_process":86}],126:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var isType = require('./isType');
var isNil = require('./isNil');
var mixin = require('./mixin');
var getTypeName = require('./getTypeName');

// All the .declare-d types should be clearly different from each other thus they should have
// different names when a name was not explicitly provided.
var nextDeclareUniqueId = 1;

module.exports = function declare(name) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isTypeName(name), function () { return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string)'; });
  }

  var type;

  function Declare(value, path) {
    if (process.env.NODE_ENV !== 'production') {
      assert(!isNil(type), function () { return 'Type declared but not defined, don\'t forget to call .define on every declared type'; });
    }
    return type(value, path);
  }

  Declare.define = function (spec) {
    if (process.env.NODE_ENV !== 'production') {
      assert(isType(spec), function () { return 'Invalid argument type ' + assert.stringify(spec) +  ' supplied to define(type) (expected a type)'; });
      assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });
      assert(isNil(spec.meta.name) && Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });
    }

    type = spec;
    mixin(Declare, type, true); // true because it overwrites Declare.displayName
    if (name) {
      type.displayName = Declare.displayName = name;
      Declare.meta.name = name;
    }
    // ensure identity is still false
    Declare.meta.identity = false;
    Declare.prototype = type.prototype;
    return Declare;
  };

  Declare.displayName = name || ( getTypeName(Declare) + "$" + nextDeclareUniqueId++ );
  // in general I can't say if this type will be an identity, for safety setting to false
  Declare.meta = { identity: false };
  Declare.prototype = null;
  return Declare;
};

}).call(this,require('_process'))
},{"./assert":124,"./getTypeName":133,"./isNil":142,"./isType":147,"./isTypeName":148,"./mixin":153,"_process":86}],127:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var isFunction = require('./isFunction');
var getTypeName = require('./getTypeName');
var isIdentity = require('./isIdentity');
var isObject = require('./isObject');
var create = require('./create');
var is = require('./is');

function getDefaultName(domain, codomain) {
  return '{[key: ' + getTypeName(domain) + ']: ' + getTypeName(codomain) + '}';
}

function dict(domain, codomain, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isFunction(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to dict(domain, codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainNameCache = getTypeName(domain);
  var codomainNameCache = getTypeName(codomain);
  var identity = isIdentity(domain) && isIdentity(codomain);

  function Dict(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = {}; // make a temporary copy, will be discarded if idempotent remains true
    for (var k in value) {
      if (value.hasOwnProperty(k)) {
        k = create(domain, k, ( process.env.NODE_ENV !== 'production' ? path.concat(domainNameCache) : null ));
        var actual = value[k];
        var instance = create(codomain, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + codomainNameCache) : null ));
        idempotent = idempotent && ( actual === instance );
        ret[k] = instance;
      }
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  Dict.meta = {
    kind: 'dict',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: identity
  };

  Dict.displayName = displayName;

  Dict.is = function (x) {
    if (!isObject(x)) {
      return false;
    }
    for (var k in x) {
      if (x.hasOwnProperty(k)) {
        if (!is(k, domain) || !is(x[k], codomain)) {
          return false;
        }
      }
    }
    return true;
  };

  Dict.update = function (instance, patch) {
    return Dict(assert.update(instance, patch));
  };

  return Dict;
}

dict.getDefaultName = getDefaultName;
module.exports = dict;

}).call(this,require('_process'))
},{"./assert":124,"./create":125,"./getTypeName":133,"./is":136,"./isFunction":139,"./isIdentity":140,"./isObject":144,"./isTypeName":148,"_process":86}],128:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var forbidNewOperator = require('./forbidNewOperator');
var isString = require('./isString');
var isObject = require('./isObject');

function getDefaultName(map) {
  return Object.keys(map).map(function (k) { return assert.stringify(k); }).join(' | ');
}

function enums(map, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isObject(map), function () { return 'Invalid argument map ' + assert.stringify(map) + ' supplied to enums(map, [name]) combinator (expected a dictionary of String -> String | Number)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to enums(map, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(map);

  function Enums(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Enums);
      path = path || [displayName];
      assert(Enums.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected one of ' + assert.stringify(Object.keys(map)) + ')'; });
    }

    return value;
  }

  Enums.meta = {
    kind: 'enums',
    map: map,
    name: name,
    identity: true
  };

  Enums.displayName = displayName;

  Enums.is = function (x) {
    return map.hasOwnProperty(x);
  };

  return Enums;
}

enums.of = function (keys, name) {
  keys = isString(keys) ? keys.split(' ') : keys;
  var value = {};
  keys.forEach(function (k) {
    value[k] = k;
  });
  return enums(value, name);
};

enums.getDefaultName = getDefaultName;
module.exports = enums;


}).call(this,require('_process'))
},{"./assert":124,"./forbidNewOperator":130,"./isObject":144,"./isString":145,"./isTypeName":148,"_process":86}],129:[function(require,module,exports){
module.exports = function fail(message) {
  throw new TypeError('[tcomb] ' + message);
};
},{}],130:[function(require,module,exports){
var assert = require('./assert');
var getTypeName = require('./getTypeName');

module.exports = function forbidNewOperator(x, type) {
  assert(!(x instanceof type), function () { return 'Cannot use the new operator to instantiate the type ' + getTypeName(type); });
};
},{"./assert":124,"./getTypeName":133}],131:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var FunctionType = require('./Function');
var isArray = require('./isArray');
var list = require('./list');
var isObject = require('./isObject');
var create = require('./create');
var isNil = require('./isNil');
var isBoolean = require('./isBoolean');
var tuple = require('./tuple');
var getFunctionName = require('./getFunctionName');
var getTypeName = require('./getTypeName');

function getDefaultName(domain, codomain) {
  return '(' + domain.map(getTypeName).join(', ') + ') => ' + getTypeName(codomain);
}

function isInstrumented(f) {
  return FunctionType.is(f) && isObject(f.instrumentation);
}

function func(domain, codomain, name) {

  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions

  if (process.env.NODE_ENV !== 'production') {
    assert(list(FunctionType).is(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to func(domain, codomain, [name]) combinator (expected an array of types)'; });
    assert(FunctionType.is(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to func(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain, codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);

  function FuncType(value, curried) {

    if (!isInstrumented(value)) { // automatically instrument the function
      return FuncType.of(value, curried);
    }

    if (process.env.NODE_ENV !== 'production') {
      assert(FuncType.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + displayName; });
    }

    return value;
  }

  FuncType.meta = {
    kind: 'func',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: true
  };

  FuncType.displayName = displayName;

  FuncType.is = function (x) {
    return isInstrumented(x) &&
      x.instrumentation.domain.length === domain.length &&
      x.instrumentation.domain.every(function (type, i) {
        return type === domain[i];
      }) &&
      x.instrumentation.codomain === codomain;
  };

  FuncType.of = function (f, curried) {

    if (process.env.NODE_ENV !== 'production') {
      assert(FunctionType.is(f), function () { return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function)'; });
      assert(isNil(curried) || isBoolean(curried), function () { return 'Invalid argument curried ' + assert.stringify(curried) + ' supplied to func.of ' + displayName + ' (expected a boolean)'; });
    }

    if (FuncType.is(f)) { // makes FuncType.of idempotent
      return f;
    }

    function fn() {
      var args = Array.prototype.slice.call(arguments);
      var len = curried ?
        args.length :
        domain.length;
      var argsType = tuple(domain.slice(0, len));

      args = argsType(args); // type check arguments

      if (len === domain.length) {
        return create(codomain, f.apply(this, args));
      }
      else {
        var g = Function.prototype.bind.apply(f, [this].concat(args));
        var newdomain = func(domain.slice(len), codomain);
        return newdomain.of(g, curried);
      }
    }

    fn.instrumentation = {
      domain: domain,
      codomain: codomain,
      f: f
    };

    fn.displayName = getFunctionName(f);

    return fn;

  };

  return FuncType;

}

func.getDefaultName = getDefaultName;
module.exports = func;

}).call(this,require('_process'))
},{"./Function":118,"./assert":124,"./create":125,"./getFunctionName":132,"./getTypeName":133,"./isArray":137,"./isBoolean":138,"./isNil":142,"./isObject":144,"./isTypeName":148,"./list":150,"./tuple":157,"_process":86}],132:[function(require,module,exports){
module.exports = function getFunctionName(f) {
  return f.displayName || f.name || '<function' + f.length + '>';
};
},{}],133:[function(require,module,exports){
var isType = require('./isType');
var getFunctionName = require('./getFunctionName');

module.exports = function getTypeName(constructor) {
  if (isType(constructor)) {
    return constructor.displayName;
  }
  return getFunctionName(constructor);
};
},{"./getFunctionName":132,"./isType":147}],134:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var isFunction = require('./isFunction');
var isArray = require('./isArray');
var forbidNewOperator = require('./isIdentity');
var is = require('./is');
var getTypeName = require('./getTypeName');

function getDefaultName(types) {
  return types.map(getTypeName).join(' & ');
}

function intersection(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);

  function Intersection(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Intersection);
      path = path || [displayName];
      assert(Intersection.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  Intersection.meta = {
    kind: 'intersection',
    types: types,
    name: name,
    identity: true
  };

  Intersection.displayName = displayName;

  Intersection.is = function (x) {
    return types.every(function (type) {
      return is(x, type);
    });
  };

  Intersection.update = function (instance, patch) {
    return Intersection(assert.update(instance, patch));
  };

  return Intersection;
}

intersection.getDefaultName = getDefaultName;
module.exports = intersection;


}).call(this,require('_process'))
},{"./assert":124,"./getTypeName":133,"./is":136,"./isArray":137,"./isFunction":139,"./isIdentity":140,"./isTypeName":148,"_process":86}],135:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isString = require('./isString');
var isFunction = require('./isFunction');
var forbidNewOperator = require('./forbidNewOperator');

module.exports = function irreducible(name, predicate) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isString(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to irreducible(name, predicate) (expected a string)'; });
    assert(isFunction(predicate), 'Invalid argument predicate ' + assert.stringify(predicate) + ' supplied to irreducible(name, predicate) (expected a function)');
  }

  function Irreducible(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Irreducible);
      path = path || [name];
      assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  Irreducible.meta = {
    kind: 'irreducible',
    name: name,
    predicate: predicate,
    identity: true
  };

  Irreducible.displayName = name;

  Irreducible.is = predicate;

  return Irreducible;
};

}).call(this,require('_process'))
},{"./assert":124,"./forbidNewOperator":130,"./isFunction":139,"./isString":145,"_process":86}],136:[function(require,module,exports){
var isType = require('./isType');

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.is(x);
  }
  return x instanceof type; // type should be a class constructor
};

},{"./isType":147}],137:[function(require,module,exports){
module.exports = function isArray(x) {
  return x instanceof Array;
};
},{}],138:[function(require,module,exports){
module.exports = function isBoolean(x) {
  return x === true || x === false;
};
},{}],139:[function(require,module,exports){
module.exports = function isFunction(x) {
  return typeof x === 'function';
};
},{}],140:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var Boolean = require('./Boolean');
var isType = require('./isType');
var getTypeName = require('./getTypeName');

// return true if the type constructor behaves like the identity function
module.exports = function isIdentity(type) {
  if (isType(type)) {
    if (process.env.NODE_ENV !== 'production') {
      assert(Boolean.is(type.meta.identity), function () { return 'Invalid meta identity ' + assert.stringify(type.meta.identity) + ' supplied to type ' + getTypeName(type); });
    }
    return type.meta.identity;
  }
  // for tcomb the other constructors, like ES6 classes, are identity-like
  return true;
};
}).call(this,require('_process'))
},{"./Boolean":115,"./assert":124,"./getTypeName":133,"./isType":147,"_process":86}],141:[function(require,module,exports){
var isType = require('./isType');

module.exports = function isMaybe(x) {
  return isType(x) && ( x.meta.kind === 'maybe' );
};
},{"./isType":147}],142:[function(require,module,exports){
module.exports = function isNil(x) {
  return x === null || x === void 0;
};
},{}],143:[function(require,module,exports){
module.exports = function isNumber(x) {
  return typeof x === 'number' && isFinite(x) && !isNaN(x);
};
},{}],144:[function(require,module,exports){
var isNil = require('./isNil');
var isArray = require('./isArray');

module.exports = function isObject(x) {
  return !isNil(x) && typeof x === 'object' && !isArray(x);
};
},{"./isArray":137,"./isNil":142}],145:[function(require,module,exports){
module.exports = function isString(x) {
  return typeof x === 'string';
};
},{}],146:[function(require,module,exports){
var isType = require('./isType');

module.exports = function isStruct(x) {
  return isType(x) && ( x.meta.kind === 'struct' );
};
},{"./isType":147}],147:[function(require,module,exports){
var isFunction = require('./isFunction');
var isObject = require('./isObject');

module.exports = function isType(x) {
  return isFunction(x) && isObject(x.meta);
};
},{"./isFunction":139,"./isObject":144}],148:[function(require,module,exports){
var isNil = require('./isNil');
var isString = require('./isString');

module.exports = function isTypeName(name) {
  return isNil(name) || isString(name);
};
},{"./isNil":142,"./isString":145}],149:[function(require,module,exports){
var isType = require('./isType');

module.exports = function isUnion(x) {
  return isType(x) && ( x.meta.kind === 'union' );
};
},{"./isType":147}],150:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var isFunction = require('./isFunction');
var getTypeName = require('./getTypeName');
var isIdentity = require('./isIdentity');
var create = require('./create');
var is = require('./is');
var isArray = require('./isArray');

function getDefaultName(type) {
  return 'Array<' + getTypeName(type) + '>';
}

function list(type, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var typeNameCache = getTypeName(type);
  var identity = isIdentity(type); // the list is identity iif type is identity

  function List(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isArray(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of ' + typeNameCache + ')'; });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = []; // make a temporary copy, will be discarded if idempotent remains true
    for (var i = 0, len = value.length; i < len; i++ ) {
      var actual = value[i];
      var instance = create(type, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + typeNameCache) : null ));
      idempotent = idempotent && ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  List.meta = {
    kind: 'list',
    type: type,
    name: name,
    identity: identity
  };

  List.displayName = displayName;

  List.is = function (x) {
    return isArray(x) && x.every(function (e) {
      return is(e, type);
    });
  };

  List.update = function (instance, patch) {
    return List(assert.update(instance, patch));
  };

  return List;
}

list.getDefaultName = getDefaultName;
module.exports = list;

}).call(this,require('_process'))
},{"./assert":124,"./create":125,"./getTypeName":133,"./is":136,"./isArray":137,"./isFunction":139,"./isIdentity":140,"./isTypeName":148,"_process":86}],151:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isFunction = require('./isFunction');
var isType = require('./isType');
var Any = require('./Any');

module.exports = function match(x) {
  var type, guard, f, count;
  for (var i = 1, len = arguments.length; i < len; ) {
    type = arguments[i];
    guard = arguments[i + 1];
    f = arguments[i + 2];

    if (isFunction(f) && !isType(f)) {
      i = i + 3;
    }
    else {
      f = guard;
      guard = Any.is;
      i = i + 2;
    }

    if (process.env.NODE_ENV !== 'production') {
      count = (count || 0) + 1;
      assert(isType(type), function () { return 'Invalid type in clause #' + count; });
      assert(isFunction(guard), function () { return 'Invalid guard in clause #' + count; });
      assert(isFunction(f), function () { return 'Invalid block in clause #' + count; });
    }

    if (type.is(x) && guard(x)) {
      return f(x);
    }
  }
  assert.fail('Match error');
};

}).call(this,require('_process'))
},{"./Any":113,"./assert":124,"./isFunction":139,"./isType":147,"_process":86}],152:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var isFunction = require('./isFunction');
var isMaybe = require('./isMaybe');
var isIdentity = require('./isIdentity');
var Any = require('./Any');
var create = require('./create');
var Nil = require('./Nil');
var forbidNewOperator = require('./forbidNewOperator');
var is = require('./is');
var getTypeName = require('./getTypeName');

function getDefaultName(type) {
  return '?' + getTypeName(type);
}

function maybe(type, name) {

  if (isMaybe(type) || type === Any || type === Nil) { // makes the combinator idempotent and handle Any, Nil
    return type;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to maybe(type, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to maybe(type, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);

  function Maybe(value, path) {
    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Maybe);
    }
    return Nil.is(value) ? null : create(type, value, path);
  }

  Maybe.meta = {
    kind: 'maybe',
    type: type,
    name: name,
    identity: isIdentity(type)
  };

  Maybe.displayName = displayName;

  Maybe.is = function (x) {
    return Nil.is(x) || is(x, type);
  };

  return Maybe;
}

maybe.getDefaultName = getDefaultName;
module.exports = maybe;

}).call(this,require('_process'))
},{"./Any":113,"./Nil":119,"./assert":124,"./create":125,"./forbidNewOperator":130,"./getTypeName":133,"./is":136,"./isFunction":139,"./isIdentity":140,"./isMaybe":141,"./isTypeName":148,"_process":86}],153:[function(require,module,exports){
(function (process){
var isNil = require('./isNil');
var assert = require('./assert');

// safe mixin, cannot override props unless specified
module.exports = function mixin(target, source, overwrite) {
  if (isNil(source)) { return target; }
  for (var k in source) {
    if (source.hasOwnProperty(k)) {
      if (overwrite !== true) {
        if (process.env.NODE_ENV !== 'production') {
          assert(!target.hasOwnProperty(k), function () { return 'Invalid call to mixin(target, source, [overwrite]): cannot overwrite property "' + k + '" of target object'; });
        }
      }
      target[k] = source[k];
    }
  }
  return target;
};
}).call(this,require('_process'))
},{"./assert":124,"./isNil":142,"_process":86}],154:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var isFunction = require('./isFunction');
var forbidNewOperator = require('./forbidNewOperator');
var isIdentity = require('./isIdentity');
var create = require('./create');
var is = require('./is');
var getTypeName = require('./getTypeName');
var getFunctionName = require('./getFunctionName');

function getDefaultName(type, predicate) {
  return '{' + getTypeName(type) + ' | ' + getFunctionName(predicate) + '}';
}

function refinement(type, predicate, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type, predicate, [name]) combinator (expected a type)'; });
    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name]) combinator (expected a function)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type, predicate, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type, predicate);
  var identity = isIdentity(type);

  function Refinement(value, path) {

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Refinement);
      path = path || [displayName];
    }

    var x = create(type, value, path);

    if (process.env.NODE_ENV !== 'production') {
      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return x;
  }

  Refinement.meta = {
    kind: 'subtype',
    type: type,
    predicate: predicate,
    name: name,
    identity: identity
  };

  Refinement.displayName = displayName;

  Refinement.is = function (x) {
    return is(x, type) && predicate(x);
  };

  Refinement.update = function (instance, patch) {
    return Refinement(assert.update(instance, patch));
  };

  return Refinement;
}

refinement.getDefaultName = getDefaultName;
module.exports = refinement;

}).call(this,require('_process'))
},{"./assert":124,"./create":125,"./forbidNewOperator":130,"./getFunctionName":132,"./getTypeName":133,"./is":136,"./isFunction":139,"./isIdentity":140,"./isTypeName":148,"_process":86}],155:[function(require,module,exports){
module.exports = function stringify(x) {
  try { // handle "Converting circular structure to JSON" error
    return JSON.stringify(x, null, 2);
  }
  catch (e) {
    return String(x);
  }
};
},{}],156:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var String = require('./String');
var Function = require('./Function');
var isArray = require('./isArray');
var isObject = require('./isObject');
var create = require('./create');
var mixin = require('./mixin');
var isStruct = require('./isStruct');
var getTypeName = require('./getTypeName');
var dict = require('./dict');

function getDefaultName(props) {
  return '{' + Object.keys(props).map(function (prop) {
    return prop + ': ' + getTypeName(props[prop]);
  }).join(', ') + '}';
}

function extend(mixins, name) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(mixins) && mixins.every(function (x) {
      return isObject(x) || isStruct(x);
    }), function () { return 'Invalid argument mixins supplied to extend(mixins, name), expected an array of objects or structs'; });
  }
  var props = {};
  var prototype = {};
  mixins.forEach(function (struct) {
    if (isObject(struct)) {
      mixin(props, struct);
    }
    else {
      mixin(props, struct.meta.props);
      mixin(prototype, struct.prototype);
    }
  });
  var ret = struct(props, name);
  mixin(ret.prototype, prototype);
  return ret;
}

function struct(props, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied to struct(props, [name]) combinator (expected a dictionary String -> Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to struct(props, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(props);

  function Struct(value, path) {

    if (Struct.is(value)) { // implements idempotency
      return value;
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an object)'; });
    }

    if (!(this instanceof Struct)) { // `new` is optional
      return new Struct(value, path);
    }

    for (var k in props) {
      if (props.hasOwnProperty(k)) {
        var expected = props[k];
        var actual = value[k];
        this[k] = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + getTypeName(expected)) : null ));
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(this);
    }

  }

  Struct.meta = {
    kind: 'struct',
    props: props,
    name: name,
    identity: false
  };

  Struct.displayName = displayName;

  Struct.is = function (x) {
    return x instanceof Struct;
  };

  Struct.update = function (instance, patch) {
    return new Struct(assert.update(instance, patch));
  };

  Struct.extend = function (structs, name) {
    return extend([Struct].concat(structs), name);
  };

  return Struct;
}

struct.getDefaultName = getDefaultName;
struct.extend = extend;
module.exports = struct;

}).call(this,require('_process'))
},{"./Function":118,"./String":123,"./assert":124,"./create":125,"./dict":127,"./getTypeName":133,"./isArray":137,"./isObject":144,"./isStruct":146,"./isTypeName":148,"./mixin":153,"_process":86}],157:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var isFunction = require('./isFunction');
var getTypeName = require('./getTypeName');
var isIdentity = require('./isIdentity');
var isArray = require('./isArray');
var create = require('./create');
var is = require('./is');

function getDefaultName(types) {
  return '[' + types.map(getTypeName).join(', ') + ']';
}

function tuple(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) && types.every(isFunction), function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to tuple(types, [name]) combinator (expected an array of types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to tuple(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Tuple(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value;
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      path = path || [displayName];
      assert(isArray(value) && value.length === types.length, function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of length ' + types.length + ')'; });
    }

    var idempotent = true;
    var ret = [];
    for (var i = 0, len = types.length; i < len; i++) {
      var expected = types[i];
      var actual = value[i];
      var instance = create(expected, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + getTypeName(expected)) : null ));
      idempotent = idempotent && ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(ret);
    }

    return ret;
  }

  Tuple.meta = {
    kind: 'tuple',
    types: types,
    name: name,
    identity: identity
  };

  Tuple.displayName = displayName;

  Tuple.is = function (x) {
    return isArray(x) &&
      x.length === types.length &&
      types.every(function (type, i) {
        return is(x[i], type);
      });
  };

  Tuple.update = function (instance, patch) {
    return Tuple(assert.update(instance, patch));
  };

  return Tuple;
}

tuple.getDefaultName = getDefaultName;
module.exports = tuple;
}).call(this,require('_process'))
},{"./assert":124,"./create":125,"./getTypeName":133,"./is":136,"./isArray":137,"./isFunction":139,"./isIdentity":140,"./isTypeName":148,"_process":86}],158:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isTypeName = require('./isTypeName');
var isFunction = require('./isFunction');
var getTypeName = require('./getTypeName');
var isIdentity = require('./isIdentity');
var isArray = require('./isArray');
var create = require('./create');
var is = require('./is');
var forbidNewOperator = require('./forbidNewOperator');
var isType = require('./isType');
var isUnion = require('./isUnion');
var isNil = require('./isNil');

function getDefaultName(types) {
  return types.map(getTypeName).join(' | ');
}

function union(types, name) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Union(value, path) {

    if (process.env.NODE_ENV === 'production') {
      if (identity) {
        return value;
      }
    }

    var type = Union.dispatch(value);
    if (!type && Union.is(value)) {
      return value;
    }

    if (process.env.NODE_ENV !== 'production') {
      forbidNewOperator(this, Union);
      path = path || [displayName];
      assert(isType(type), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (no constructor returned by dispatch)'; });
      path[path.length - 1] += '(' + getTypeName(type) + ')';
    }

    return create(type, value, path);
  }

  Union.meta = {
    kind: 'union',
    types: types,
    name: name,
    identity: identity
  };

  Union.displayName = displayName;

  Union.is = function (x) {
    return types.some(function (type) {
      return is(x, type);
    });
  };

  Union.dispatch = function (x) { // default dispatch implementation
    for (var i = 0, len = types.length; i < len; i++ ) {
      var type = types[i];
      if (isUnion(type)) { // handle union of unions
        var t = type.dispatch(x);
        if (!isNil(t)) {
          return t;
        }
      }
      else if (is(x, type)) {
        return type;
      }
    }
  };

  Union.update = function (instance, patch) {
    return Union(assert.update(instance, patch));
  };

  return Union;
}

union.getDefaultName = getDefaultName;
module.exports = union;


}).call(this,require('_process'))
},{"./assert":124,"./create":125,"./forbidNewOperator":130,"./getTypeName":133,"./is":136,"./isArray":137,"./isFunction":139,"./isIdentity":140,"./isNil":142,"./isType":147,"./isTypeName":148,"./isUnion":149,"_process":86}],159:[function(require,module,exports){
(function (process){
var assert = require('./assert');
var isObject = require('./isObject');
var isFunction = require('./isFunction');
var isArray = require('./isArray');
var isNumber = require('./isNumber');
var mixin = require('./mixin');

function getShallowCopy(x) {
  if (isArray(x)) {
    return x.concat();
  }
  if (x instanceof Date || x instanceof RegExp) {
    return x;
  }
  if (isObject(x)) {
    return mixin({}, x);
  }
  return x;
}

function update(instance, patch) {

  if (process.env.NODE_ENV !== 'production') {
    assert(isObject(patch), function () { return 'Invalid argument patch ' + assert.stringify(patch) + ' supplied to function update(instance, patch): expected an object containing commands'; });
  }

  var value = getShallowCopy(instance);
  var isChanged = false;
  for (var k in patch) {
    if (patch.hasOwnProperty(k)) {
      if (update.commands.hasOwnProperty(k)) {
        value = update.commands[k](patch[k], value);
        isChanged = true;
      }
      else {
        var newValue = update(value[k], patch[k]);
        isChanged = isChanged || ( newValue !== value[k] );
        value[k] = newValue;
      }
    }
  }
  return isChanged ? value : instance;
}

// built-in commands

function $apply(f, value) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isFunction(f), 'Invalid argument f supplied to immutability helper { $apply: f } (expected a function)');
  }
  return f(value);
}

function $push(elements, arr) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper { $push: elements } (expected an array)');
    assert(isArray(arr), 'Invalid value supplied to immutability helper $push (expected an array)');
  }
  return arr.concat(elements);
}

function $remove(keys, obj) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(keys), 'Invalid argument keys supplied to immutability helper { $remove: keys } (expected an array)');
    assert(isObject(obj), 'Invalid value supplied to immutability helper $remove (expected an object)');
  }
  for (var i = 0, len = keys.length; i < len; i++ ) {
    delete obj[keys[i]];
  }
  return obj;
}

function $set(value) {
  return value;
}

function $splice(splices, arr) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(splices) && splices.every(isArray), 'Invalid argument splices supplied to immutability helper { $splice: splices } (expected an array of arrays)');
    assert(isArray(arr), 'Invalid value supplied to immutability helper $splice (expected an array)');
  }
  return splices.reduce(function (acc, splice) {
    acc.splice.apply(acc, splice);
    return acc;
  }, arr);
}

function $swap(config, arr) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isObject(config), 'Invalid argument config supplied to immutability helper { $swap: config } (expected an object)');
    assert(isNumber(config.from), 'Invalid argument config.from supplied to immutability helper { $swap: config } (expected a number)');
    assert(isNumber(config.to), 'Invalid argument config.to supplied to immutability helper { $swap: config } (expected a number)');
    assert(isArray(arr), 'Invalid value supplied to immutability helper $swap (expected an array)');
  }
  var element = arr[config.to];
  arr[config.to] = arr[config.from];
  arr[config.from] = element;
  return arr;
}

function $unshift(elements, arr) {
  if (process.env.NODE_ENV !== 'production') {
    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper {$unshift: elements} (expected an array)');
    assert(isArray(arr), 'Invalid value supplied to immutability helper $unshift (expected an array)');
  }
  return elements.concat(arr);
}

function $merge(obj, value) {
  return mixin(mixin({}, value), obj, true);
}

update.commands = {
  $apply: $apply,
  $push: $push,
  $remove: $remove,
  $set: $set,
  $splice: $splice,
  $swap: $swap,
  $unshift: $unshift,
  $merge: $merge
};

module.exports = update;

}).call(this,require('_process'))
},{"./assert":124,"./isArray":137,"./isFunction":139,"./isNumber":143,"./isObject":144,"./mixin":153,"_process":86}],160:[function(require,module,exports){
(function (process){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,require('_process'))
},{"_process":86,"stream":102}],161:[function(require,module,exports){
(function (factory) {  
  if (typeof exports == 'object') {
    module.exports = factory();
  } else if ((typeof define == 'function') && define.amd) {
    define(factory);
  }
}(function () {

  var isBuiltIn = (function () {
    var built_ins = [
      Object,
      Function,
      Array,
      String,
      Boolean,
      Number,
      Date,
      RegExp,
      Error
    ];
    var built_ins_length = built_ins.length;

    return function (_constructor) {
      for (var i = 0; i < built_ins_length; i++) {
        if (built_ins[i] === _constructor) {
          return true;
        }
      }
      return false;
    };
  })();

  var stringType = (function () {
    var _toString = ({}).toString;

    return function (obj) {
      // For now work around this bug in PhantomJS
      // https://github.com/ariya/phantomjs/issues/11722
      if (obj === null) {
        return 'null';
      } else if (obj === undefined) {
        return 'undefined';
      }

      // [object Blah] -> Blah
      var stype = _toString.call(obj).slice(8, -1);

      // Temporarily elided see commented on line 37 above
      // if ((obj === null) || (obj === undefined)) {
      //   return stype.toLowerCase();
      // }

      var ctype = of(obj);

      if (ctype && !isBuiltIn(ctype)) {
        return ctype.name;
      } else {
        return stype;
      }
    };
  })();

  function of (obj) {
    if ((obj === null) || (obj === undefined)) {
      return obj;
    } else {
      return obj.constructor;
    }
  }

  function is (obj, test) {
    var typer = (of(test) === String) ? stringType : of;
    return (typer(obj) === test);
  }
  
  function instance (obj, test) {
    return (obj instanceof test);
  }

  function extension (_Extension, _Base) {
    return instance(_Extension.prototype, _Base);
  }

  function any (obj, tests) {
    if (!is(tests, Array)) {
      throw ("Second argument to .any() should be array")
    }
    for (var i = 0; i < tests.length; i++) {
      var test = tests[i];
      if (is(obj, test)) {
        return true;
      }
    }
    return false;
  }
  
  var exports = function (obj, type) {
    if (arguments.length == 1) {
      return of(obj);
    } else {
      if (is(type, Array)) {
        return any(obj, type);
      } else {
        return is(obj, type);
      }
    }
  }

  exports.instance  = instance;
  exports.string    = stringType;
  exports.of        = of;
  exports.is        = is;
  exports.any       = any;
  exports.extension = extension;
  return exports;

}));

},{}],162:[function(require,module,exports){
var reg = /[\'\"]/

module.exports = function unquote(str) {
  if (!str) {
    return ''
  }
  if (reg.test(str.charAt(0))) {
    str = str.substr(1)
  }
  if (reg.test(str.charAt(str.length - 1))) {
    str = str.substr(0, str.length - 1)
  }
  return str
}

},{}],163:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],164:[function(require,module,exports){
(function (Buffer){
module.exports = function isBuffer(arg) {
  return arg instanceof Buffer;
}

}).call(this,require("buffer").Buffer)
},{"buffer":5}],165:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":164,"_process":86,"inherits":36}],166:[function(require,module,exports){
var luminance = require('relative-luminance');
var hexRgb = require('hex-rgb');

// http://www.w3.org/TR/WCAG20/#contrast-ratiodef

module.exports.luminance = fromLum;
module.exports.rgb = fromRGB;
module.exports.hex = fromHex;
module.exports.score = score;

/*
 * @param {number} a luminance value
 * @param {number} b luminance value
 * @returns {number} contrast ratio
 */
function fromLum(a, b) {
    var l1 = Math.max(a, b),
        l2 = Math.min(a, b);
    return (l1 + 0.05) / (l2 + 0.05);
}

/*
 * @param {array} a rgb value
 * @param {array} b rgb value
 * @returns {number} contrast ratio
 */
function fromRGB(a, b) {
    return fromLum(luminance(a), luminance(b));
}

/*
 * @param {string} a hex value
 * @param {string} b hex value
 * @returns {number} contrast ratio
 */
function fromHex(a, b) {
    return fromRGB(hexRgb(a), hexRgb(b));
}

/*
 * @param {array} a rgb value
 * @param {array} b rgb value
 * @returns {number} contrast ratio
 */
function score(contrast) {
    return (contrast >= 7) ? 'AAA' : (contrast >= 4.5) ? 'AA' : '';
}

},{"hex-rgb":34,"relative-luminance":99}]},{},[1]);
