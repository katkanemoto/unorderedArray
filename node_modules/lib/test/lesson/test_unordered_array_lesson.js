var lesson = require('lib/lesson/unordered_array_lesson');
var test = require('tape');
var check = require('check-types');

test('[lesson] incorrect, no arguments', function (t) {
	t.plan(4);
	
	try {
		lesson();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

test('[lesson] incorrect, bad argument', function (t) {
	t.plan(4);
	
	try {
		lesson("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

test('[lesson] incorrect, UI argument wrong type', function (t) {
	t.plan(4);
	
	try {
		lesson({UI: "some bad argument"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

test('[lesson] correct, insert button, setup event handler (sync)', function (t) {
	t.plan(2);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	var insert_button_event_type;
	var insert_button_listener;
	ui.insert_button.addEventListener = function(type, listener) {
		insert_button_event_type = type;
		insert_button_listener = listener;
	}
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var pre_start_backup = lesson.prototype.pre_start;
	
	var called_pre_start = 0;
	lesson.prototype.pre_start = function() {
		called_pre_start += 1;
	}
	
	var l = lesson({UI: ui});
	
	//TEST
	t.equal(insert_button_event_type, 'click', 'setup a click handler');
	insert_button_listener();
	t.equal(called_pre_start, 1, 'event handler calls next()');
	
	//CLEANUP
	lesson.prototype.pre_start = pre_start_backup;
});

test('[lesson] correct, insert button, event handler (async)', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	ui.insert_button = document.createElement('input');
	ui.insert_button.type = 'button';
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var pre_start_backup = lesson.prototype.pre_start;
	lesson.prototype.pre_start = function() {
		//TEST
		t.ok(true, "saw click event from 'insert' button");
		
		//CLEANUP
		lesson.prototype.pre_start = pre_start_backup;
	}
	
	var l = lesson({UI: ui});
	ui.insert_button.dispatchEvent(new Event("click"));
});

test('[lesson] correct, next button, setup event handler', function (t) {
	t.plan(2);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	var next_button_event_type;
	var next_button_listener;
	ui.next_button.addEventListener = function(type, listener) {
		next_button_event_type = type;
		next_button_listener = listener;
	}
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var next_backup = lesson.prototype.next;
	var called_next = 0;
	lesson.prototype.next = function() {
		called_next += 1;
	}
	
	var l = lesson({UI: ui});
	
	//TEST
	t.equal(next_button_event_type, 'click', 'setup a click handler');
	next_button_listener();
	t.equal(called_next, 1, 'event handler calls next()');
	
	//CLEANUP
	lesson.prototype.next = next_backup;
});

test('[lesson] correct, next button, event handler (async)', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	ui.next_button = document.createElement('input');
	ui.next_button.type = 'button';
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var next_backup = lesson.prototype.next;
	lesson.prototype.next = function() {
		//TEST
		t.ok(true, "saw click event from 'next' button");
		
		//CLEANUP
		lesson.prototype.next = next_backup;
	}
	
	var l = lesson({UI: ui});
	ui.next_button.dispatchEvent(new Event("click"));
});

test('[lesson.pre_start] correct, not in correct state', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	var get_called = false;
	ui.input.get = function() {
		get_called = true;
	}
	
	var l = lesson({UI: ui});
	
	l._state = -1;	//setup invalid state
	
	l.pre_start();
	
	//TEST
	t.notOk(get_called, 'input has not been pulled from the UI');
});

test('[lesson.pre_start] correct, correct state & bad input', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	ui.input.get = function() {
		return Number.NaN;
	}
	
	var output;
	ui.output.set = function(text) {
		output = text;
	}
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	//TEST
	t.ok(output.match(/not a number/), 'shows what was wrong');
	t.ok(output.match(/Please enter a number/), 'tells you what to enter');
	t.ok(output.match(/press the insert button/), '...and what to do');
});

test('[lesson.pre_start] correct, working array full case detected', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	ui.array.working.size = 1;
	ui.array.working.push(0);
	
	ui.input.get = function() {
		return 0;
	}
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	t.ok(l._array_full, 'saw that the array was full');
});

test('[lesson.pre_start] correct, working array NOT full case detected', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 0;
	}
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	t.notOk(l._array_full, 'saw that the array was NOT full');
});

test('[lesson.pre_start] correct, starting the lesson logic', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 0;
	}
	
	var next_backup = lesson.prototype.next;
	lesson.prototype.next = function() {
		t.ok(true, "called next()");
	}
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	t.equal(l._state, l._RUN, 'running the lesson');
	t.equal(l._step_state, l._STEP_1, 'step 1 of the lessson');
	
	//cleanup
	lesson.prototype.next = next_backup;
});

test('[lesson.pre_start] correct, case: array not full, initial call', function (t) {
	t.plan(11);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock move() function to check for call
	ui.array.move = function() {
		t.ok(true, 'called move()');
	}
	
	//create a mock set() function to check for call
	ui.output.set = function() {
		t.ok(true, 'called set()');
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 0;
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	var result = l.pre_start();
	
	//TEST
	t.equal(ui.array.input.length, 0, 'removed item from input array');
	t.equal(ui.array.working.length, 1, 'working array now has new item');
	t.equal(ui.array.working[0], 1, '...which was the value taken from get()');
	t.equal(l._state, l._RUN, 'still in the running state');
	t.equal(l._step_state, l._STEP_2, 'but now in the second step of the lesson')
	t.ok(check.object(result));
	t.notOk(result.done, 'not finished yet');
	t.ok(result.value.match(/Added the value/));
	t.ok(result.value.match(/to the array/));
});

test('[lesson.next] correct, case: array not full, final call', function (t) {
	t.plan(11);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock move() function to check for call
	ui.array.move = function() {
		t.ok(true, 'called move()');
	}
	
	//create a mock set() function to check for call
	ui.output.set = function() {
		t.ok(true, 'called set()');
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 0;
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	
	//FIRST PRESS
	var result = l.pre_start();
	
	//TEST
	t.notOk(result.done, 'not finished yet');
	t.equal(l._state, l._RUN, 'still in the running state');
	
	//SECOND PRESS
	result = l.next();
	
	//TEST
	t.ok(result.done, 'finished');
	t.equal(l._step_state, undefined, 'reset step state')
	t.equal(l._state, l._READY, 'in the ready state');
	t.ok(result.value.match(/Moved the \'tail\' pointer/));
	t.ok(result.value.match(/to prepare for the next insertion/));
	t.equal(ui.arrow.working.index, 1, 'incremented the index for the arrow');
});

test('[lesson.pre_start] correct, case: array full, call 1', function (t) {
	t.plan(8);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	ui.arrow.working.increment();	//move the tail pointer up
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = false;
	ui.output.set = function() {
		output_set_called = true;
	};
	
	var array_get_called = false;
	ui.array.get = function() {
		array_get_called = true;
	}
	
	var arrow_get_called = false;
	ui.arrow.get = function() {
		arrow_get_called = true;
	}
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	var result = l.pre_start();
	
	//TEST
	t.equal(l._state, l._RUN, 'in the running state');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Array is full/));
	t.ok(result.value.match(/Allocating new array/));
	t.equal(l._step_state, l._STEP_2, 'now in the second step of the lesson');
	t.ok(output_set_called, 'set the output to the message about what was done on this step')
	t.ok(array_get_called, 'got a new array');
	t.ok(arrow_get_called, 'got a new arrow');
});

test('[lesson.next] correct, case: array full, call 2', function (t) {
	t.plan(6);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	ui.arrow.working.increment();	//move the tail pointer up
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = false;
	ui.output.set = function() {
		output_set_called = true;
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	
	//SETUP, PRESS 1
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	l._array_full = true;
	l._array_tmp = ui.array.get({size:ui.array.working.size*2, nodes:0});
	l._arrow_tmp = ui.arrow.get({name:'tail', array:l._array_tmp, index:0});
	
	//PRESS 2
	var result = l.next();
	
	//TEST
	t.ok(check.object(l._move_pointer), 'setup the move pointer');
	t.ok(output_set_called, 'set a new message');
	t.equal(l._state, l._RUN, 'in the running state');
	t.notOk(result.done, 'not finished');
	t.equal(l._step_state, l._STEP_MOVING, 'third step on next()');
	t.ok(result.value.match(/move pointer/));
});

test('[lesson.next] correct, case: array full, call 3 - moving', function (t) {
	t.plan(5);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	ui.arrow.working.increment();	//move the tail pointer up
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = 0;
	ui.output.set = function() {
		output_set_called += 1;
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	
	//SETUP, PRESS 1
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	l._array_full = true;
	l._array_tmp = ui.array.get({size:ui.array.working.size*2, nodes:0});
	l._arrow_tmp = ui.arrow.get({name:'tail', array:l._array_tmp, index:0});
	
	//SETUP, PRESS 2
	l._move_pointer = ui.arrow.get({name:'move', array:ui.array.working, index:0});
	l._step_state = l._STEP_MOVING;
	
	//PRESS 3
	/* console.log(l._array_tmp);
	console.log(l._arrow_tmp);
	console.log(ui.array.working);
	console.log(ui.arrow.working);
	console.log(l._move_pointer); */
	
	//console.log("next()");
	var result = l.next();
	
	/* console.log(l._array_tmp);
	console.log(l._arrow_tmp);
	console.log(ui.array.working);
	console.log(ui.arrow.working);
	console.log(l._move_pointer); */
	
	//TEST
	
	t.equal(output_set_called, 1, 'set a new message');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Moved value/));
	t.equal(l._move_pointer.index, 1, 'advanced the move pointer on the old array one space');
	t.equal(l._arrow_tmp.index, 1, 'advanced the tail pointer on the new array one space, since we added a new value');
});

test('[lesson.next] correct, case: array full, call 4 - exiting from move', function (t) {
	t.plan(4);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	ui.arrow.working.increment();	//move the tail pointer up
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = 0;
	ui.output.set = function() {
		output_set_called += 1;
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	
	//SETUP, PRESS 1
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	l._array_full = true;
	l._array_tmp = ui.array.get({size:ui.array.working.size*2, nodes:0});
	l._arrow_tmp = ui.arrow.get({name:'tail', array:l._array_tmp, index:0});
	
	//SETUP, PRESS 2
	l._move_pointer = ui.arrow.get({name:'move', array:ui.array.working, index:0});
	l._step_state = l._STEP_MOVING;
	
	//SETUP, PRESS 3
	l._move_pointer.increment();
	l._arrow_tmp.increment();
	l._array_tmp[0] = 0;
	
	//PRESS
	var result = l.next();
	
	//TEST
	t.equal(output_set_called, 1, 'set a new message');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/we\'ve finished moving the values/));
	t.equal(l._step_state, l._STEP_3, 'should be in the next step after moving after this');
});

test('[lesson.next] correct, case: array full, call 5 - removing old array and setting up new array as "working"', function (t) {
	t.plan(11);
	
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	ui.arrow.working.increment();	//move the tail pointer up
	
	//modify to be a full array of length 1
	ui.array.working.size = 1;
	ui.array.working[0] = 0;
	
	//setup get() so that it return a valid value to pre_start()
	ui.input.get = function() {
		return 1;
	}
	
	//create a mock set() function to check for call
	var output_set_called = 0;
	ui.output.set = function() {
		output_set_called += 1;
	};
	
	//insert a mock value in the input array
	ui.array.input[0] = 1;
	
	var l = lesson({UI: ui});
	
	//SETUP, PRESS 1
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	l._array_full = true;
	var new_array = ui.array.get({size:ui.array.working.size*2, nodes:0});
	l._array_tmp = new_array;
	var new_tail_arrow = ui.arrow.get({name:'tail', array:l._array_tmp, index:0});
	l._arrow_tmp = new_tail_arrow;
	
	//SETUP, PRESS 2
	l._move_pointer = ui.arrow.get({name:'move', array:ui.array.working, index:0});
	l._step_state = l._STEP_MOVING;
	
	//SETUP, PRESS 3
	l._move_pointer.increment();
	l._arrow_tmp.increment();
	l._array_tmp[0] = 0;
	
	//SETUP, PRESS 4
	l._step_state = l._STEP_3;
	
	//create mock del() functions to track number of calls
	var array_del_called = 0;
	ui.array.del = function() {
		array_del_called += 1;
	};
	
	var arrow_del_called = 0;
	ui.arrow.del = function() {
		arrow_del_called += 1;
	};
	
	//PRESS
	var result = l.next();
	
	//TEST
	t.equal(output_set_called, 1, 'set a new message');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Removing the old array/));
	t.equal(l._step_state, l._STEP_1, 'should be back in step 1 to traverse to "array not empty case"');
	t.equal(arrow_del_called, 2, 'de-allocated both the move pointer and the tail pointer for the old array');
	t.equal(array_del_called, 1, 'de-allocated the old array');
	t.ok(check.undefined(l._array_tmp));
	t.ok(check.undefined(l._arrow_tmp));
	t.ok(check.undefined(l._move_pointer));
	t.deepEqual(ui.array.working, new_array, 'the new array should be saved on the UI as the new current work array');
	t.deepEqual(ui.arrow.working, new_tail_arrow, '...and its tail arrow should be saved on the UI similarly');
});

test('[lesson] correct, integration testing, insert into array to fill it (size 2), then insert another value to create new array (size 4) and insert into it', function (t) {
	//SETUP
	var mock_UI = require('lib/test/mock_UI');
	var ui = mock_UI();
	
	//start the working array at size 2, with no items stored
	ui.array.working.size = 2;
	
	//setup the lesson
	var l = lesson({UI: ui});
	
	//TEST - pre-insert
	t.equal(l._state, l._READY);
	t.equal(ui.array.working.length, 0, 'working array should be empty');
	t.equal(ui.arrow.working.index, 0, 'tail on working array should be at 0th index');
	t.ok(check.undefined(l._step_state), 'should not be stepping through a lesson yet');
	
	//SETUP
	//mock input.get() function to return values
	var input = -1;
	ui.input.get = function() {
		input += 1;
		return input;
	};
	
	//mock output.set() to track message
	var output_set_called = 0;
	ui.output.set = function() {
		output_set_called += 1;
	};
	
	//PRESS - pre_start
	var result = l.pre_start();
	
	//TEST - post first press
	t.equal(l._state, l._RUN);
	t.equal(ui.array.working.length, 1, 'working array should have first item copied in');
	t.equal(ui.arrow.working.index, 0, 'tail pointer should be at 0th position, until we increment on next step');
	t.equal(l._step_state, l._STEP_2);
	t.notOk(result.done, 'should not be done yet');
	t.ok(result.value.match(/Added the value/));
	t.equal(output_set_called, 1);
	
	//PRESS - next
	
	result = l.next();
	
	//TEST
	t.equal(l._state, l._READY);
	t.equal(ui.array.working.length, 1, 'working array should have first item copied in');
	t.equal(ui.arrow.working.index, 1, 'working tail pointer at index 1');
	t.ok(check.undefined(l._step_state));
	t.ok(result.done);
	t.ok(result.value.match(/prepare for the next insertion/));
	t.equal(output_set_called, 2);
	
	//PRESS - insert another value
	l.pre_start();
	l.next();
	
	//TEST
	t.equal(l._state, l._READY);
	t.equal(ui.array.working.length, 2, 'working array should see both items');
	t.equal(ui.arrow.working.index, 2, 'working tail pointer at index 2');
	t.ok(check.undefined(l._step_state));
	t.ok(result.done);
	t.ok(result.value.match(/prepare for the next insertion/));
	t.equal(output_set_called, 4);
	
	//PRESS - insert another value, _array_full === true
	result = l.pre_start();
	
	//TEST
	t.ok(l._array_full, 'should see array full case detected')
	t.equal(l._state, l._RUN);
	t.equal(ui.array.working.length, 2, 'working array should see both items');
	t.equal(ui.arrow.working.index, 2, 'working tail pointer at index 2');
	t.equal(l._step_state, l._STEP_2);
	t.notOk(result.done);
	t.ok(result.value.match(/Array is full/), 'array is full message');
	t.equal(output_set_called, 5);
	//NOTE: the array allocated does NOT detect as an object in the mock_UI
	t.ok(check.array(l._array_tmp), 'should have a new array allocated');
	t.equal(l._array_tmp.length, 0, 'with nothing in it');
	t.equal(l._array_tmp.size, 4, 'but whose size is twice that of the old array');
	t.ok(check.object(l._arrow_tmp), 'and a new arrow for the new array');
	t.equal(l._arrow_tmp.index, 0, 'positioned at the start of the new array');
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_MOVING);
	t.notOk(result.done);
	t.ok(result.value.match(/move pointer/), 'move pointer message');
	t.equal(output_set_called, 6);
	t.ok(check.object(l._move_pointer), 'should see the move pointer');
	t.equal(l._move_pointer.index, 0, 'starts at the beginning of the old array');
	t.deepEqual(l._move_pointer.array, ui.array.working, 'the move pointer should be pointing at the old array');
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_MOVING);
	t.notOk(result.done);
	t.ok(result.value.match(/Moved value/), 'moved a value');
	t.equal(output_set_called, 7);
	
	t.equal(l._array_tmp.length, 1, 'first moved value');
	t.equal(l._arrow_tmp.index, 1, 'moved its tail pointer');
	
	t.equal(l._move_pointer.index, 1, 'move pointer ready to copy second value');
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_MOVING);
	
	t.notOk(result.done);
	t.ok(result.value.match(/Moved value/), 'moved a value');
	t.equal(output_set_called, 8);
	
	t.equal(l._array_tmp.length, 2, 'both values moved');
	t.equal(l._arrow_tmp.index, 2, 'moved its tail pointer');
	
	t.equal(l._move_pointer.index, 2, 'move pointer now at the end of the old array');
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_3);
	
	t.notOk(result.done);
	t.ok(result.value.match(/we\'ve finished moving the values/), 'finished moving');
	t.equal(output_set_called, 9);
	
	t.equal(l._array_tmp.length, 2, 'both values moved');
	t.equal(l._arrow_tmp.index, 2);
	
	t.equal(l._move_pointer.index, 2, 'move pointer now at the end of the old array');
	
	//SETUP
	var old_array = ui.array.working;
	var old_arrow = ui.arrow.working;
	var new_array = l._array_tmp;
	var new_arrow = l._arrow_tmp;
	
	//PRESS - next
	result = l.next();
	
	//TEST
	t.equal(l._state, l._RUN);
	t.equal(l._step_state, l._STEP_1);
	
	t.notOk(result.done);
	t.ok(result.value.match(/Removing the old array and the move pointer/), 'cleaning up');
	t.equal(output_set_called, 10);
	
	t.notOk(l._array_full);
	t.ok(check.undefined(l._array_tmp));
	t.ok(check.undefined(l._arrow_tmp));
	t.ok(check.undefined(l._move_pointer));
	
	t.deepEqual(ui.array.working, new_array, 'the new array is now saved on the ui for work going forward');
	t.deepEqual(ui.arrow.working, new_arrow, 'and so is its arrow');
	
	//PRESS - move final value from input to the newly allocated array
	l.next();
	l.next();
	
	//TEST
	t.equal(l._state, l._READY, 'should be ready to insert another value');
	t.ok(check.undefined(l._step_state), 'should not be stepping through a lesson');
	t.equal(ui.array.working.length, 3, 'should have 3 values in the new array');
	t.equal(ui.arrow.working.index, 3, 'tail pointer should be one past the last value');
	
	t.end();
});