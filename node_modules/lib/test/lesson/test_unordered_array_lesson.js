var lesson = require('lib/lesson/unordered_array_lesson');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	function mock() {
		var ret = {
			input : {
				get : function() {},
			//	set : this._text_input._.set,
				clear : function() {},
				get_canvas_element : function() {},
			},
			output : {
				//get : this._text_output._.get,
				set : function() {},
				//clear : this._text_output._.clear,
			},
			insert_button : new createjs.Shape(),
			next_button : new createjs.Shape(),
			array : {
				working : undefined,
			},
			arrow : {
				working : {
					_ : {
						name : "test",
						pointed_at : undefined,
						next : function() {},
						move : function() {},
					}
				},
			},
			//pub_sub : pub_sub,
		};
		
		ret.array.working = new createjs.Container();
		ret.array.working._ = {
			length : undefined,
			values : [],
			push : function () {},
		};
		ret.arrow.working._.pointed_at = new createjs.Shape();
		ret.arrow.working._.pointed_at._ = {
			index : undefined,
		};
		
		return ret;
	};
	
	function real() {
		var lesson_UI = require('lib/UI/lesson_UI');
		var UI = lesson_UI();
		UI.next();	//get the testing lesson_UI into the LESSON state, so that get_proxy() works
		return UI.get_proxy();
	}
	
	return {
		mock : mock,
		real : real,
	}
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	var stage = primitives.get('stage');
	
	//reset the stage
	stage.clear();
	stage.removeAllChildren();
	
	//delete the text input created by lesson_UI
	var div = document.getElementById('canvas_container');
	//	find the input control
	var input_index;
	for (var i = 0; i < div.children.length; i++) {
		if (div.children[i].type === "text") {
			//don't delete inside the array while iterating over it
			input_index = i;
		}
	};
	//if there was a text input, then delete it
	if (input_index) {
		div.removeChild(div.children[input_index]);
	}
};

TEARDOWN();

test('[lesson] incorrect, no arguments', function (t) {
	t.plan(4);
	
	try {
		lesson();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

test('[lesson] incorrect, bad argument', function (t) {
	t.plan(4);
	
	try {
		lesson("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

test('[lesson] incorrect, UI argument wrong type', function (t) {
	t.plan(4);
	
	try {
		lesson({UI: "some bad argument"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/UI/), 'what argument caused the problem');
		t.ok(message.match(/object/), 'tells you what type needed');
		t.ok(message.match(/argument should be object/), 'tells you about how to pass arguments');
	}
});

//NOTE: when interacting with the real UI, be sure to add a test that verifies the UI is done tweening before moving on to a new test
//	move() will cause some tests to fail, as it does not execute a tween if there is already an existing tween running
//something like this:
/* setTimeout(function() {
	var move = require('lib/util/move');
	t.notOk(move.is_moving(), "finished tween");
	
	TEARDOWN();
}, 1500); */

test('[lesson] correct, (real)', function (t) {
	//SETUP
	var ui = SETUP().real();
	var stage_add_called = false;
	ui.stage.add = function() {
		stage_add_called = true;
	};
	
	//PRE-TEST
	t.notOk(ui.next_button.hasEventListener("click"), "no event handlers on the 'next' button yet");
	
	//SETUP
	var l = lesson({UI: ui});
	
	//TEST
	t.ok(check.object(l._array), "setup the array");
	t.ok(check.object(l._tail_arrow), "populated the arrow reference, from setting up the array");
	t.ok(stage_add_called, "added the array to the stage");
	t.ok(ui.next_button.hasEventListener("click"), "added the event handler to the 'next' button");
	
	TEARDOWN();
	t.end();
});
	
test('[lesson] correct, next button, click event handler, READY state (real)', function (t) {
	t.plan(1);
	
	//SETUP
	var ui = SETUP().real();
	
	var pre_start_backup = lesson.prototype.pre_start;
	lesson.prototype.pre_start = function() {
		//TEST
		t.ok(true, "saw click event from 'next' button");
		
		//CLEANUP
		lesson.prototype.pre_start = pre_start_backup;
		TEARDOWN();
	}
	
	var l = lesson({UI: ui});
	ui.next_button.dispatchEvent(new Event("click"));
});

test('[lesson] correct, next button, click event handler, RUN state (real)', function (t) {
	t.plan(1);
	
	//SETUP
	var ui = SETUP().real();
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var next_backup = lesson.prototype.next;
	lesson.prototype.next = function() {
		//TEST
		t.ok(true, "saw click event from 'next' button");
		
		//CLEANUP
		lesson.prototype.next = next_backup;
		TEARDOWN();
	}
	
	var l = lesson({UI: ui});
	l._state = l._RUN;
	ui.next_button.dispatchEvent(new Event("click"));
});

test('[lesson] correct, next button event handler (real), does nothing when tweening', function (t) {
	t.plan(5);
	
	//SETUP
	var ui = SETUP().real();
	
	//setup mock function on lesson prototype for event handler to call, BEFORE allocating object
	var next_backup = lesson.prototype.next;
	lesson.prototype.next = function() {
		//TEST
		t.ok(true, "saw click event from 'next' button");
	}
	
	var l = lesson({UI: ui});
	l._state = l._RUN;
	
	//in live code may start a tween
	//any other clicks (simulated below) should be ignored until the tween is complete
	ui.next_button.dispatchEvent(new Event("click"));
	
	//setup a tween
	var move = require('lib/util/move');
	var source = {x:0, y:0};
	var source_mover = move(source);
	var destination = {x:100, y:100};
	source_mover.to(destination);	//default tween time ~1 sec
	
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(source.x > 0 && source.x < 100, 'value should be on the way to 100, but not equal');
		t.ok(source.y > 0 && source.y < 100, 'value should be on the way to 100, but not equal');
		
		ui.next_button.dispatchEvent(new Event("click"));	//should do nothing
	}, 500);
	
	setTimeout(function() {
		//CLEANUP
		lesson.prototype.next = next_backup;
		TEARDOWN();
		t.ok(true, "finished tween");
	}, 1500);
});

test('[lesson._setup_array] correct', function (t) {
	//SETUP
	var ui = SETUP().real();
	
	//TEST
	var result = lesson.prototype._setup_array();
	
	t.ok(check.object(result), 'made a new array object');
	t.ok(check.object(result._.arrow), 'made a new arrow object');
	t.ok(check.not.undefined(result.x), 'defined the x');
	t.ok(check.not.undefined(result.y), 'and the y');
	
	TEARDOWN();
	t.end();
});

test('[lesson.pre_start] correct, not in correct state (real)', function (t) {
	t.plan(1);
	
	//SETUP
	var ui = SETUP().real();
	
	var get_called = false;
	ui.input.get = function() {
		get_called = true;
	}
	
	var l = lesson({UI: ui});
	
	l._state = -1;	//setup invalid state
	
	l.pre_start();
	
	//TEST
	t.notOk(get_called, 'input has not been pulled from the UI');
	
	TEARDOWN();
});

test('[lesson.pre_start] correct, correct state & bad input (real)', function (t) {
	//SETUP
	var ui = SETUP().real();
	
	//put in some bad input into the text input
	ui.input.set("some bad input");
	
	var l = lesson({UI: ui});
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	//text output should be set to an error
	var output = ui.output.get();
	
	//TEST
	t.ok(output.match(/not a number/), 'shows what was wrong');
	t.ok(output.match(/Please enter a number/), 'tells you what to enter');
	t.ok(output.match(/the 'Next' button/), '...and what to do');
	
	TEARDOWN();
	
	t.end();
});

test('[lesson.pre_start] correct, working array full case detected (real)', function (t) {
	//SETUP
	var ui = SETUP().real();	
	
	//create an input to attempt to insert
	ui.input.set("0");
	
	var next_backup = lesson.prototype.next;
	lesson.prototype.next = function() {};
	
	//TEST
	var l = lesson({UI: ui});
	l._array._.values = [0, 0];	//create a full array to detect
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	t.ok(l._array_full, 'saw that the array was full');
	
	//CLEANUP
	lesson.prototype.next = next_backup;
	TEARDOWN();
	t.end();
});

test('[lesson.pre_start] correct, working array NOT full case detected (real)', function (t) {
	//SETUP
	var ui = SETUP().real();
	
	//create an input to attempt to insert
	ui.input.set("0");
	
	var next_backup = lesson.prototype.next;
	lesson.prototype.next = function() {};
	
	//TEST
	var l = lesson({UI: ui});
	//default array is empty
	l._state = l._READY;	//setup correct state
	l.pre_start();
	
	t.notOk(l._array_full, 'saw that the array was NOT full');
	
	//CLEANUP
	lesson.prototype.next = next_backup;
	TEARDOWN();
	t.end();
});

test('[lesson.pre_start] correct, case: array not full, call 1 (real)', function (t) {
	t.plan(14);
	
	//SETUP
	var ui = SETUP().real();
	
	//set a valid value in the UI to add to the array
	ui.input.set("0");
	
	var l = lesson({UI: ui});
	
	//PRE-TEST
	t.equal(l._array._.values.length, 0, "values array is empty");
	t.equal(l._array.children[0].children.length, 1, "array's first child has one child");
	
	//EXECUTE
	
	l._state = l._READY;	//setup correct state
	var result = l.pre_start();
	
	//TEST
	//input is empty
	//	checking through the API
	t.ok(Number.isNaN(ui.input.get()), "input is empty");
	
	//	...and by inspecting the DOM element
	var div = document.getElementById('canvas_container');
	for (var i = 0; i < div.children.length; i++) {
		if (div.children[i].type === "text") {
			t.equal(div.children[i].value, "", "input is empty");
		}
	};
	
	t.equal(l._array._.values.length, 1, "values array now has a single element");
	t.equal(l._array.children[0].children.length, 2, "array's first child now has two children");
	
	t.equal(l._state, l._RUN, 'still in the running state');
	t.equal(l._step_state, l._STEP_2, 'but now in the second step of the lesson')
	t.ok(check.object(result));
	t.notOk(result.done, 'not finished yet');
	t.ok(result.value.match(/Added the value/));
	t.ok(result.value.match(/to the array/));
	
	//text input has been disabled
	t.ok(ui.input.self._.htmlElement.disabled);
	
	setTimeout(function() {
		//CLEANUP
		var move = require('lib/util/move');
		t.notOk(move.is_moving(), "finished tween");
		
		TEARDOWN();
	}, 1500);
});

test('[lesson.next] correct, case: array not full, call 2 (real)', function (t) {
	t.plan(8);
	
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//PRESS 1
	//single item in the values array
	l._array._.values.push(0);
	//two items in the first child of the UI array
	l._array.addChild(new createjs.Container());
	l._array.children[0].addChild(new createjs.Shape());
	l._array.children[0].addChild(new createjs.Shape());
	//input is blank
	ui.input.clear();
	
	l._state = l._RUN;			//setup correct state, running the lesson
	l._step_state = l._STEP_2;	//setup correct step state
	
	//PRESS 2
	result = l.next();
	
	//TEST
	t.ok(result.done, 'finished');
	t.equal(l._step_state, undefined, 'reset step state')
	t.equal(l._state, l._READY, 'in the ready state');
	t.ok(result.value.match(/Moved the \'tail\' pointer/));
	t.ok(result.value.match(/to prepare for the next insertion/));
	t.equal(l._tail_arrow._.index, 1, 'incremented the index for the arrow');
	
	//text input has been re-enabled
	t.notOk(ui.input.self._.htmlElement.disabled);
	
	setTimeout(function() {
		var move = require('lib/util/move');
		t.notOk(move.is_moving(), "finished tween");
		
		TEARDOWN();
	}, 1500);
});

test('[lesson.next] correct, case: array not full, call 2 (adding this fills up the array) (real)', function (t) {
	t.plan(8);
	
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//PRESS 1
	//single item in the values array
	l._array._.values.push(0);
	l._array._.length = 1;
	//two items in the first child of the UI array
	l._array.addChild(new createjs.Container());
	l._array.children[0].addChild(new createjs.Shape());
	l._array.children[0].addChild(new createjs.Shape());
	//input is blank
	ui.input.clear();
	
	
	l._state = l._RUN;			//setup correct state, running the lesson
	l._step_state = l._STEP_2;	//setup correct step state
	
	//PRESS 2
	result = l.next();
	
	//TEST
	t.ok(result.done, 'finished');
	t.equal(l._step_state, undefined, 'reset step state')
	t.equal(l._state, l._READY, 'in the ready state');
	t.ok(result.value.match(/the end of the array/));
	t.ok(result.value.match(/there are no/));
	t.ok(result.value.match(/other indices to insert values into/));
	t.equal(l._tail_arrow._.index, 1, 'incremented the index for the arrow');
	
	setTimeout(function() {
		var move = require('lib/util/move');
		t.notOk(move.is_moving(), "finished tween");
		
		TEARDOWN();
	}, 1500);
});

test('[lesson.pre_start] correct, case: array full, call 1 (real)', function (t) {
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 1
	l._tail_arrow._.pointed_at = l._array.children[1];
	l._tail_arrow.x += 50;
	
	//insert a value into the input
	ui.input.set("2");
	
	//EXEC
	
	l._state = l._READY;	//setup correct state
	var result = l.pre_start();
	
	//TEST
	t.equal(l._state, l._RUN, 'in the running state');
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Array is full/));
	t.ok(result.value.match(/Allocating new array/));
	t.equal(l._step_state, l._STEP_2, 'now in the second step of the lesson');
	t.ok(check.object(l._array_tmp), 'got a new array');
	t.equal(l._array_tmp.x, l._array.x, 'positioned the new array below the old one');
	t.ok(l._array_tmp.y > l._array.y, 'positioned the new array below the old one');
	t.ok(check.object(l._arrow_tmp), 'got a new arrow');
	t.ok(l._allocated_array, "flagged that we setup a new array");
	
	TEARDOWN();
	
	t.end();
});

test('[lesson.pre_start] correct, case: array full, call 1 (real), previously allocated an array', function (t) {
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 1
	l._tail_arrow._.pointed_at = l._array.children[1];
	l._tail_arrow.x += 50;
	
	//insert a value into the input
	ui.input.set("2");
	
	//EXEC
	l._state = l._READY;	//setup correct state
	l._allocated_array = true;
	var result = l.pre_start();
	
	//TEST
	t.equal(l._state, l._DONE, 'lesson is finished');
	t.ok(result.done, 'lesson is finished');
	
	var output = ui.output.get();
	t.ok(output.match(/Lesson finished/));
	t.ok(output.match(/the lesson cannot allocate/));
	t.ok(check.undefined(l._step_state), 'step state is undefined');
	
	TEARDOWN();
	
	t.end();
});

test('[lesson.next] correct, case: array full, call 2 (real)', function (t) {
	t.plan(6);
	
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 1
	l._tail_arrow._.pointed_at = l._array.children[1];
	l._tail_arrow.x += 50;
	
	//END INIT
	
	//CALL 1
	//flag that the array is full
	l._array_full = true;
	
	//setup correct state
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	
	var array_UI = require('lib/UI/array_UI');
	var result = array_UI({length:4});
	l._array_tmp = result;
	l._arrow_tmp = result._.arrow;
	
	l._array_tmp.x = l._array.x;
	l._array_tmp.y = l._array.y + 115;
	
	ui.stage.add(l._array_tmp);
	
	//END CALL 1
	
	//EXEC
	var result = l.next();
	
	//TEST
	t.ok(check.object(l._move_pointer), 'setup the move pointer');
	t.equal(l._state, l._RUN, 'in the running state');
	t.notOk(result.done, 'not finished');
	t.equal(l._step_state, l._STEP_MOVING_1, 'third step on next()');
	t.ok(result.value.match(/move pointer/));
	
	setTimeout(function() {
		var move = require('lib/util/move');
		t.notOk(move.is_moving(), "finished tween");
		
		TEARDOWN();
	}, 1500);
});

test('[lesson.next] correct, case: array full, call 3 - moving 1 (real)', function (t) {
	t.plan(10);
	
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 2, beyond the end of the array
	l._tail_arrow._.pointed_at = undefined;
	l._tail_arrow.x += 50;
	l._tail_arrow.x += 50;
	l._tail_arrow._.index = 2;
	//END INIT
	
	//CALL 1
	//flag that the array is full
	l._array_full = true;
	
	//setup correct state
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	
	var array_UI = require('lib/UI/array_UI');
	var result = array_UI({length:4});
	l._array_tmp = result;
	l._arrow_tmp = result._.arrow;
	
	l._array_tmp.x = l._array.x;
	l._array_tmp.y = l._array.y + 115;
	
	ui.stage.add(l._array_tmp);
	//END CALL 1
	
	//CALL 2
	l._move_pointer = l._array._.iterator("move");
	l._step_state = l._STEP_MOVING_1;
	//END CALL 2
	
	//PRE-TEST
	t.equal(l._array_tmp.children[0].children.length, 1, "first index in the new array, has only a single child");
	t.equal(l._array.children[0].children.length, 2, "first index in the old array has two children");
	t.equal(l._array.children[0].children[1].text, "0", "the first value in the old array is 0, before the move");
	
	//EXEC
	var result = l.next();
	
	//TEST
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Moved value/));
	t.equal(l._array_tmp.children[0].children.length, 2, "first index in the new array, now has two children");
	t.equal(l._array_tmp.children[0].children[1].text, "0", "and the first value from the old array is now in the first index of the new array");
	t.equal(l._array.children[0].children.length, 1, "first index in the old array now has only 1 child");
	t.equal(l._step_state, l._STEP_MOVING_2, "should be in the second moving sub-step of the moving step");
	
	setTimeout(function() {
		var move = require('lib/util/move');
		t.notOk(move.is_moving(), "finished tween");
		
		TEARDOWN();
	}, 1500);
});

test('[lesson.next] correct, case: array full, call 4 - moving 2 (real)', function (t) {
	t.plan(5);
	
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 2, beyond the end of the array
	l._tail_arrow._.pointed_at = undefined;
	l._tail_arrow.x += 50;
	l._tail_arrow.x += 50;
	l._tail_arrow._.index = 2;
	//END INIT
	
	//CALL 1
	
	//flag that the array is full
	l._array_full = true;
	
	//setup correct state
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	
	var array_UI = require('lib/UI/array_UI');
	var result = array_UI({length:4});
	l._array_tmp = result;
	l._arrow_tmp = result._.arrow;
	
	l._array_tmp.x = l._array.x;
	l._array_tmp.y = l._array.y + 115;
	
	ui.stage.add(l._array_tmp);
	//END CALL 1
	
	//CALL 2
	l._move_pointer = l._array._.iterator("move");
	l._step_state = l._STEP_MOVING_1;
	//END CALL 2
	
	//CALL 3
	l._array.children[0].removeChildAt(1);	//remove the 0 from the old array
	l._array_tmp.children[0].addChild(new createjs.Text("0"));	//and add 0 to the new array
	l._step_state = l._STEP_MOVING_2;
	//END CALL 3
	
	//EXEC
	var result = l.next();
	
	//TEST
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Incremented the move pointer/), "saw that we moved the move pointer");
	t.equal(l._move_pointer._.index, 1, "move pointer should now be at index 1");
	t.equal(l._step_state, l._STEP_MOVING_3, "third moving sub-step of the moving step");
	
	setTimeout(function() {
		var move = require('lib/util/move');
		t.notOk(move.is_moving(), "finished tween");
		
		TEARDOWN();
	}, 1500);
});

test('[lesson.next] correct, case: array full, call 5 - moving 3 (real)', function (t) {
	t.plan(5);
	
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 2, beyond the end of the array
	l._tail_arrow._.pointed_at = undefined;
	l._tail_arrow.x += 50;
	l._tail_arrow.x += 50;
	l._tail_arrow._.index = 2;
	//END INIT
	
	//CALL 1	
	//flag that the array is full
	l._array_full = true;
	
	//setup correct state
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	
	var array_UI = require('lib/UI/array_UI');
	var result = array_UI({length:4});
	l._array_tmp = result;
	l._arrow_tmp = result._.arrow;
	
	l._array_tmp.x = l._array.x;
	l._array_tmp.y = l._array.y + 115;
	
	ui.stage.add(l._array_tmp);
	//END CALL 1
	
	//CALL 2
	l._move_pointer = l._array._.iterator("move");
	l._step_state = l._STEP_MOVING_1;
	//END CALL 2
	
	//CALL 3
	l._array.children[0].removeChildAt(1);	//remove the 0 from the old array
	l._array_tmp.children[0].addChild(new createjs.Text("0"));	//and add 0 to the new array
	l._step_state = l._STEP_MOVING_2;
	//END CALL 3
	
	//CALL 4
	//move pointer pointed at the second child of the old array
	l._move_pointer._.pointed_at = l._array.children[1];
	l._move_pointer.x += 50;
	l._move_pointer._.index = 1;
	l._step_state = l._STEP_MOVING_3;
	//END CALL 4
	
	//EXEC
	var result = l.next();
	
	//TEST
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Incremented the tail pointer/), "moved the tail pointer");
	t.equal(l._arrow_tmp._.index, 1, "tail pointer in the new array, now at index 1");
	t.equal(l._step_state, l._STEP_MOVING_4, "checking for exit condition");
	
	setTimeout(function() {
		var move = require('lib/util/move');
		t.notOk(move.is_moving(), "finished tween");
		
		TEARDOWN();
	}, 1500);
});

test('[lesson.next] correct, case: array full, call 6 - moving 4 (real) (NOT exiting from move)', function (t) {
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 2, beyond the end of the array
	l._tail_arrow._.pointed_at = undefined;
	l._tail_arrow.x += 50;
	l._tail_arrow.x += 50;
	l._tail_arrow._.index = 2;
	//END INIT
	
	//CALL 1	
	//flag that the array is full
	l._array_full = true;
	
	//setup correct state
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	
	var array_UI = require('lib/UI/array_UI');
	var result = array_UI({length:4});
	l._array_tmp = result;
	l._arrow_tmp = result._.arrow;
	
	l._array_tmp.x = l._array.x;
	l._array_tmp.y = l._array.y + 115;
	
	ui.stage.add(l._array_tmp);
	//END CALL 1
	
	//CALL 2
	l._move_pointer = l._array._.iterator("move");
	l._step_state = l._STEP_MOVING_1;
	//END CALL 2
	
	//CALL 3
	l._array.children[0].removeChildAt(1);	//remove the 0 from the old array
	l._array_tmp.children[0].addChild(new createjs.Text("0"));	//and add 0 to the new array
	l._step_state = l._STEP_MOVING_2;
	//END CALL 3
	
	//CALL 4
	//move pointer pointed at the second child of the old array
	l._move_pointer._.pointed_at = l._array.children[1];
	l._move_pointer.x += 50;
	l._move_pointer._.index = 1;
	l._step_state = l._STEP_MOVING_3;
	//END CALL 4
	
	//CALL 5
	//increment the tail pointer on the new array to index 1
	l._arrow_tmp.x += 50;
	l._arrow_tmp._.index = 1;
	l._arrow_tmp._.pointed_at = l._array_tmp.children[1];
	l._step_state = l._STEP_MOVING_4;
	//END CALL 5
	
	//EXEC
	var result = l.next();
	
	//TEST
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/the 'move' pointer is not at/));
	t.ok(result.value.match(/the same index as the 'tail'/));
	t.ok(result.value.match(/we need to move at least/));
	t.ok(result.value.match(/one more value from the old array/));
	t.equal(l._step_state, l._STEP_MOVING_1, "checking for exit condition");
	
	TEARDOWN();
	t.end();
});

test('[lesson.next] correct, case: array full, call 6 - moving 4 (real), exiting from move', function (t) {
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 2, beyond the end of the array
	l._tail_arrow._.pointed_at = undefined;
	l._tail_arrow.x += 50;
	l._tail_arrow.x += 50;
	l._tail_arrow._.index = 2;
	//END INIT
	
	//CALL 1	
	//flag that the array is full
	l._array_full = true;
	
	//setup correct state
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	
	var array_UI = require('lib/UI/array_UI');
	var result = array_UI({length:4});
	l._array_tmp = result;
	l._arrow_tmp = result._.arrow;
	
	l._array_tmp.x = l._array.x;
	l._array_tmp.y = l._array.y + 115;
	
	ui.stage.add(l._array_tmp);
	//END CALL 1
	
	//CALL 2
	l._move_pointer = l._array._.iterator("move");
	l._step_state = l._STEP_MOVING_1;
	//END CALL 2
	
	//CALL 3
	l._array.children[0].removeChildAt(1);	//remove the 0 from the old array
	l._array.children[1].removeChildAt(1);	//remove the 1 from the old array
	l._array_tmp.children[0].addChild(new createjs.Text("0"));	//and add 0 to the new array
	l._array_tmp.children[1].addChild(new createjs.Text("1"));	//and add 1 to the new array
	l._step_state = l._STEP_MOVING_2;
	//END CALL 3
	
	//CALL 4
	//move the move pointer in the old array past the end of the array, it's traversed the entire array
	l._move_pointer._.pointed_at = undefined;
	l._move_pointer.x += 50;
	l._move_pointer.x += 50;
	l._move_pointer._.index = 2;
	l._step_state = l._STEP_MOVING_3;
	//END CALL 4
	
	//CALL 5
	//increment the tail pointer on the new array to index 2, the position it should be in after inserting two values from the old array
	l._arrow_tmp.x += 50;
	l._arrow_tmp.x += 50;
	l._arrow_tmp._.index = 2;
	l._arrow_tmp._.pointed_at = l._array_tmp.children[2];
	l._step_state = l._STEP_MOVING_4;
	//END CALL 5
	
	//EXEC
	var result = l.next();
	
	//TEST
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/The 'move' pointer is at the same/));
	t.ok(result.value.match(/index as the 'tail' pointer/));
	t.ok(result.value.match(/we've finished moving/));
	t.equal(l._step_state, l._STEP_3, "back at the first moving sub-step, to move the next value");
	
	TEARDOWN();
	t.end();
});

test('[lesson.next] correct, case: array full, call 7 - step 3 (real)', function (t) {
	t.plan(10);
	
	//SETUP
	var ui = SETUP().real();
	var l = lesson({UI: ui});
	
	//INIT
	//fill the array
	l._array._.values = [0, 1];
	l._array.children[0].addChild(new createjs.Text("0"));
	l._array.children[1].addChild(new createjs.Text("1"));
	
	//point the tail arrow (old array) at index 2, beyond the end of the array
	l._tail_arrow._.pointed_at = undefined;
	l._tail_arrow.x += 50;
	l._tail_arrow.x += 50;
	l._tail_arrow._.index = 2;
	//END INIT
	
	//CALL 1	
	//flag that the array is full
	l._array_full = true;
	
	//setup correct state
	l._state = l._RUN;
	l._step_state = l._STEP_2;
	
	var array_UI = require('lib/UI/array_UI');
	var result = array_UI({length:4});
	l._array_tmp = result;
	l._arrow_tmp = result._.arrow;
	
	l._array_tmp.x = l._array.x;
	l._array_tmp.y = l._array.y + 115;
	
	ui.stage.add(l._array_tmp);
	//END CALL 1
	
	//CALL 2
	l._move_pointer = l._array._.iterator("move");
	l._step_state = l._STEP_MOVING_1;
	//END CALL 2
	
	//CALL 3
	l._array.children[0].removeChildAt(1);	//remove the 0 from the old array
	l._array.children[1].removeChildAt(1);	//remove the 1 from the old array
	l._array_tmp.children[0].addChild(new createjs.Text("0"));	//and add 0 to the new array
	l._array_tmp.children[1].addChild(new createjs.Text("1"));	//and add 1 to the new array
	l._step_state = l._STEP_MOVING_2;
	//END CALL 3
	
	//CALL 4
	//move the move pointer in the old array past the end of the array, it's traversed the entire array
	l._move_pointer._.pointed_at = undefined;
	l._move_pointer.x += 50;
	l._move_pointer.x += 50;
	l._move_pointer._.index = 2;
	l._step_state = l._STEP_MOVING_3;
	//END CALL 4
	
	//CALL 5
	//increment the tail pointer on the new array to index 2, the position it should be in after inserting two values from the old array
	l._arrow_tmp.x += 50;
	l._arrow_tmp.x += 50;
	l._arrow_tmp._.index = 2;
	l._arrow_tmp._.pointed_at = l._array_tmp.children[2];
	l._step_state = l._STEP_MOVING_4;
	//END CALL 5
	
	//CALL 6
	l._step_state = l._STEP_3;
	//END CALL 6
	
	//EXEC
	
	//PRE-TEST
	//record a reference to the old array, the move pointer and the new array, to verify changes have been made to the proxy variable post-next()
	var old_array = l._array;
	var move_pointer = l._move_pointer;
	var new_array = l._array_tmp;
	
	t.ok(check.object(old_array));
	t.ok(check.object(move_pointer));
	t.ok(check.object(new_array));
	
	var result = l.next();
	
	//TEST
	t.deepEqual(l._array, new_array, "post next() the new array should be the default working array, as the old one had been removed");
	t.ok(check.undefined(l._move_pointer), "the move pointer has been removed");
	t.notOk(l._array_full, "since the new array has space to insert, it's been flagged in the lesson");
	
	t.notOk(result.done, 'not finished');
	t.ok(result.value.match(/Removing the old array/));
	t.equal(l._step_state, l._STEP_1, "back to step one, to move value from the input to it's new position at index 2 in the array");
	
	setTimeout(function() {
		var move = require('lib/util/move');
		t.notOk(move.is_moving(), "finished tween");
		
		TEARDOWN();
		t.end();
	}, 1500);
});

test('[lesson] correct, integration testing, insert into array to fill it (size 2), then insert another value to create new array (size 4) and insert into it', function (t) {
	//SETUP
	var lesson_UI = require('lib/UI/lesson_UI');
	var UI = lesson_UI({lesson:lesson});
	UI.next();
	var ui = UI.get_proxy();
	
	//get a reference to the lesson that the UI creates, so we can examine its state during the calls below
	var l = UI._lesson_instance;
	
	//DEBUG
	//console.log(l);
	
	var command_queue = [];
	
	//NOTE: something odd when examining the state of the lesson (l._step_state or l._state)
	//when executing we can examine the UI and see that the states have advanced to allow for the behavior of inserting a number or updating the array
	//	but when examined directly, they appear to be as if the lesson had never left the constructor?
	//		e.g. after inserting a number into the input & pressing "insert", during the testing phase l._step_state is undefined and l._state is READY
	//		(as if the insert button were not pressed at all?)
	//for now avoiding testing the state directly and just verifying the UI has made the changes one would expect
	
	function call_1() {
		//DEBUG
		console.log("call 1 - inputing 0 into the array");
		//set an input in the HTML
		
		var div = document.getElementById('canvas_container');
		for (var i = 0; i < div.children.length; i++) {
			if (div.children[i].type === "text") {
				div.children[i].value = "0";
			}
		};
		
		//press the next button
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		t.ok(Number.isNaN(ui.input.get()), "input is empty");
		t.equal(l._array._.values.length, 1, "values array now has a single element");
		
		var result = ui.output.get();
		t.ok(result.match(/Added the value/));
		t.ok(result.match(/to the array/));
	};
	command_queue.push(call_1);
	
	function call_2() {
		//DEBUG
		console.log("call 2 - advancing the 'tail' pointer");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		t.ok(result.match(/Moved the \'tail\' pointer/));
		t.ok(result.match(/to prepare for the next insertion/));
		t.equal(l._tail_arrow._.index, 1, 'incremented the index for the arrow');
	};
	command_queue.push(call_2);
	
	function call_3() {
		//DEBUG
		console.log("call 3 - inserting a 1");
		
		//set an input in the HTML
		var div = document.getElementById('canvas_container');
		for (var i = 0; i < div.children.length; i++) {
			if (div.children[i].type === "text") {
				div.children[i].value = "1";
			}
		};
		
		//press the next button
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		t.ok(Number.isNaN(ui.input.get()), "input is empty");
		t.equal(l._array._.values.length, 2, "now two elements in the array");
		
		var result = ui.output.get();
		t.ok(result.match(/Added the value/));
		t.ok(result.match(/to the array/));
	};
	command_queue.push(call_3);
	
	function call_4() {
		//DEBUG
		console.log("call 4 - incrementing the tail pointer (beyond the end of the arry)");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		t.ok(result.match(/Moved the 'tail' pointer to/));
		t.ok(result.match(/the end of the array/));
		t.ok(result.match(/there are no/));
		t.ok(result.match(/other indices to insert values into/));
		t.equal(l._tail_arrow._.index, 2, 'incremented the index for the arrow');
	};
	command_queue.push(call_4);
	
	function call_5() {
		//DEBUG
		console.log("call 5 - attempting to insert 2, allocating new array");
		//DEBUG
		
		//set an input in the HTML
		var div = document.getElementById('canvas_container');
		for (var i = 0; i < div.children.length; i++) {
			if (div.children[i].type === "text") {
				div.children[i].value = "2";
			}
		};
		
		//press the next button
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		t.ok(result.match(/Array is full/));
		t.ok(result.match(/Allocating new array/));
		t.ok(check.object(l._array_tmp), 'got a new array');
		t.ok(check.object(l._arrow_tmp), 'got a new arrow');
	};
	command_queue.push(call_5);
	
	function call_6() {
		//DEBUG
		console.log("call 6 - allocating the move pointer");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		t.ok(result.match(/move pointer/));
		
		t.ok(check.object(l._move_pointer), 'setup the move pointer');
		
		//BUG-WORKAROUND
		//	for some reason this single click is allocating two new move pointers? (does not appear in manual testing)
		//	just delete the second spurious move pointer from the 2-array to continue		
		/* var duplicate_index;
		for (var i = 0; i < UI._array_screen.children[2].children.length; i++) {
			var obj = UI._array_screen.children[2].children[i];
			
			//DEBUG
			console.log(obj);
			
			if (check.object(obj._) && check.string(obj._.name) && (obj._.name === "move")) {
				if (l._move_pointer !== obj) {
					console.log("Found DUPLICATE 'move' pointer");
					duplicate_index = i;
				} else {
					console.log("Found CORRECT 'move' pointer");
				}
			}
		}
		if (duplicate_index) {
			UI._array_screen.children[2].removeChildAt(duplicate_index);
		} */
	};
	command_queue.push(call_6);
	
	function call_7() {
		//DEBUG
		console.log("call 7 - moving first value between arrays");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		t.ok(result.match(/Moved value/));
		
		t.equal(l._array_tmp.children[0].children.length, 2, "first index in the new array, now has two children");
		t.equal(l._array_tmp.children[0].children[1].text, "0", "and the first value from the old array is now in the first index of the new array");
		t.equal(l._array.children[0].children.length, 1, "first index in the old array now has only 1 child");
	};
	command_queue.push(call_7);
	
	function call_8() {
		//DEBUG
		console.log("call 8 - incrementing the move pointer");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		t.ok(result.match(/Incremented the move pointer/), "saw that we moved the move pointer");
		t.equal(l._move_pointer._.index, 1, "move pointer should now be at index 1");
		t.deepEqual(l._move_pointer._.pointed_at, l._array.children[1], "move pointer should now be at index 1");
	};
	command_queue.push(call_8);
	
	function call_9() {
		//DEBUG
		console.log("call 9 - incrementing the tail pointer");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		
		t.ok(result.match(/Incremented the tail pointer/), "moved the tail pointer");
		t.equal(l._arrow_tmp._.index, 1, "tail pointer in the new array, now at index 1");
	};
	command_queue.push(call_9);
	
	function call_10() {
		//DEBUG
		console.log("call 10 - checking if finished");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		
		t.ok(result.match(/the 'move' pointer is not at/));
		t.ok(result.match(/the same index as the 'tail'/));
		t.ok(result.match(/we need to move at least/));
		t.ok(result.match(/one more value from the old array/));
	};
	command_queue.push(call_10);
	
	function call_11() {
		//DEBUG
		console.log("call 11 - moving value between arrays");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		
		t.equal(l._array_tmp.children[1].children.length, 2, "target index in the new array, now has two children");
		t.equal(l._array_tmp.children[1].children[1].text, "1", "and the value from the old array is now in the target index of the new array");
		t.equal(l._array.children[1].children.length, 1, "target index in the old array now has only 1 child");
	};
	command_queue.push(call_11);
	
	function call_12() {
		//DEBUG
		console.log("call 12 - incrementing the move pointer");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		t.ok(result.match(/Incremented the move pointer/), "saw that we moved the move pointer");
		t.equal(l._move_pointer._.index, 2, "move pointer should now be at index 2");
	};
	command_queue.push(call_12);
	
	function call_13() {
		//DEBUG
		console.log("call 13 - incrementing the tail pointer");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		
		t.ok(result.match(/Incremented the tail pointer/), "moved the tail pointer");
		t.equal(l._arrow_tmp._.index, 2, "tail pointer in the new array, now at index 2");
	};
	command_queue.push(call_13);
	
	function call_14() {
		//DEBUG
		console.log("call 14 - checking if finished moving");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		
		t.ok(result.match(/The 'move' pointer is at the same/));
		t.ok(result.match(/index as the 'tail' pointer/));
		t.ok(result.match(/we've finished moving/));
	};
	command_queue.push(call_14);
	
	function call_15() {
		//DEBUG
		console.log("call 15 - removing old array & move pointer");
		
		//keep a reference to the new array for testing below
		var new_array = l._array_tmp;
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		
		t.equal(l._array._.length, 4, "post next() the new array should be the default working array, as the old one had been removed");
		t.ok(check.undefined(l._array_tmp), "array_tmp variable has been cleared");
		t.ok(check.undefined(l._move_pointer), "the move pointer has been removed");
		t.notOk(l._array_full, "since the new array has space to insert, it's been flagged in the lesson");
	};
	command_queue.push(call_15);
	
	function call_16() {
		//DEBUG
		console.log("call 16 - inputing 2 into the array");
		
		//press the insert button
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		t.ok(Number.isNaN(ui.input.get()), "input is empty");
		
		t.equal(l._array._.values.length, 3, "values array now has a single element");
		
		var result = ui.output.get();
		t.ok(result.match(/Added the value/));
		t.ok(result.match(/to the array/));
	};
	command_queue.push(call_16);
	
	function call_17() {
		//DEBUG
		console.log("call 17 - advancing the 'tail' pointer");
		
		//press next
		ui.next_button.dispatchEvent(new Event("click"));
		
		//TEST
		var result = ui.output.get();
		t.ok(result.match(/Moved the \'tail\' pointer/));
		t.ok(result.match(/to prepare for the next insertion/));
		t.equal(l._tail_arrow._.index, 3, 'incremented the index for the arrow');
	};
	command_queue.push(call_17);
	
	var iter = command_queue[Symbol.iterator]();
	
	var intervalID = setInterval(function() {
		var result = iter.next();
		
		if (!result.done) {
			result.value();
		} else {
			console.log("DONE");
			TEARDOWN();
			t.end();
			clearInterval(intervalID);
		}
	}, 3000);
});