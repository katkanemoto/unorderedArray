var move = require('lib/util/move');
var test = require('tape');
var check = require('check-types');

test('[move] incorrect, bad number of arguments', function (t) {
	t.plan(2);
	
	try {
		move();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Requires argument/), 'should tell you what is wrong');
	}
});

test('[move] incorrect, bad source argument', function (t) {
	t.plan(2);
	
	try {
		move({source:"bad source argument", destination:{}, createjs:{}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Requires object options\: source\, destination\, createjs/), 'should tell you what is wrong');
	}
});

test('[move] incorrect, source, does not have (x, y) properties', function (t) {
	t.plan(2);
	
	try {
		move({source:{}, destination:{x:0, y:0}, createjs:{}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument source and desintation should have numeric properties/), 'should tell you what is wrong');
	}
});

test('[move] incorrect, objects have the (x, y) properties, but wrong type', function (t) {
	t.plan(2);
	
	try {
		move({source:{x:0, y:0}, destination:{x:"0", y:"0"}, createjs:{}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument source and desintation should have numeric properties/), 'should tell you what is wrong');
	}
});

test('[move] correct, defaults', function (t) {
	t.plan(1);
	
	var duration_seen;
	function mock_Tween() {
		return {
			get : function() {
				return this;
			},
			to : function(options, duration) {
				duration_seen = duration;
				return this;
			},
			call : function(func) {
				func();
			},
		};
	};
	
	var mock_createjs = {
		Tween : new mock_Tween(),
	};
	
	move({source:{x:0, y:0}, destination:{x:0, y:0}, createjs:mock_createjs});
	t.equal(duration_seen, 1000, 'using default duration');
});

test('[move] correct, duration invalid, uses defaults', function (t) {
	t.plan(1);
	
	var duration_seen;
	function mock_Tween() {
		return {
			get : function() {
				return this;
			},
			to : function(options, duration) {
				duration_seen = duration;
				return this;
			},
			call : function(func) {
				func();
			},
		};
	};
	
	var mock_createjs = {
		Tween : new mock_Tween(),
	};
	
	move({source:{x:0, y:0}, destination:{x:0, y:0}, createjs:mock_createjs, duration:"some bad value"});
	t.equal(duration_seen, 1000, 'using default duration');
});

test('[move] correct, duration set', function (t) {
	t.plan(1);
	
	var duration_seen;
	function mock_Tween() {
		return {
			get : function() {
				return this;
			},
			to : function(options, duration) {
				duration_seen = duration;
				return this;
			},
			call : function(func) {
				func();
			},
		};
	};
	
	var mock_createjs = {
		Tween : new mock_Tween(),
	};
	
	move({source:{x:0, y:0}, destination:{x:0, y:0}, createjs:mock_createjs, duration:1});
	t.equal(duration_seen, 1, 'using set duration');
});

test('[move] correct, bad duration value, uses defaults', function (t) {
	t.plan(1);
	
	var duration_seen;
	function mock_Tween() {
		return {
			get : function() {
				return this;
			},
			to : function(options, duration) {
				duration_seen = duration;
				return this;
			},
			call : function(func) {
				func();
			},
		};
	};
	
	var mock_createjs = {
		Tween : new mock_Tween(),
	};
	
	move({source:{x:0, y:0}, destination:{x:0, y:0}, createjs:mock_createjs, duration:0});
	t.equal(duration_seen, 1000, 'using default duration');
});

test('[move] correct, simulated mutex protection of the tween function', function (t) {
	t.plan(2);
	
	var duration_seen;
	function mock_Tween() {
		return {
			get : function() {
				return this;
			},
			to : function(options, duration) {
				duration_seen = duration;
				return this;
			},
			call : function(func) {
				//set a time out to simulate the time it takes to tween
				setTimeout(function() {
					//simulate a second move taking place while the first is not finished, it should return false indicating that the internal variable _is_moving is true and the tween is still executing
					t.notOk(move({source:{x:0, y:0}, destination:{x:0, y:0}, createjs:mock_createjs}), 'should return false indicating that the internal variable _is_moving is true and the tween is still executing');
					func();
				}, 1000);
				
			},
		};
	};
	
	var mock_createjs = {
		Tween : new mock_Tween(),
	};
	
	//call the tween, with the setTimeout above, the internal variable _is_moving should be true up until it's allowed to execute call()
	var result = move({source:{x:0, y:0}, destination:{x:0, y:0}, createjs:mock_createjs});
	t.ok(result, 'the result from the first move should be true, as we can tween initially');
});

test('[move] correct, inegration testing, defaults', function (t) {
	t.plan(6);
	var mock_source = {x:0, y:0}
	
	t.ok(move({source:mock_source, destination:{x:1, y:1}, createjs:createjs}));
	
	setTimeout(function() {
		t.ok(mock_source.x > 0 && mock_source.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(mock_source.y > 0 && mock_source.y < 1, 'value should be on the way to 1, but not equal');
		t.notOk(move({source:mock_source, destination:{x:1, y:1}, createjs:createjs}), 'should not be able to start another move until the first is complete');
	}, 500);
	
	setTimeout(function() {
		t.equal(mock_source.x, 1, 'value should be tweened to match the destination');
		t.equal(mock_source.y, 1, 'value should be tweened to match the destination');
	}, 2000);
});

test('[move] correct, inegration testing, duration set', function (t) {
	t.plan(6);
	var mock_source = {x:0, y:0}
	
	t.ok(move({source:mock_source, destination:{x:1, y:1}, createjs:createjs, duration:2000}));
	
	setTimeout(function() {
		t.ok(mock_source.x > 0 && mock_source.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(mock_source.y > 0 && mock_source.y < 1, 'value should be on the way to 1, but not equal');
		t.notOk(move({source:mock_source, destination:{x:1, y:1}, createjs:createjs}), 'should not be able to start another move until the first is complete');
	}, 1500);
	
	setTimeout(function() {
		t.equal(mock_source.x, 1, 'value should be tweened to match the destination');
		t.equal(mock_source.y, 1, 'value should be tweened to match the destination');
	}, 3000);
});

test('[move] correct, source and desintation the same', function (t) {
	t.plan(4);
	var mock_source = {x:0, y:0};
	var mock_destination = {x:0, y:0};
	
	t.ok(move({source:mock_source, destination:mock_destination, createjs:createjs}));
	
	setTimeout(function() {
		t.notOk(move({source:mock_source, destination:{x:1, y:1}, createjs:createjs}), 'should not be able to start another move until the first is complete');
	}, 500);
	
	setTimeout(function() {
		t.equal(mock_source.x, 0, 'value should be tweened to match the destination');
		t.equal(mock_source.y, 0, 'value should be tweened to match the destination');
	}, 2000);
});