var move = require('lib/util/move');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[move._argument_check] incorrect, no argument', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this);
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Requires argument/), 'should tell you what is wrong');
		t.ok(message.match(/object/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, wrong type', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, "some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Requires argument/), 'should tell you what is wrong');
		t.ok(message.match(/object/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, right type, but no x or y', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, {});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument requires numeric property/), 'should tell you what is wrong');
		t.ok(message.match(/x/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, right type, x is present, but wrong type', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, {x:"2"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument requires numeric property/), 'should tell you what is wrong');
		t.ok(message.match(/x/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, right type, x is present and correct, but y is not', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, {x:2});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument requires numeric property/), 'should tell you what is wrong');
		t.ok(message.match(/y/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] incorrect, argument passed, right type, x is present and correct, but y is wrong type', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	
	try {
		move.prototype._argument_check.call(mock_this, {x:2, y:"2"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Argument requires numeric property/), 'should tell you what is wrong');
		t.ok(message.match(/y/), "tells you what's needed");
	}
	
	TEARDOWN();
});

test('[move._argument_check] correct', function (t) {
	t.plan(1);
	
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//TEST
	t.ok(move.prototype._argument_check.call(mock_this, {x:2, y:2}), "method returned true, so all checks passed");
	
	TEARDOWN();
});

test("[move] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//TEST
	try {
		move();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		console.log(message);
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[move] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		move();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test('[move] correct, duration invalid, uses defaults', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0}, {duration:"some bad value"});
	t.equal(result._duration, 1000, 'using default duration');
	
	TEARDOWN();
});

test('[move] correct, duration unset, uses defaults', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0}, {});
	t.equal(result._duration, 1000, 'using default duration');
	
	TEARDOWN();
});

test('[move] correct, no options', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0});
	t.equal(result._duration, 1000, 'using default duration');
	
	TEARDOWN();
});

test('[move] correct, duration set', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0}, {duration:1});
	t.equal(result._duration, 1, 'uses user defined duration');
	
	TEARDOWN();
});

test('[move] correct, duration set, but bad number', function (t) {
	t.plan(1);
	
	SETUP();
	
	var result = move({x:0, y:0}, {duration:-1});
	t.equal(result._duration, 1000, 'default duration used');
	
	TEARDOWN();
});

test('[move.is_moving && move.to] correct, false before move, true while moving, false after and tween completed by changing the source', function (t) {
	t.plan(7);
	
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_argument_check : function() {},
		
		_createjs : primitives.get('createjs'),
		_source : {x:0, y:0},
		_duration : 1000,
	};
	
	//TEST
	t.notOk(move.is_moving(), "should be false before move");
	
	//create a tween to move _source to the coordinates at (1, 1), this should take 1 second, with the default duration
	var destination = {x:1, y:1};
	move.prototype.to.call(mock_this, destination);
	
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(mock_this._source.x > 0 && mock_this._source.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(mock_this._source.y > 0 && mock_this._source.y < 1, 'value should be on the way to 1, but not equal');
	}, 500);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "then false again after the move");
		t.equal(mock_this._source.x, destination.x, "source and destination should be the same after the move")
		t.equal(mock_this._source.y, destination.y, "source and destination should be the same after the move")
		TEARDOWN();
	}, 1500);
});

test('[move.is_moving && move.to] correct, user defined duration', function (t) {
	t.plan(7);
	
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_argument_check : function() {},
		
		_createjs : primitives.get('createjs'),
		_source : {x:0, y:0},
		_duration : 1000,
	};
	
	//TEST
	t.notOk(move.is_moving(), "should be false before move");
	
	//override duration, with user defined value
	var destination = {x:1, y:1};
	move.prototype.to.call(mock_this, destination, {duration:500});
	
	//test with values that are less than the default, as should not pass if the default is used in the tween
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(mock_this._source.x > 0 && mock_this._source.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(mock_this._source.y > 0 && mock_this._source.y < 1, 'value should be on the way to 1, but not equal');
	}, 250);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "then false again after the move");
		t.equal(mock_this._source.x, destination.x, "source and destination should be the same after the move");
		t.equal(mock_this._source.y, destination.y, "source and destination should be the same after the move");
		TEARDOWN();
	}, 900);
});

test('[move.is_moving && move.to] correct, cannot start second tween while first is running', function (t) {
	t.plan(2);
	
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_argument_check : function() {},
		
		_createjs : primitives.get('createjs'),
		_source : {x:0, y:0},
		_duration : 1000,
	};
	
	//TEST
	
	//override duration, with user defined value
	var destination = {x:1, y:1};
	move.prototype.to.call(mock_this, destination, {duration:3000});
	
	//test with values that are less than the default, as should not pass if the default is used in the tween
	setTimeout(function() {
		t.notOk(move.prototype.to.call(mock_this, {x:15, y:15}, {duration:1}), "should return false during a tween, as cannot create a second tween during the first");
	}, 1500);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "wait for tween to complete so as not to pollute other tests");
		TEARDOWN();
	}, 3100);
});

test('[move] integration testing, correct, decorate and tween', function (t) {
	t.plan(8);
	
	SETUP();
	
	var test_obj = {x:0, y:0};
	test_obj._ = {};
	test_obj._.move = move(test_obj);
	
	var destination = {x:1, y:1};
	
	//TEST
	t.notOk(move.is_moving(), "should be false before the tween");
	t.ok(test_obj._.move.to(destination), "should return true to start a tween");
	
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(test_obj.x > 0 && test_obj.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(test_obj.y > 0 && test_obj.y < 1, 'value should be on the way to 1, but not equal');
	}, 500);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "should be false after the tween is complete");
		t.equal(test_obj.x, destination.x, "source and destination should be the same after the move");
		t.equal(test_obj.y, destination.y, "source and destination should be the same after the move");
		TEARDOWN();
	}, 1100);
});

test('[move] integration testing, correct, decorate two objects and verify cannot tween other objects while a tween is executing', function (t) {
	SETUP();
	
	var test_obj1 = {x:0, y:0};
	test_obj1._ = {};
	test_obj1._.move = move(test_obj1);
	
	var test_obj2 = {x:0, y:0};
	test_obj2._ = {};
	test_obj2._.move = move(test_obj2);
	
	var destination = {x:1, y:1};
	
	//TEST
	t.notOk(move.is_moving(), "should be false before the tween");
	t.ok(test_obj1._.move.to(destination), "should return true to start a tween");
	t.notOk(test_obj2._.move.to(destination), "cannot start up second tween, while the first is running");
	
	setTimeout(function() {
		t.ok(move.is_moving(), "should return true during a tween");
		t.ok(test_obj1.x > 0 && test_obj1.x < 1, 'value should be on the way to 1, but not equal');
		t.ok(test_obj1.y > 0 && test_obj1.y < 1, 'value should be on the way to 1, but not equal');
		t.equal(test_obj2.x, 0, "second object remains the same, as not tweened");
		t.equal(test_obj2.y, 0, "second object remains the same, as not tweened");
	}, 500);
	
	setTimeout(function() {
		t.notOk(move.is_moving(), "should be false after the tween is complete");
		t.equal(test_obj1.x, destination.x, "source and destination should be the same after the move");
		t.equal(test_obj1.y, destination.y, "source and destination should be the same after the move");
		t.equal(test_obj2.x, 0, "second object remains the same, as not tweened");
		t.equal(test_obj2.y, 0, "second object remains the same, as not tweened");
		TEARDOWN();
		t.end();
	}, 1100);
});