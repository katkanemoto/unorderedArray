var array_UI = require('lib/UI/array_UI');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var mock_lib = {
		TitleScreen : function() {
			return {
				insert_btn : {
					addEventListener : function() {},
				},
				gotoAndPlay : function() {},
			};
		},
		ArrayScreen : function() {
			return {};
		},
		ArrayElement : function() {
			var ae = new createjs.Shape();
			ae.index_txt = {
				text : '',
			};
			
			return ae;
		},
	};
	
	primitives.set('lib', mock_lib);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test("[array_UI] incorrect, 'lib' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('lib', '');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/lib/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'lib' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('lib');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/lib/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('createjs');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, no argument", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, but no property", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, with length property, but wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({length:"some bad type"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, with length property, right type, but invalid value", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({length:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] correct", function (t) {
	//SETUP
	SETUP();
	
	//TEST
	var result = array_UI({length:1});
	
	t.ok(check.object(result), "got back an object");
	t.ok(check.instanceStrict(result.array, createjs.Container), "the array object");
	t.ok(check.instanceStrict(result.arrow, createjs.Container), "the arrow object");
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._make_array] correct', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_createjs : primitives.get('createjs'),
		_lib : primitives.get('lib'),
		_array : undefined,
	};
	
	//TEST
	var result = array_UI.prototype._make_array.call(mock_this, 1);
	
	t.ok(check.instanceStrict(result, createjs.Container), "got back a container");
	t.equal(result.children.length, 1, "should have only one arrayElement");
	t.ok(check.instanceStrict(result.children[0], createjs.Container), "children are containers");
	t.ok(check.object(result.children[0]._), "each child has a _ namespace for decoration");
	t.ok(check.number(result.children[0]._.index), "each child has an index associated");
	t.equal(result.children[0]._.index, 0, "...and the index matches the arrayElement's position in the array");
	t.ok(check.object(result.getBounds()), "bounds have been set");
	t.ok(check.object(result._), "decorated _ namespace is present");
	t.ok(check.number(result._.length), "_length is present");
	t.equal(result._.length, 1, "...and equal to the length of the array");
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._decorate_coordinates] correct', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	for (var i = 0; i < 3; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
	}
	
	//TEST
	var result = array_UI.prototype._decorate_coordinates.call(mock_this, outer_container);
	
	//initial placement, such that the parent array is at (0, 0)
	//	use this to test that the values of the coordinates update as the parent moves in the next step
	result.x = 0;
	result.y = 0;
	
	//this should increase, as we check arrayElements that are more to the right on the screen (larger x values on their positions)
	var previous_on_x = 0;
	//this should stay the same, as the arrayElements are all in a line (do not vary up or down on the screen)
	var previous_on_y = result.children[0]._.on().y;
	
	//record coordinate values, for comparison later when we change the position of the parent container
	var on_values = [];
	
	//similar characteristics of the values of below.x and below.y
	var previous_below_x = 0;
	var previous_below_y = result.children[0]._.below().y;
	
	var below_values = [];
	
	for (var i = 0; i < result.children.length; i++) {
		t.ok(check.object(result.children[i]._), "child " + String(i) + " has a '_' namepsace");
		t.ok(check.function(result.children[i]._.on), "child " + String(i) + " has a 'on' property");
		t.ok(check.function(result.children[i]._.below), "child " + String(i) + " has a 'below' property");
		
		var on = result.children[i]._.on();
		
		t.ok(check.number(on.x), "child " + String(i) + " has a numeric 'on.x' property");
		t.ok(check.number(on.y), "child " + String(i) + " has a numeric 'on.y' property");
		
		t.ok(on.x > previous_on_x, "child " + String(i) + ", 'on.x' greater than previous");
		previous_on_x = on.x;
		
		t.equal(on.y, previous_on_y, "child " + String(i) + ", 'on.y' equal to previous");
		previous_on_y = on.y;
		
		on_values.push({x:on.x, y:on.y});
		
		var below = result.children[i]._.below();
		
		t.ok(check.number(below.x), "child " + String(i) + " has a numeric 'below.x' property");
		t.ok(check.number(below.y), "child " + String(i) + " has a numeric 'below.y' property");
		
		t.ok(below.x > previous_below_x, "child " + String(i) + ", 'below.x' greater than previous");
		previous_below_x = below.x;
		
		t.equal(below.y, previous_below_y, "child " + String(i) + ", 'below.y' equal to previous");
		previous_below_y = below.y;
		
		below_values.push({x:below.x, y:below.y});
	}
	
	result.x = 100;
	result.y = 100;
	
	for (var i = 0; i < result.children.length; i++) {
		var on = result.children[i]._.on();
		
		t.ok(on.x > on_values[i].x, "should see larger value on current x, since we moved the parent");
		t.ok(on.y > on_values[i].y, "should see larger value on current y, since we moved the parent");
		t.equal(on.x - on_values[i].x, 100, "the difference between the old placement and the new should be how far we moved the parent");
		t.equal(on.y - on_values[i].y, 100, "the difference between the old placement and the new should be how far we moved the parent");
		
		var below = result.children[i]._.below();
		
		t.ok(below.x > below_values[i].x, "should see larger value on current x, since we moved the parent");
		t.ok(below.y > below_values[i].y, "should see larger value on current y, since we moved the parent");
		t.equal(below.x - below_values[i].x, 100, "the difference between the old placement and the new should be how far we moved the parent");
		t.equal(below.y - below_values[i].y, 100, "the difference between the old placement and the new should be how far we moved the parent");
	}
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._setup_tail_arrow] correct', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	for (var i = 0; i < 3; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		inner_container._.index = i;
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
	}
	
	outer_container._ = {};
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	for (var i = 0; i < outer_container.children.length; i++) {
		outer_container.children[i]._.below = function() {
			return {x:0, y:0}
		}
	}
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	
	//TEST
	var result = array_UI.prototype._setup_tail_arrow.call(mock_this, outer_container);
	
	t.ok(check.instanceStrict(result, createjs.Container), "got back a container");
	t.ok(check.object(result._), "that has a _ namespace");
	t.ok(check.object(result._.move), "_.move is defined");
	t.equal(result._.name, "tail", "arrow should be named 'tail'");
	t.ok(check.function(result._.next), "next is defined");
	t.ok(check.object(result._.pointed_at), "it should be pointed at an object");
	t.deepEqual(result._.pointed_at, outer_container.children[0], "which should be the first child in the array");
	t.equal(outer_container.children.length, 4, "added the arrow to the array container");
	t.deepEqual(outer_container.children[3], result, "added the arrow to the array container");
	
	t.end();
});

test('[array_UI._setup_tail_arrow] correct, next() correct from start of the array', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	outer_container._ = {};
	outer_container._.values = [];
	
	for (var i = 0; i < 3; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		inner_container._.index = i;
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
		
		outer_container._.values.push(i);
	}
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	outer_container.children[0]._.below = function() {
		return {x:0, y:0}
	};
	
	outer_container.children[1]._.below = function() {
		return {x:1, y:1}
	};
	
	outer_container.children[2]._.below = function() {
		return {x:2, y:2}
	};
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	
	//TEST
	var result = array_UI.prototype._setup_tail_arrow.call(mock_this, outer_container);
	var next_result = result._.next();
	
	t.ok(check.object(result._.pointed_at), "arrow should be pointed at an object");
	t.deepEqual(result._.pointed_at, outer_container.children[1], "...which should be the SECOND child post next()");
	
	t.notOk(next_result.done, "the return value should show we're not done iterating");
	
	setTimeout(function() {
		t.ok(result.x > 0 && result.x < 1, 'coordinates should be on the way to (1, 1), but not equal');
		t.ok(result.y > 0 && result.y < 1, 'coordinates should be on the way to (1, 1), but not equal');
	}, 500);
	
	setTimeout(function() {
		t.equal(result.x, 1, "arrow should be at (1, 1) after the move() is finished");
		t.equal(result.y, 1, "arrow should be at (1, 1) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._setup_tail_arrow] correct, next() correct from start of the array (array positioned at (100, 100))', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	outer_container._ = {};
	outer_container._.values = [];
	
	for (var i = 0; i < 3; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		inner_container._.index = i;
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
		
		outer_container._.values.push(i);
	}
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	//adjusting mock values for below() to take into account relocation of the outer_container
	var array = outer_container;
	array.children[0]._.below = (function(j) {
		return function() {
			return {x:array.x + array.children[j].x + 22, y:array.y + 70};
		}
	})(0)
	
	array.children[1]._.below = (function(j) {
		return function() {
			return {x:array.x + array.children[j].x + 22, y:array.y + 70};
		}
	})(1)
	
	array.children[2]._.below = (function(j) {
		return function() {
			return {x:array.x + array.children[j].x + 22, y:array.y + 70};
		}
	})(2)
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	
	//TEST
	var result = array_UI.prototype._setup_tail_arrow.call(mock_this, outer_container);
	
	//simulating positioning of array after the array has been created
	outer_container.x = 100;
	outer_container.y = 100;
		
	var next_result = result._.next();
	
	t.ok(check.object(result._.pointed_at), "arrow should be pointed at an object");
	t.deepEqual(result._.pointed_at, outer_container.children[1], "...which should be the SECOND child post next()");
	
	t.notOk(next_result.done, "the return value should show we're not done iterating");
	
	setTimeout(function() {
		t.ok(result.x > 22 && result.x < 72, 'coordinates should be on the way to (72, 70), but not equal');
		t.equal(result.y, 70, 'y should not change');
	}, 500);
	
	setTimeout(function() {
		t.ok(result.x, 72, 'arrow should be at (72, 70), after the move() is finished');
		t.equal(result.y, 70, 'y should not change');
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._setup_tail_arrow] correct, next() correct to the end of the array', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {};
	
	var _lib = primitives.get('lib');
	var _createjs = primitives.get('createjs');
	
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	var offsetX = 0;
	var outer_container = new _createjs.Container();
	
	outer_container._ = {};
	outer_container._.values = [];
	outer_container._.length = 1;
	
	for (var i = 0; i < outer_container._.length; i++) {
		var arrayElement = new _lib.ArrayElement();
		var inner_container = new _createjs.Container();
		inner_container.addChild(arrayElement);
		
		//offset each subcontainer by the size of the array element box
		inner_container.x = offsetX;
		
		inner_container._ = {};
		
		inner_container._.index = i;
		
		offsetX += 50;
		
		outer_container.addChild(inner_container);
		
		outer_container._.values.push(i);
	}
	//ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP-ARRAY-SETUP
	
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	outer_container.children[0]._.below = function() {
		return {x:0, y:0}
	};
	//ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES-ARRAY-DECORATE-COORDINATES
	
	//TEST
	var result = array_UI.prototype._setup_tail_arrow.call(mock_this, outer_container);
	var next_result = result._.next();
	
	t.ok(check.object(result._.pointed_at), "arrow should be pointed at an object");
	t.deepEqual(result._.pointed_at, outer_container.children[0], "...which should still be the first child");
	
	t.ok(next_result.done, "the return value should show we're done iterating.");
	
	t.equal(result.x, 0, "arrow should never have moved.");
	t.equal(result.y, 0, "arrow should never have moved.");
	
	t.end();
});

test('[array_UI._decorate_value_array] correct', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_this = {};
	
	//TEST
	var result = array_UI.prototype._decorate_value_array.call(mock_this, {_:{}});
	
	t.ok(check.array(result._.values), "values array decorated");
});

test('[array_UI._decorate_method_push] correct', function (t) {
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	t.ok(check.function(result._.push), "push() is decorated");
	
	t.end();
});

test('[array_UI._decorate_method_push] incorrect, no argument', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	try {
		result._.push()
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/Requires a createjs.Text object/), 'should be Text');
		t.ok(message.match(/value is a number/), 'should be a number');
	}
});

test('[array_UI._decorate_method_push] incorrect, bad argument', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	try {
		result._.push("some bad argument")
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/Requires a createjs.Text object/), 'should be Text');
		t.ok(message.match(/value is a number/), 'should be a number');
	}
});

test('[array_UI._decorate_method_push] incorrect, correct argument type, empty value', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text();
	
	try {
		result._.push(arg)
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/Requires a createjs.Text object/), 'should be Text');
		t.ok(message.match(/value is a number/), 'should be a number');
	}
});

test('[array_UI._decorate_method_push] incorrect, correct argument type, bad value', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text("some bad value");
	
	try {
		result._.push(arg)
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/Requires a createjs.Text object/), 'should be Text');
		t.ok(message.match(/value is a number/), 'should be a number');
	}
});

test('[array_UI._decorate_method_push] incorrect, array is full', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {
		_:{
			values : [1, 2, 3],
			length : 3,
		},
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text("0");
	
	try {
		result._.push(arg)
	} catch(error) {
		t.ok(check.instanceStrict(error, RangeError), 'we should get back a RangeError');
		var message = error.toString();
		t.ok(message.match(/Array is full/), "tells you what's wrong");
		t.ok(message.match(/cannot push\(\) new value/), "cannot push()");
	}
});

test('[array_UI._decorate_method_push] correct, empty array', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	mock_child._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {
		_ : {
			index : 0,
		},
	};
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//before the push
	t.equal(arg.x, 0, "the position of the value has not been tweened");
	t.equal(arg.y, 0, "the position of the value has not been tweened");
	t.equal(mock_child.children.length, 1, "there should only be a single child in position 0 of the array, the ArrayElement object");
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	
	result._.push(arg);
	
	//after the push
	t.equal(mock_child.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child.children[1].text, "0", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	
	setTimeout(function() {
		t.ok(arg.x > 0 && arg.x < 100, 'coordinates should be on the way to (100, 100), but not equal');
		t.ok(arg.y > 0 && arg.y < 100, 'coordinates should be on the way to (100, 100), but not equal');
	}, 500);
	
	setTimeout(function() {
		t.equal(arg.x, 100, "value should be at (100, 100) after the move() is finished");
		t.equal(arg.y, 100, "value should be at (100, 100) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, empty array, (array positioned at (100, 100))', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//adding on() positioning to the child
	mock_child._.on = (function(j) {
		return function() {
			return {x:mock_array.x + mock_array.children[j].x + 9, y:mock_array.y + 15};
		}
	})(0);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {
		_ : {
			index : 0,
		},
	};
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//adding arrow to the array container
	mock_array.addChild(mock_arrow);
	
	//positioning array
	mock_array.x = 100;
	mock_array.y = 100;
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//before the push
	t.equal(arg.x, 0, "the position of the value has not been tweened");
	t.equal(arg.y, 0, "the position of the value has not been tweened");
	t.equal(mock_child.children.length, 1, "there should only be a single child in position 0 of the array, the ArrayElement object");
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	
	result._.push(arg);
	
	//after the push
	t.equal(mock_child.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child.children[1].text, "0", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	
	setTimeout(function() {
		//value is repositioned with respect to the ArrayElement container, since (0, 0) globally is (-100, -100) with respect to the container
		//	half way through the tween from its translated global position to on(), it should increase from (-100, -100) to (9, 15)
		t.ok(arg.x > -100 && arg.x < 9, 'coordinates should be on the way to (9, 15), but not equal');
		t.ok(arg.y > -100 && arg.y < 15, 'coordinates should be on the way to (9, 15), but not equal');
	}, 500);
	
	setTimeout(function() {
		//NOTE: value is added to the array's child container (that contains the ArrayElement and the value)
		//	as such it is repositioned to a value in that container that maps to its original global position
		//	then tweened to the position on() the ArrayElement
		//	which, with respect to the child container, is always (9, 15)
		t.equal(arg.x, 9, "value should be at (9, 15) after the move() is finished");
		t.equal(arg.y, 15, "value should be at (9, 15) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, non-empty array', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child1 = new createjs.Container();
	mock_child1._ = {};
	mock_child1._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_child2 = new createjs.Container();
	mock_child2._ = {};
	mock_child2._.on = function() {
		return {x:200, y:200};
	};
	
	var mock_ArrayElement1 = new createjs.Shape();
	mock_ArrayElement1.x = 100;
	mock_ArrayElement1.y = 100;
	mock_child1.addChild(mock_ArrayElement1);
	
	//there's already a value in position 1
	var value1 = new createjs.Text("0");
	mock_child1.addChild(value1);
	mock_child1.x = 100;
	mock_child1.y = 100;
	
	//but no value in position 2
	var mock_ArrayElement2 = new createjs.Shape();
	mock_ArrayElement2.x = 200;
	mock_ArrayElement2.y = 200;
	mock_child2.addChild(mock_ArrayElement2);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [0];
	mock_array._.length = 3;
	mock_array.addChild(mock_child1);
	mock_array.addChild(mock_child2);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {
		_ : {
			index : 1,
		},
	};
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("1");
	arg.x = 0;
	arg.y = 0;
	
	result._.push(arg);
	
	//after the push
	t.equal(mock_child2.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child2.children[1].text, "1", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 2, "values array should have the new value in it");
	t.equal(mock_array._.values[1], 1, "values array should have the new value in it");
	
	setTimeout(function() {
		t.equal(arg.x, 200, "value should be at (200, 200) after the move() is finished");
		t.equal(arg.y, 200, "value should be at (200, 200) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, non-empty array (array positioned at (100, 100))', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child1 = new createjs.Container();
	mock_child1._ = {};
	//adding 100 to each coordinate to compensate for the positioning of the array, since on() returns global coordinates
	mock_child1._.on = function() {
		return {x:100+100, y:100+100};
	};
	
	var mock_child2 = new createjs.Container();
	mock_child2._ = {};
	mock_child2._.on = function() {
		return {x:200+100, y:200+100};
	};
	
	var mock_ArrayElement1 = new createjs.Shape();
	mock_ArrayElement1.x = 100;
	mock_ArrayElement1.y = 100;
	mock_child1.addChild(mock_ArrayElement1);
	
	//there's already a value in position 1
	var value1 = new createjs.Text("0");
	mock_child1.addChild(value1);
	mock_child1.x = 100;
	mock_child1.y = 100;
	
	//but no value in position 2
	var mock_ArrayElement2 = new createjs.Shape();
	mock_ArrayElement2.x = 200;
	mock_ArrayElement2.y = 200;
	mock_child2.addChild(mock_ArrayElement2);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [0];
	mock_array._.length = 3;
	mock_array.addChild(mock_child1);
	mock_array.addChild(mock_child2);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {
		_ : {
			index : 1,
		},
	};
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	mock_array.addChild(mock_arrow);
	
	//positioning array
	mock_array.x = 100;
	mock_array.y = 100;
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("1");
	arg.x = 0;
	arg.y = 0;
	
	result._.push(arg);
	
	//after the push
	t.equal(mock_child2.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child2.children[1].text, "1", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 2, "values array should have the new value in it");
	t.equal(mock_array._.values[1], 1, "values array should have the new value in it");
	
	setTimeout(function() {
		t.equal(arg.x, 200, "value should be at (200, 200) after the move() is finished");
		t.equal(arg.y, 200, "value should be at (200, 200) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

//tail