var array_UI = require('lib/UI/array_UI');
var test = require('tape');
var check = require('check-types');

//NOTE: workaround, until we can migrate these tests to use the real UI
//	the real `lib` variable for those tests that need it
var primitives = require("lib/util/primitives");
var real_lib = primitives.get('lib');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var mock_lib = {
		TitleScreen : function() {
			return {
				insert_btn : {
					addEventListener : function() {},
				},
				gotoAndPlay : function() {},
			};
		},
		ArrayScreen : function() {
			return {};
		},
		ArrayElement : function() {
			var ae = new createjs.Shape();
			ae.index_txt = {
				text : '',
			};
			
			return ae;
		},
	};
	
	primitives.set('lib', mock_lib);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test("[array_UI] incorrect, 'lib' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('lib', '');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/lib/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'lib' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('lib');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/lib/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.delete('createjs');
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, no argument", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, but no property", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, with length property, but wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({length:"some bad type"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, with length property, right type, but invalid value", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({length:0});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Require argument object with property 'length'/), "tells you what's wrong");
		t.ok(message.match(/'length' should be an integer > 0/), "and what length should be");
	}
	
	TEARDOWN();
});

test("[array_UI] incorrect, argument object, with correct length, arrow argument wrong type", function (t) {
	//SETUP
	SETUP();
	
	var result = array_UI({length:1, arrow:"some wrong type"});
	t.equal(result._.arrow._.name, "tail", "name of the arrow is the default");
	
	TEARDOWN();
	t.end();
});

test("[array_UI] incorrect, argument object, with correct length, arrow argument object, but name property wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	//TEST
	try {
		array_UI({length:1, arrow:{name:0}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Optional argument: arrow.name/), "tells you what's wrong");
		t.ok(message.match(/should be String/), "and how to fix it");
	}
	
	TEARDOWN();
});

test("[array_UI] correct, with alt arrow name", function (t) {
	//SETUP
	SETUP();
	
	var result = array_UI({length:1, arrow:{name:"search"}});
	t.equal(result._.arrow._.name, "search", "new arrow name is used");
	
	TEARDOWN();
	t.end();
});

test("[array_UI] correct, default arrow name", function (t) {
	//SETUP
	SETUP();
	
	//TEST
	var result = array_UI({length:1});
	
	t.ok(check.object(result), "got back an object");
	t.ok(check.instanceStrict(result, createjs.Container), "the array object");
	t.ok(check.instanceStrict(result._.arrow, createjs.Container), "the arrow object");
	t.ok(result.contains(result._.arrow), "we can see the arrow in the array container");
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._make_array] correct', function (t) {
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	
	var mock_this = {
		_createjs : primitives.get('createjs'),
		_lib : primitives.get('lib'),
		_array : undefined,
	};
	
	//TEST
	var result = array_UI.prototype._make_array.call(mock_this, 1);
	
	t.ok(check.instanceStrict(result, createjs.Container), "got back a container");
	t.equal(result.children.length, 1, "should have only one arrayElement");
	t.ok(check.instanceStrict(result.children[0], createjs.Container), "children are containers");
	t.ok(check.object(result.children[0]._), "each child has a _ namespace for decoration");
	t.ok(check.object(result.getBounds()), "bounds have been set");
	t.ok(check.object(result._), "decorated _ namespace is present");
	t.ok(check.number(result._.length), "_length is present");
	t.equal(result._.length, 1, "...and equal to the length of the array");
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._decorate_iterator] correct', function (t) {
	//SETUP
	SETUP();
	
	var called_iterator = false;
	var mock_this = {
		_iterator : function(array, name) {
			called_iterator = true;
		},
	};
	var mock_array = {
		_ : {},
	};
	
	var result = array_UI.prototype._decorate_iterator.call(mock_this, mock_array);
	
	t.ok(check.function(mock_array._.iterator), "iterator() was decorated");
	mock_array._.iterator("some name");
	t.ok(called_iterator, "calling the decorated function, calls _iterator on the `this`");
	
	TEARDOWN();
	
	t.end();
});

test('[array_UI._decorate_iterator -> iterator] incorrect, no argument', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var called_iterator = false;
	var mock_this = {
		_iterator : function(array, name) {
			called_iterator = true;
		},
	};
	var mock_array = {
		_ : {},
	};
	
	var result = array_UI.prototype._decorate_iterator.call(mock_this, mock_array);
	
	//TEST
	try {
		mock_array._.iterator();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Required argument 'name' missing/), "tells you what it's looking for");
		t.ok(message.match(/should be non-empty String/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test('[array_UI._decorate_iterator -> iterator] incorrect, empty string', function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var called_iterator = false;
	var mock_this = {
		_iterator : function(array, name) {
			called_iterator = true;
		},
	};
	var mock_array = {
		_ : {},
	};
	
	var result = array_UI.prototype._decorate_iterator.call(mock_this, mock_array);
	
	//TEST
	try {
		mock_array._.iterator('');
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Required argument 'name' missing/), "tells you what it's looking for");
		t.ok(message.match(/should be non-empty String/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test('[array_UI._decorate_value_array] correct', function (t) {
	t.plan(1);
	
	//SETUP
	var mock_this = {};
	
	//TEST
	var result = array_UI.prototype._decorate_value_array.call(mock_this, {_:{}});
	
	t.ok(check.array(result._.values), "values array decorated");
});

test('[array_UI._decorate_method_push] correct', function (t) {
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	t.ok(check.function(result._.push), "push() is decorated");
	
	t.end();
});

test('[array_UI._decorate_method_push] incorrect, no argument', function (t) {
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	try {
		result._.push()
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Requires a options object/), "tells you what's wrong");
	}
	
	t.end();
});

test('[array_UI._decorate_method_push] incorrect, bad argument', function (t) {
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	try {
		result._.push("some bad argument")
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Requires a options object/), "tells you what's wrong");
	}
	
	t.end();
});

test('[array_UI._decorate_method_push] incorrect, argument right type, value unset', function (t) {
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	try {
		result._.push({})
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Required argument: 'value'/), "tells you what's wrong");
		t.ok(message.match(/should be a createjs.Text object whose value is a number/), "and how to fix it");
	}
	
	t.end();
});

test('[array_UI._decorate_method_push] incorrect, argument right type, value set, but wrong type', function (t) {
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	
	try {
		result._.push({value:"some bad type"})
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Required argument: 'value'/), "tells you what's wrong");
		t.ok(message.match(/should be a createjs.Text object whose value is a number/), "and how to fix it");
	}
	
	t.end();
});

test('[array_UI._decorate_method_push] incorrect, argument right type, value set & right type, but empty content', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text();
	
	try {
		result._.push({value:arg})
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Required argument: 'value'/), "tells you what's wrong");
		t.ok(message.match(/should be a createjs.Text object whose value is a number/), "and how to fix it");
	}
});

test('[array_UI._decorate_method_push] incorrect, argument right type, value set & right type, but wrong type for content', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {_:{}};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text("some bad value");
	
	try {
		result._.push({value:arg});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Required argument: 'value'/), "tells you what's wrong");
		t.ok(message.match(/should be a createjs.Text object whose value is a number/), "and how to fix it");
	}
});

test('[array_UI._decorate_method_push] incorrect, argument right type, value set & right type, with good content, tween wrong type', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {
		_: {
			values : [],
			length : -1,
		}
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text("0");
	
	try {
		result._.push({value:arg, tween:"some bad type"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/Optional argument: 'tween'/), "tells you what's wrong");
		t.ok(message.match(/should be true or false/), "and how to fix it");
	}
	
	TEARDOWN();
});

test('[array_UI._decorate_method_push] incorrect, array is full', function (t) {
	t.plan(3);
	
	//SETUP
	var mock_this = {};
	var mock_array = {
		_:{
			values : [1, 2, 3],
			length : 3,
		},
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array);
	var arg = new createjs.Text("0");
	
	try {
		result._.push({value:arg});
	} catch(error) {
		t.ok(check.instanceStrict(error, RangeError), 'we should get back a RangeError');
		var message = error.toString();
		t.ok(message.match(/Array is full/), "tells you what's wrong");
		t.ok(message.match(/cannot push\(\) new value/), "cannot push()");
	}
	
	TEARDOWN();
});

test('[array_UI._decorate_method_push] correct, empty array', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	mock_child._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 0;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//add it to the stage, for global positioning
	var add_to_stage = require("lib/util/add_to_stage");
	var ats = add_to_stage(arg);
	ats();
	
	//before the push
	t.equal(arg.x, 0, "the position of the value has not been tweened");
	t.equal(arg.y, 0, "the position of the value has not been tweened");
	t.equal(mock_child.children.length, 1, "there should only be a single child in position 0 of the array, the ArrayElement object");
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	
	result._.push({value:arg});
	
	//after the push
	t.equal(mock_child.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child.children[1].text, "0", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	
	var move = require('lib/util/move');
	t.ok(move.is_moving(), "we should be moving directly after the push()");
	
	setTimeout(function() {
		t.equal(arg.x, 9, "value should be at (9, 15) after the move() is finished");
		t.equal(arg.y, 15, "value should be at (9, 15) after the move() is finished");
		
		TEARDOWN();
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, empty array, (array positioned at (100, 100))', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//adding on() positioning to the child
	mock_child._.on = (function(j) {
		return function() {
			return {x:mock_array.x + mock_array.children[j].x + 9, y:mock_array.y + 15};
		}
	})(0);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 0;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//adding arrow to the array container
	mock_array.addChild(mock_arrow);
	
	//positioning array
	mock_array.x = 100;
	mock_array.y = 100;
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//add it to the stage, for global positioning
	var add_to_stage = require("lib/util/add_to_stage");
	var ats = add_to_stage(arg);
	ats();
	
	//before the push
	t.equal(arg.x, 0, "the position of the value has not been tweened");
	t.equal(arg.y, 0, "the position of the value has not been tweened");
	t.equal(mock_child.children.length, 1, "there should only be a single child in position 0 of the array, the ArrayElement object");
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	
	result._.push({value:arg});
	
	//after the push
	t.equal(mock_child.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child.children[1].text, "0", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	
	setTimeout(function() {
		//value is repositioned with respect to the ArrayElement container, since (0, 0) globally is (-100, -100) with respect to the container
		//	half way through the tween from its translated global position to on(), it should increase from (-100, -100) to (9, 15)
		t.ok(arg.x > -100 && arg.x < 9, 'coordinates should be on the way to (9, 15), but not equal');
		t.ok(arg.y > -100 && arg.y < 15, 'coordinates should be on the way to (9, 15), but not equal');
	}, 500);
	
	setTimeout(function() {
		//NOTE: value is added to the array's child container (that contains the ArrayElement and the value)
		//	as such it is repositioned to a value in that container that maps to its original global position
		//	then tweened to the position on() the ArrayElement
		//	which, with respect to the child container, is always (9, 15)
		t.equal(arg.x, 9, "value should be at (9, 15) after the move() is finished");
		t.equal(arg.y, 15, "value should be at (9, 15) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, non-empty array', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child1 = new createjs.Container();
	mock_child1._ = {};
	mock_child1._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_child2 = new createjs.Container();
	mock_child2._ = {};
	mock_child2._.on = function() {
		return {x:200, y:200};
	};
	
	var mock_ArrayElement1 = new createjs.Shape();
	mock_ArrayElement1.x = 100;
	mock_ArrayElement1.y = 100;
	mock_child1.addChild(mock_ArrayElement1);
	
	//there's already a value in position 1
	var value1 = new createjs.Text("0");
	mock_child1.addChild(value1);
	mock_child1.x = 100;
	mock_child1.y = 100;
	
	//but no value in position 2
	var mock_ArrayElement2 = new createjs.Shape();
	mock_ArrayElement2.x = 200;
	mock_ArrayElement2.y = 200;
	mock_child2.addChild(mock_ArrayElement2);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [0];
	mock_array._.length = 3;
	mock_array.addChild(mock_child1);
	mock_array.addChild(mock_child2);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 1;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("1");
	arg.x = 0;
	arg.y = 0;
	
	//add it to the stage, for global positioning
	var add_to_stage = require("lib/util/add_to_stage");
	var ats = add_to_stage(arg);
	ats();
	
	result._.push({value:arg});
	
	//after the push
	t.equal(mock_child2.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child2.children[1].text, "1", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 2, "values array should have the new value in it");
	t.equal(mock_array._.values[1], 1, "values array should have the new value in it");
	
	setTimeout(function() {
		t.equal(arg.x, 9, "value should be at (9, 15) after the move() is finished");
		t.equal(arg.y, 15, "value should be at (9, 15) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, non-empty array (array positioned at (100, 100))', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child1 = new createjs.Container();
	mock_child1._ = {};
	//adding 100 to each coordinate to compensate for the positioning of the array, since on() returns global coordinates
	mock_child1._.on = function() {
		return {x:100+100, y:100+100};
	};
	
	var mock_child2 = new createjs.Container();
	mock_child2._ = {};
	mock_child2._.on = function() {
		return {x:200+100, y:200+100};
	};
	
	var mock_ArrayElement1 = new createjs.Shape();
	mock_ArrayElement1.x = 100;
	mock_ArrayElement1.y = 100;
	mock_child1.addChild(mock_ArrayElement1);
	
	//there's already a value in position 1
	var value1 = new createjs.Text("0");
	mock_child1.addChild(value1);
	mock_child1.x = 100;
	mock_child1.y = 100;
	
	//but no value in position 2
	var mock_ArrayElement2 = new createjs.Shape();
	mock_ArrayElement2.x = 200;
	mock_ArrayElement2.y = 200;
	mock_child2.addChild(mock_ArrayElement2);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [0];
	mock_array._.length = 3;
	mock_array.addChild(mock_child1);
	mock_array.addChild(mock_child2);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 1;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	mock_array.addChild(mock_arrow);
	
	//positioning array
	mock_array.x = 100;
	mock_array.y = 100;
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("1");
	arg.x = 0;
	arg.y = 0;
	
	//add it to the stage, for global positioning
	var add_to_stage = require("lib/util/add_to_stage");
	var ats = add_to_stage(arg);
	ats();
	
	result._.push({value:arg});
	
	//after the push
	t.equal(mock_child2.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child2.children[1].text, "1", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 2, "values array should have the new value in it");
	t.equal(mock_array._.values[1], 1, "values array should have the new value in it");
	
	setTimeout(function() {
		t.equal(arg.x, 9, "value should be at (9, 15) after the move() is finished");
		t.equal(arg.y, 15, "value should be at (9, 15) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, empty array (array to array move())', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	mock_child._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 0;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//create an array for the Text object to be placed in
	var container = new createjs.Container();
	container.addChild(arg);
	
	//add the container to the stage, now we should use relative positioning to tween the Text object between the containers
	var add_to_stage = require("lib/util/add_to_stage");
	var ats = add_to_stage(container);
	ats();
	
	//before the push
	t.equal(arg.x, 0, "the position of the value has not been tweened");
	t.equal(arg.y, 0, "the position of the value has not been tweened");
	t.equal(mock_child.children.length, 1, "there should only be a single child in position 0 of the array, the ArrayElement object");
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	
	result._.push({value:arg});
	
	//after the push
	t.equal(mock_child.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child.children[1].text, "0", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	
	setTimeout(function() {
		t.ok(arg.x > 0 && arg.x < 9, 'coordinates should be on the way to (9, 15), but not equal');
		t.ok(arg.y > 0 && arg.y < 15, 'coordinates should be on the way to (9, 15), but not equal');
	}, 500);
	
	setTimeout(function() {
		t.equal(arg.x, 9, "value should be at (9, 15) after the move() is finished");
		t.equal(arg.y, 15, "value should be at (9, 15) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, non-empty array (array to array move())', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child1 = new createjs.Container();
	mock_child1._ = {};
	mock_child1._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_child2 = new createjs.Container();
	mock_child2._ = {};
	mock_child2._.on = function() {
		return {x:200, y:200};
	};
	
	var mock_ArrayElement1 = new createjs.Shape();
	mock_ArrayElement1.x = 100;
	mock_ArrayElement1.y = 100;
	mock_child1.addChild(mock_ArrayElement1);
	
	//there's already a value in position 1
	var value1 = new createjs.Text("0");
	mock_child1.addChild(value1);
	mock_child1.x = 100;
	mock_child1.y = 100;
	
	//but no value in position 2
	var mock_ArrayElement2 = new createjs.Shape();
	mock_ArrayElement2.x = 200;
	mock_ArrayElement2.y = 200;
	mock_child2.addChild(mock_ArrayElement2);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [0];
	mock_array._.length = 3;
	mock_array.addChild(mock_child1);
	mock_array.addChild(mock_child2);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 1;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("1");
	arg.x = 0;
	arg.y = 0;
	
	//create an array for the Text object to be placed in
	var container = new createjs.Container();
	container.addChild(arg);
	
	//add the container to the stage, now we should use relative positioning to tween the Text object between the containers
	var add_to_stage = require("lib/util/add_to_stage");
	var ats = add_to_stage(container);
	ats();
	
	result._.push({value:arg});
	
	//after the push
	t.equal(mock_child2.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child2.children[1].text, "1", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 2, "values array should have the new value in it");
	t.equal(mock_array._.values[1], 1, "values array should have the new value in it");
	
	setTimeout(function() {
		t.equal(arg.x, 9, "value should be at (9, 15) after the move() is finished");
		t.equal(arg.y, 15, "value should be at (9, 15) after the move() is finished");
		
		TEARDOWN();
		
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, removing from source values array', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	mock_child._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 0;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//create an array for the Text object to be placed in
	var mock_source_array = new createjs.Container();
	var internal_container = new createjs.Container();
	internal_container.addChild(arg);
	mock_source_array.addChild(internal_container);
	
	//add the container to the stage, now we should use relative positioning to tween the Text object between the containers
	var add_to_stage = require("lib/util/add_to_stage");
	var ats = add_to_stage(mock_source_array);
	ats();
	
	//decorate the container with a values array
	mock_source_array._ = {};
	mock_source_array._.values = [];
	
	//add the vlaue of the arg to the values array
	mock_source_array._.values.push(0);
	
	//before the push
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	t.equal(mock_source_array._.values.length, 1, "the source array has a values in its internal values array");
	t.equal(mock_source_array._.values[0], 0, "the source array has a values in its internal values array");
	
	result._.push({value:arg});
	
	//after the push
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	t.equal(mock_source_array._.values.length, 0, "the source array should have had the values removed from its values array");
	t.ok(check.undefined(mock_source_array._.values[0]), "...and should be empty");
	
	setTimeout(function() {
		TEARDOWN();
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] incorrect, value not found in the source values array', function (t) {
	//SETUP
	
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	mock_child._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 0;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//create an array for the Text object to be placed in
	var mock_source_array = new createjs.Container();
	var internal_container = new createjs.Container();
	internal_container.addChild(arg);
	mock_source_array.addChild(internal_container);
	
	//add the container to the stage, now we should use relative positioning to tween the Text object between the containers
	var add_to_stage = require("lib/util/add_to_stage");
	var ats = add_to_stage(mock_source_array);
	ats();
	
	//decorate the container with a values array
	mock_source_array._ = {};
	mock_source_array._.values = [];
	
	//add the vlaue of the arg to the values array
	mock_source_array._.values.push(-1);
	
	//before the push
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	t.equal(mock_source_array._.values.length, 1, "the source array has a values in its internal values array");
	t.equal(mock_source_array._.values[0], -1, "the source array has a values in its internal values array");
	
	try {
		result._.push({value:arg});
	} catch(error) {
		t.ok(check.instanceStrict(error, Error), 'we should get back an Error');
		var message = error.toString();
		t.ok(message.match(/Unknown error/), "tells you what's wrong");
		t.ok(message.match(/the source array containing that value did NOT have that value in its internal values array/), "tells you what's wrong");
	}
	
	setTimeout(function() {
		TEARDOWN();
		t.end();
	}, 1500);
});

test('[array_UI._decorate_method_push] correct, empty array (tween = false)', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child = new createjs.Container();
	mock_child._ = {};
	mock_child._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_ArrayElement = new createjs.Shape();
	mock_ArrayElement.x = 100;
	mock_ArrayElement.y = 100;
	mock_child.addChild(mock_ArrayElement);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [];
	mock_array._.length = 3;
	mock_array.addChild(mock_child);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 0;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("0");
	arg.x = 0;
	arg.y = 0;
	
	//before the push
	t.equal(mock_child.children.length, 1, "there should only be a single child in position 0 of the array, the ArrayElement object");
	t.equal(mock_array._.values.length, 0, "values array should be empty");
	
	result._.push({value:arg, tween:false});
	
	//should not be tweening
	var move = require('lib/util/move');
	t.notOk(move.is_moving(), "should not be tweening");
	
	//after the push
	t.equal(mock_child.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child.children[1].text, "0", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 1, "values array should have the new value in it");
	t.equal(mock_array._.values[0], 0, "values array should have the new value in it");
	
	t.equal(arg.x, 9, "value should be at (9, 15) after being set in the array");
	t.equal(arg.y, 15, "value should be at (9, 15) after being set in the array");
	
	TEARDOWN();
	t.end();
});

test('[array_UI._decorate_method_push] correct, non-empty array (tween = false)', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {};
	
	//a container, containing an ArrayElement
	var mock_child1 = new createjs.Container();
	mock_child1._ = {};
	mock_child1._.on = function() {
		return {x:100, y:100};
	};
	
	var mock_child2 = new createjs.Container();
	mock_child2._ = {};
	mock_child2._.on = function() {
		return {x:200, y:200};
	};
	
	var mock_ArrayElement1 = new createjs.Shape();
	mock_ArrayElement1.x = 100;
	mock_ArrayElement1.y = 100;
	mock_child1.addChild(mock_ArrayElement1);
	
	//there's already a value in position 1
	var value1 = new createjs.Text("0");
	mock_child1.addChild(value1);
	mock_child1.x = 100;
	mock_child1.y = 100;
	
	//but no value in position 2
	var mock_ArrayElement2 = new createjs.Shape();
	mock_ArrayElement2.x = 200;
	mock_ArrayElement2.y = 200;
	mock_child2.addChild(mock_ArrayElement2);
	
	//a container containing children
	mock_array = new createjs.Container();
	mock_array._ = {};
	mock_array._.values = [0];
	mock_array._.length = 3;
	mock_array.addChild(mock_child1);
	mock_array.addChild(mock_child2);
	
	//a container, containing createjs.Shape objects forming an arrow
	//	as well as some decorated functions / properties
	var called_next = false;
	
	mock_arrow = new createjs.Container();
	mock_arrow._ = {};
	mock_arrow._.pointed_at = {};
	mock_arrow._.index = 1;
	mock_arrow._.next = function() {
		called_next = true;
	};
	
	//TEST
	var result = array_UI.prototype._decorate_method_push.call(mock_this, mock_array, mock_arrow);
	var arg = new createjs.Text("1");
	arg.x = 0;
	arg.y = 0;
	
	result._.push({value:arg, tween:false});
	
	//after the push
	t.equal(mock_child2.children.length, 2, "two children now, an ArrayElement and a value");
	t.equal(mock_child2.children[1].text, "1", "the value contains the value we're adding to the array");
	t.equal(mock_array._.values.length, 2, "values array should have the new value in it");
	t.equal(mock_array._.values[1], 1, "values array should have the new value in it");
	
	t.equal(arg.x, 9, "value should be at (9, 15) after being set in the array");
	t.equal(arg.y, 15, "value should be at (9, 15) after being set in the array");
	
	TEARDOWN();
	t.end();
});

test('[array_UI._decorate_move] correct', function (t) {
	t.plan(2);
	
	SETUP();
	
	//SETUP
	var mock_this = {};
	
	//TEST
	var result = array_UI.prototype._decorate_move.call(mock_this, {x:0, y:0, _:{}});
	
	t.ok(check.object(result._.move), "decorated move()");
	t.ok(check.function(result._.move.to), "decorated move()");
	
	TEARDOWN();
});

test('[array_UI.is_array] correct', function (t) {
	SETUP();
	
	//SETUP
	var test_array = array_UI({length:1});
	
	//TEST
	t.ok(array_UI.is_array(test_array));
	
	TEARDOWN();
	t.end();
});

test('[array_UI.is_array] incorrect', function (t) {
	SETUP();
	
	//TEST
	t.notOk(array_UI.is_array("some bad type"));
	
	TEARDOWN();
	t.end();
});

test('[array_UI._decorate_method_pop] correct', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {
		_createjs : createjs,
		_lib : real_lib,
	}
	
	var array = array_UI.prototype._make_array.call(mock_this, 1);
	array = array_UI.prototype._decorate_value_array(array);
	var arrow = array_UI.prototype._iterator(array, "tail");
	array._.arrow = arrow;
	array = array_UI.prototype._decorate_method_push(array, arrow);
	array = array_UI.prototype._decorate_move(array);
	array = array_UI.prototype._decorate_method_pop(array, arrow);
	
	//TEST
	t.ok(check.function(array._.pop));
	
	TEARDOWN();
	t.end();
});

test('[array_UI -> pop()] incorrect, empty array', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {
		_createjs : createjs,
		_lib : real_lib,
	}
	
	var array = array_UI.prototype._make_array.call(mock_this, 1);
	array = array_UI.prototype._decorate_value_array(array);
	var arrow = array_UI.prototype._iterator(array, "tail");
	array._.arrow = arrow;
	array = array_UI.prototype._decorate_method_push(array, arrow);
	array = array_UI.prototype._decorate_move(array);
	array = array_UI.prototype._decorate_method_pop(array, arrow);
	
	//TEST
	t.plan(2);
	try {
		array._.pop();
	} catch(error) {
		t.ok(check.instanceStrict(error, RangeError), 'we should get back an RangeError');
		var message = error.toString();
		t.ok(message.match(/from an empty array/), "tells you what's wrong");
	}
	
	TEARDOWN();
});

test('[array_UI -> pop()] incorrect, bad argument index, wrong type', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {
		_createjs : createjs,
		_lib : real_lib,
	}
	
	var array = array_UI.prototype._make_array.call(mock_this, 1);
	array = array_UI.prototype._decorate_value_array(array);
	var arrow = array_UI.prototype._iterator(array, "tail");
	array._.arrow = arrow;
	array = array_UI.prototype._decorate_method_push(array, arrow);
	array = array_UI.prototype._decorate_move(array);
	array = array_UI.prototype._decorate_method_pop(array, arrow);
	
	//TEST
	t.plan(3);
	try {
		array._.pop({index:"some bad type"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back an TypeError');
		var message = error.toString();
		t.ok(message.match(/Optional argument 'index'/), "tells you what's wrong");
		t.ok(message.match(/should be an integer and in bounds on the array/), "and how to fix it");
	}
	
	TEARDOWN();
});

test('[array_UI -> pop()] incorrect, bad argument index, invalid value', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {
		_createjs : createjs,
		_lib : real_lib,
	}
	
	var array = array_UI.prototype._make_array.call(mock_this, 1);
	array = array_UI.prototype._decorate_value_array(array);
	var arrow = array_UI.prototype._iterator(array, "tail");
	array._.arrow = arrow;
	array = array_UI.prototype._decorate_method_push(array, arrow);
	array = array_UI.prototype._decorate_move(array);
	array = array_UI.prototype._decorate_method_pop(array, arrow);
	
	//TEST
	t.plan(3);
	try {
		array._.pop({index:-1});
	} catch(error) {
		t.ok(check.instanceStrict(error, RangeError), 'we should get back an RangeError');
		var message = error.toString();
		t.ok(message.match(/Optional argument 'index'/), "tells you what's wrong");
		t.ok(message.match(/should be an integer and in bounds on the array/), "and how to fix it");
	}
	
	TEARDOWN();
});

test('[array_UI -> pop()] incorrect, bad argument index, invalid value', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {
		_createjs : createjs,
		_lib : real_lib,
	}
	
	var array = array_UI.prototype._make_array.call(mock_this, 1);
	array = array_UI.prototype._decorate_value_array(array);
	var arrow = array_UI.prototype._iterator(array, "tail");
	array._.arrow = arrow;
	array = array_UI.prototype._decorate_method_push(array, arrow);
	array = array_UI.prototype._decorate_move(array);
	array = array_UI.prototype._decorate_method_pop(array, arrow);
	
	//TEST
	t.plan(3);
	try {
		array._.pop({index:1});
	} catch(error) {
		t.ok(check.instanceStrict(error, RangeError), 'we should get back an RangeError');
		var message = error.toString();
		t.ok(message.match(/Optional argument 'index'/), "tells you what's wrong");
		t.ok(message.match(/should be an integer and in bounds on the array/), "and how to fix it");
	}
	
	TEARDOWN();
});

test('[array_UI -> pop()] correct, default, single item in array', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {
		_createjs : createjs,
		_lib : real_lib,
	}
	
	var array = array_UI.prototype._make_array.call(mock_this, 1);
	array = array_UI.prototype._decorate_value_array(array);
	var arrow = array_UI.prototype._iterator(array, "tail");
	array._.arrow = arrow;
	array = array_UI.prototype._decorate_method_push(array, arrow);
	array = array_UI.prototype._decorate_move(array);
	array = array_UI.prototype._decorate_method_pop(array, arrow);
	
	array._.push({value:new createjs.Text(0), tween:false});
	array._.arrow._.next({tween:false});
	
	//TEST
	var result = array._.pop();
	
	t.equal(result, 0);
	t.equal(array._.values.length, 0);
	t.equal(array.children[0].children.length, 1);
	
	TEARDOWN();
	t.end();
});

test('[array_UI -> pop()] correct, default, multiple items in array, remove from last position', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {
		_createjs : createjs,
		_lib : real_lib,
	}
	
	var array = array_UI.prototype._make_array.call(mock_this, 4);
	array = array_UI.prototype._decorate_value_array(array);
	var arrow = array_UI.prototype._iterator(array, "tail");
	array._.arrow = arrow;
	array = array_UI.prototype._decorate_method_push(array, arrow);
	array = array_UI.prototype._decorate_move(array);
	array = array_UI.prototype._decorate_method_pop(array, arrow);
	
	array._.push({value:new createjs.Text(0), tween:false});
	array._.arrow._.next({tween:false});
	array._.push({value:new createjs.Text(1), tween:false});
	array._.arrow._.next({tween:false});
	
	//TEST
	var result = array._.pop();
	
	t.equal(result, 1);
	t.equal(array._.values.length, 1);
	t.equal(array.children[1].children.length, 1);
	
	TEARDOWN();
	t.end();
});

test('[array_UI -> pop()] correct, multiple items in array, remove from first position', function (t) {
	//SETUP
	SETUP();
	
	var mock_this = {
		_createjs : createjs,
		_lib : real_lib,
	}
	
	var array = array_UI.prototype._make_array.call(mock_this, 4);
	array = array_UI.prototype._decorate_value_array(array);
	var arrow = array_UI.prototype._iterator(array, "tail");
	array._.arrow = arrow;
	array = array_UI.prototype._decorate_method_push(array, arrow);
	array = array_UI.prototype._decorate_move(array);
	array = array_UI.prototype._decorate_method_pop(array, arrow);
	
	array._.push({value:new createjs.Text(0), tween:false});
	array._.arrow._.next({tween:false});
	array._.push({value:new createjs.Text(1), tween:false});
	array._.arrow._.next({tween:false});
	
	//TEST
	var result = array._.pop({index:0});
	
	t.equal(result, 0);
	t.equal(array._.values.length, 1);
	t.equal(array._.values[0], 1, "the values array has moved its values");
	t.equal(array.children[0].children.length, 1, "we've removed the first item...");
	t.equal(array.children[1].children.length, 2, "but the second item in the array is still at its index and has NOT been moved");
	
	TEARDOWN();
	t.end();
});

//tail