var shape_factory = require('lib/factory/shape_factory');
var test = require('tape');
var check = require('check-types');

function SETUP() {
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', createjs);
	
	var canvas = document.getElementsByTagName('canvas')[0];
	var stage = new createjs.Stage(canvas);
	
	primitives.set('stage', stage);
}

function TEARDOWN() {
	var primitives = require("lib/util/primitives");
	primitives.clear();
}

test('[shape_factory.color] correct, no arguments', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color();
	t.deepEqual({fill:undefined, stroke:null}, sf._color_options, 'internal color variable is default');
	
	TEARDOWN();
});

test('[shape_factory.color] correct, valid color string', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({fill:'#000'});
	t.deepEqual({fill:'#000', stroke:null}, sf._color_options, 'fill option is set on internal color variable');
	
	TEARDOWN();
});

test('[shape_factory.color] correct, valid color string, as alias color', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({color:'#000'});
	t.deepEqual({fill:'#000', stroke:null}, sf._color_options, 'fill option is set on internal color variable');
	
	TEARDOWN();
});

test('[shape_factory.color] correct, valid color string to stroke', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({stroke:'#000'});
	t.deepEqual({fill:undefined, stroke:'#000'}, sf._color_options, 'stroke is set');
	
	TEARDOWN();
});

test('[shape_factory.color] incorrect, invalid color string', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.color({color:'some fake color string'});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/non-empty String \(of a valid CSS color\)/), 'argument should be css color, null or undefined');
	}
	
	TEARDOWN();
});

test('[shape_factory.color] correct, color is null', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({color:null});
	t.deepEqual({fill:null, stroke:null}, sf._color_options, 'both fill and stroke should be null');
	
	TEARDOWN();
});

test('[shape_factory.color] incorrect, argument is not object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.color("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'argument should be an object');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, empty argument', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape();
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/argument 'type' is required/), 'argument should include "type" option at least');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, type argument invalid object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape({type:{}});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/non-empty String/), 'argument should include "type" option at least');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, type argument empty string', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape({type:""});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/non-empty String/), 'argument should include "type" option at least');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, an invalid type string', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape({type:"some fake shape spec"});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/argument 'type' was unknown shape type/), 'argument should include "type" option at least');
	}
	
	TEARDOWN();
});

test('[shape_factory.shape] correct, type=circle, but no radius defined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	
	sf.shape({type:"circle"});
	
	t.equal(sf._shape_type, "circle");
	t.equal(sf._shape_options.radius, 1);
	
	TEARDOWN();
});

test('[shape_factory.shape] correct, type=circle, radius defined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	
	sf.shape({type:"circle", radius:2});
	
	t.equal(sf._shape_type, "circle");
	t.equal(sf._shape_options.radius, 2);
	
	TEARDOWN();
});

test('[shape_factory.shape] correct, type=rect, height and width undefined', function (t) {
	t.plan(3);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"rect"});
	
	t.equal(sf._shape_type, "rect");
	t.equal(sf._shape_options.height, 18);
	t.equal(sf._shape_options.width, 36);
	
	TEARDOWN();
});

test('[shape_factory.shape] correct, type=rect, width and height defined', function (t) {
	t.plan(3);
	
	SETUP();
	
	var sf = shape_factory();
	
	sf.shape({type:"rect", width:1, height:2});
	
	t.equal(sf._shape_type, "rect");
	t.equal(sf._shape_options.height, 2);
	t.equal(sf._shape_options.width, 1);
	
	TEARDOWN();
});

test('[shape_factory.shape] incorrect, argument is not object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.shape("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'argument should be an object');
	}
	
	TEARDOWN();
});

test('[shape_factory._get_color] correct, fill is undefined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf._color_options.fill = undefined;
	
	var result = sf._get_color();
	
	var colorString = require("color-string");
	t.ok(colorString.get(result.fill), 'should get back a valid color for the fill');
	
	t.equal(result.stroke, null);
	
	TEARDOWN();
});

test('[shape_factory._get_color] correct, fill is user defined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf._color_options.fill = "some color string";
	
	var result = sf._get_color();
	
	t.equal(result.fill, "some color string", 'should get back the test color string for the fill');
	
	t.equal(result.stroke, null);
	
	TEARDOWN();
});

test('[shape_factory._get_color] correct, stroke and fill are user defined', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf._color_options.fill = "some color string";
	sf._color_options.stroke = "some other color string";
	
	var result = sf._get_color();
	
	t.equal(result.fill, "some color string", 'should get back the test color string for the fill');
	
	t.equal(result.stroke, "some other color string", 'get back the test stroke string');
	
	TEARDOWN();
});

test('[shape_factory._get_shape] incorrect, shape() had not been run to setup', function (t) {
	t.plan(2);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	
	//test
	try {
		sf._get_shape({fill:"red", stroke:null});
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/run shape/), 'user should do shape() first before attempting to call _get_shape()');
	}
	
	TEARDOWN();
});

test('[shape_factory._get_shape] correct, defaults (circle)', function (t) {
	t.plan(3);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	sf._shape_type = "circle";
	
	//test
	var shape = sf._get_shape({fill:"red", stroke:null});
	t.ok(check.instanceStrict(shape.graphics.command, createjs.Graphics.Circle), 'Shape should contain a circle graphic');
	t.equal(shape.graphics.command.radius, 1, '...with default radius (1)');
	t.deepEqual(shape.getBounds(), {x: -1, y: -1, width: 2, height: 2}, "...whose bounds should be special values for Circle");
	
	TEARDOWN();
});

test('[shape_factory._get_shape] correct, user options (circle)', function (t) {
	t.plan(5);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	sf._shape_options.radius = 42;
	sf._shape_options.x = 42;
	sf._shape_options.y = 42;
	sf._shape_type = "circle";
	
	//test
	var shape = sf._get_shape({fill:"red", stroke:null});
	t.ok(check.instanceStrict(shape.graphics.command, createjs.Graphics.Circle), 'Shape should contain a circle graphic');
	t.equal(shape.graphics.command.radius, 42, '...with a radius of 42');
	t.deepEqual(shape.getBounds(), {x: -42, y: -42, width: 84, height: 84}, "...whose bounds should be special values for Circle");
	t.equal(shape.x, 42, "x is correct");
	t.equal(shape.y, 42, "y is correct");
	
	TEARDOWN();
});

test('[shape_factory._get_shape] correct, defaults (rectangle)', function (t) {
	t.plan(4);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	sf._shape_type = "rect";
	
	//test
	var shape = sf._get_shape({fill:"red", stroke:null});
	t.ok(check.instanceStrict(shape.graphics.command, createjs.Graphics.Rect), 'Shape should contain a rectangle graphic');
	t.equal(shape.graphics.command.h, 18, '...with default height');
	t.equal(shape.graphics.command.w, 36, '...and width');
	t.deepEqual(shape.getBounds(), {x: 0, y: 0, width: 36, height: 18}, "bounds should be at the edge of the rectangle");
	
	TEARDOWN();
});

test('[shape_factory._get_shape] correct, user defined (rectangle)', function (t) {
	t.plan(6);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	sf._shape_options.height = 42;
	sf._shape_options.width = 42;
	sf._shape_options.x = 42;
	sf._shape_options.y = 42;
	sf._shape_type = "rect";
	
	//test
	var shape = sf._get_shape({fill:"red", stroke:null});
	t.ok(check.instanceStrict(shape.graphics.command, createjs.Graphics.Rect), 'Shape should contain a rectangle graphic');
	t.equal(shape.graphics.command.h, 42, '...with default height');
	t.equal(shape.graphics.command.w, 42, '...and width');
	t.deepEqual(shape.getBounds(), {x: 0, y: 0, width: 42, height: 42}, "bounds should be at the edge of the rectangle");
	t.equal(shape.x, 42, "x is correct");
	t.equal(shape.y, 42, "y is correct");
	
	TEARDOWN();
});

test('[shape_factory._bundle] correct', function (t) {
	t.plan(4);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var shape1 = new createjs.Shape();
	shape1.setBounds(1, 1, 1, 1);
	var shape2 = new createjs.Shape();
	
	//test
	var container = sf._bundle(shape1, shape2);
	t.equal(container.children.length, 2);
	t.equal(container.children[0], shape1);
	t.equal(container.children[1], shape2);
	//bounds should be the same as the shape in container
	t.deepEqual(container.getBounds(), {x: 1, y: 1, width: 1, height: 1});
	
	TEARDOWN();
});

test('[shape_factory._set_props] correct', function (t) {
	t.plan(2);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var shape = new createjs.Shape();
	shape.setBounds(0, 0, 0, 0);
	
	var text = new createjs.Text();
	var container = sf._bundle(shape, text);
	
	//test
	var result = sf._set_props(container);
	
	t.equal(container.x, 0);
	t.equal(container.y, 0);
	
	TEARDOWN();
});

test('[shape_factory._set_props] correct, user options', function (t) {
	t.plan(2);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var shape = new createjs.Shape();
	shape.setBounds(0, 0, 0, 0);
	
	var text = new createjs.Text();
	var container = sf._bundle(shape, text);
	
	//test
	var result = sf._set_props(container, {x:42, y:42});
	t.equal(result.x, 42);
	t.equal(result.y, 42);
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, defaults, rectangle', function (t) {
	t.plan(26);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"rect"});
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.ok(check.number(result.children[0].graphics.command.h), "as a rect it should have a valid height property");
	t.ok(check.number(result.children[0].graphics.command.w), "...and width");
	t.equal(result.children[0].graphics.command.h, 18, "should have default height for a rect");
	t.equal(result.children[0].graphics.command.w, 36, "...and width");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	//we should see all the event handlers / modifiers set
	var shape = result.children[0];
	t.ok(result._.on);
	t.ok(check.function(result._.on));
	t.ok(result._.off);
	t.ok(check.function(result._.off));
	t.ok(result._.addEventListener);
	t.ok(check.function(result._.addEventListener));
	t.ok(result._.hasEventListener);
	t.ok(check.function(result._.hasEventListener));
	t.ok(result._.removeAllEventListeners);
	t.ok(check.function(result._.removeAllEventListeners));
	t.ok(result._.removeEventListener);
	t.ok(check.function(result._.removeEventListener));
	
	t.deepEqual(result.getBounds(), {x:0, y:0, width:36, height:18}, "...and we should be able to see the default bounds");
	
	t.ok(result._.place, "the place property should be defined... ");
	t.ok(check.object(result._.place), "...and the place object should be attached");
	
	var colorString = require("color-string");
	t.ok(colorString.get(result._.shape_fill), "the fill should be a random color");
	t.equal(result._.shape_stroke, null, "and stroke should be the default (null)");
	
	TEARDOWN();
});

test('[shape_factory.get] incorrect, argument is not object', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.get("some bad argument");
	} catch(error) {
		t.ok(check.instanceStrict(error, TypeError), 'we should get back a TypeError');
		var message = error.toString();
		t.ok(message.match(/requires Object/), 'argument should be an object');
	}
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, defaults, circle', function (t) {
	t.plan(24);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"circle"});
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.ok(check.number(result.children[0].graphics.command.radius), "as a circle it should have a valid radius property");
	t.equal(result.children[0].graphics.command.radius, 1, "should have default radius for a circle");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	
	//we should see all the event handlers / modifiers set
	//NOTE: we cannot tell the difference between the Shape.(function) and Container.(function) (of this type)
	//	they must be inherited from the same place, so we just have to check that they're set and that they're functions	
	var shape = result.children[0];
	t.ok(result._.on);
	t.ok(check.function(result._.on));
	t.ok(result._.off);
	t.ok(check.function(result._.off));
	t.ok(result._.addEventListener);
	t.ok(check.function(result._.addEventListener));
	t.ok(result._.hasEventListener);
	t.ok(check.function(result._.hasEventListener));
	t.ok(result._.removeAllEventListeners);
	t.ok(check.function(result._.removeAllEventListeners));
	t.ok(result._.removeEventListener);
	t.ok(check.function(result._.removeEventListener));
	
	t.deepEqual(result.getBounds(), {x:-1, y:-1, width:2, height:2}, "and we should be able to see the default bounds");
	
	t.ok(result._.place, "the place property should be defined... ");
	t.ok(check.object(result._.place), "...and the place object should be attached");
	
	var colorString = require("color-string");
	t.ok(colorString.get(result._.shape_fill), "the fill should be a random color");
	t.equal(result._.shape_stroke, null, "and stroke should be the default (null)");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, user options', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"circle"});
	var result = sf.get({x:1, y:1});
	
	t.equal(result.x, 1);
	t.equal(result.y, 1);
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, color() set', function (t) {
	t.plan(4);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"circle", radius:2});
	sf.color({color:"red"});
	var result = sf.get();
	
	//can't check color with method in createjs, so just have to verify we got the right Shape
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4});
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, text() set', function (t) {
	t.plan(7);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"circle", radius:2});
	sf.text({text:"red"});
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4})
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.equal(result.children[1].text, "red", "...to what we passed in");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, setter function permutation: text, color, shape', function (t) {
	t.plan(7);
	
	SETUP();
	
	var sf = shape_factory();
	sf.text({text:"red"});
	sf.color({color:"red"});
	sf.shape({type:"circle", radius:2});
	
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4})
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.equal(result.children[1].text, "red", "...to what we passed in");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, setter function permutation: color, text, shape', function (t) {
	t.plan(7);
	
	SETUP();
	
	var sf = shape_factory();
	sf.color({color:"red"});
	sf.text({text:"red"});
	sf.shape({type:"circle", radius:2});
	
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4})
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.equal(result.children[1].text, "red", "...to what we passed in");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, trigger exception in setter (color()), then get()', function (t) {
	t.plan(4);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.color({color:25});
	} catch (error) {}
	
	sf.shape({type:"circle", radius:2});
	
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4});
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, circle, trigger exception in setter (text()), then get()', function (t) {
	t.plan(7);
	
	SETUP();
	
	var sf = shape_factory();
	try {
		sf.text({color:25});
	} catch (error) {}
	
	sf.shape({type:"circle", radius:2});
	
	var result = sf.get();
	
	t.equal(result.children.length, 2);
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.equal(result.children[0].graphics.command.radius, 2, "should have radius for a circle");
	t.deepEqual(result.getBounds(), {x:-2, y:-2, width:4, height:4});
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, array box (null color, assigned number, black stroke, number is left of the shape)', function (t) {
	t.plan(12);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result = sf.get();
	
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.ok(check.number(result.children[0].graphics.command.h), "as a rect it should have a valid height property");
	t.ok(check.number(result.children[0].graphics.command.w), "...and width");
	t.equal(result.children[0].graphics.command.h, 18, "should have default height for a rect");
	t.equal(result.children[0].graphics.command.w, 36, "...and width");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	t.equal(result.children[1].text, "0", "we should see our number set");
	t.equal(result.children[1].x, -22, "and our coordinates");
	t.equal(result.children[1].y, 1, "set for the text");
	t.equal(result.children[1].font, "16px Arial", "and our font set");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, aray box (null color, assigned number, black stroke, number is left of the shape)', function (t) {
	t.plan(12);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result = sf.get();
	
	t.ok(check.instanceStrict(result.children[0], createjs.Shape), "first child should should be createjs.Shape");
	t.ok(check.number(result.children[0].graphics.command.h), "as a rect it should have a valid height property");
	t.ok(check.number(result.children[0].graphics.command.w), "...and width");
	t.equal(result.children[0].graphics.command.h, 18, "should have default height for a rect");
	t.equal(result.children[0].graphics.command.w, 36, "...and width");
	t.ok(check.instanceStrict(result.children[1], createjs.Text), "second child should should be createjs.Text");
	t.ok(check.string(result.children[1].text), "...its value should be set");
	t.ok(check.number(Number(result.children[1].text)), "...to a number");
	t.equal(result.children[1].text, "0", "we should see our number set");
	t.equal(result.children[1].x, -22, "and our coordinates");
	t.equal(result.children[1].y, 1, "set for the text");
	t.equal(result.children[1].font, "16px Arial", "and our font set");
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, aray box, multiple, while changing only the display text', function (t) {
	t.plan(6);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result_1 = sf.get();
	
	sf.text({text:1});
	
	var result_2 = sf.get();
	
	t.equal(result_1.children[1].text, "0");
	t.equal(result_2.children[1].text, "1");
	
	t.equal(result_1.children[1].font, result_2.children[1].font);
	t.equal(result_1.children[1].x, result_2.children[1].x);
	t.equal(result_1.children[1].y, result_2.children[1].y);
	t.equal(result_1.children[1].textAlign, result_2.children[1].textAlign);
	
	TEARDOWN();
});

test('[shape_factory.get][inegration testing] correct, multiple, checking container option persistence', function (t) {
	t.plan(8);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result_1 = sf.get();
	var result_2 = sf.get({y:18});
	var result_3 = sf.get({x:36});
	var result_4 = sf.get({y:36});
	
	t.equal(result_1.x, 0);
	t.equal(result_1.y, 0);
	
	t.equal(result_2.x, 0);
	t.equal(result_2.y, 18);
	
	t.equal(result_3.x, 36);
	t.equal(result_3.y, 18);
	
	t.equal(result_4.x, 36);
	t.equal(result_4.y, 36);
	
	TEARDOWN();
});

test('[shape_factory.get][place] correct', function (t) {
	t.plan(1);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result_1 = sf.get();
	
	t.ok(!check.undefined(result_1._.place), 'place namespace is correctly applied to the container');
	
	TEARDOWN();
});

test('[shape_factory.get][place] placer functions work', function (t) {
	t.plan(8);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result_1 = sf.get();
	var result_2 = sf.get();
	t.equal(result_1.x, 0);
	t.equal(result_1.y, 0);
	t.equal(result_2.x, 0);
	t.equal(result_2.y, 0);
	
	//this should move it below the other container
	result_1._.place.below(result_2);
	
	t.equal(result_1.x, 0);
	t.equal(result_1.y, 18);
	t.equal(result_2.x, 0);
	t.equal(result_2.y, 0);
	
	TEARDOWN();
});

test('[shape_factory.get] correct, color is set in the _ namespace', function (t) {
	t.plan(2);
	
	SETUP();
	
	var sf = shape_factory();
	sf.shape({type:"box"});
	sf.color({color:null, stroke:"black"});
	sf.text({text:0, font:"16px Arial", x:-22, y:1, textAlign:"right"});
	
	var result = sf.get();
	
	t.equal(result._.shape_fill, null);
	t.equal(result._.shape_stroke, "black");
	
	TEARDOWN();
});

test('[shape_factory._decorate] correct', function (t) {
	t.plan(21);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var container = new createjs.Container();
	var shape = new createjs.Shape();
	shape.setBounds(1, 1, 1, 1);
	var text = new createjs.Text();
	container.addChild(shape);
	container.addChild(text);
	var color = {fill:"some fill", stroke: "some stroke"}
	
	var result = sf._decorate(container, color);
	
	t.ok(result._);
	t.ok(result._.on);
	t.ok(check.function(result._.on));
	t.ok(result._.off);
	t.ok(check.function(result._.off));
	t.ok(result._.addEventListener);
	t.ok(check.function(result._.addEventListener));
	t.ok(result._.hasEventListener);
	t.ok(check.function(result._.hasEventListener));
	t.ok(result._.removeAllEventListeners);
	t.ok(check.function(result._.removeAllEventListeners));
	t.ok(result._.removeEventListener);
	t.ok(check.function(result._.removeEventListener));
	
	t.equal(container.getBounds().x, 1);
	t.equal(container.getBounds().y, 1);
	t.equal(container.getBounds().width, 1);
	t.equal(container.getBounds().height, 1);
	
	t.ok(result._.place);
	t.ok(check.object(result._.place));
	
	t.equal(result._.shape_fill, "some fill");
	t.equal(result._.shape_stroke, "some stroke");
	
	TEARDOWN();
});

test('[shape_factory._decorate] correct, add_to_stage', function (t) {
	t.plan(2);
	
	SETUP();
	
	//setup
	var sf = shape_factory();
	var container = new createjs.Container();
	var shape = new createjs.Shape();
	shape.setBounds(1, 1, 1, 1);
	var text = new createjs.Text();
	container.addChild(shape);
	container.addChild(text);
	var color = {fill:"some fill", stroke: "some stroke"}
	
	var result = sf._decorate(container, color);
	
	t.ok(check.object(result._));
	t.ok(check.function(result._.add_to_stage));
	
	TEARDOWN();
});

test("[shape_factory] incorrect, 'createjs' unset", function (t) {
	t.plan(3);
	
	//TEST
	try {
		shape_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		console.log(message);
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});

test("[shape_factory] incorrect, 'createjs' wrong type", function (t) {
	t.plan(3);
	
	//SETUP
	SETUP();
	
	var primitives = require("lib/util/primitives");
	primitives.set('createjs', '');
	
	//TEST
	try {
		shape_factory();
	} catch(error) {
		t.ok(check.instanceStrict(error, ReferenceError), 'we should get back a ReferenceError');
		var message = error.toString();
		t.ok(message.match(/createjs/), 'checking for an object in primitives');
		t.ok(message.match(/undefined or not object in primitives object/), 'defined what was wrong');
	}
	
	TEARDOWN();
});